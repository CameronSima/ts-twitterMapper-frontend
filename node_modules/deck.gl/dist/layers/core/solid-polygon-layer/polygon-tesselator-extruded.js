'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonTesselatorExtruded = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _polygon = require('./polygon');

var Polygon = _interopRequireWildcard(_polygon);

var _glMatrix = require('gl-matrix');

var _fp = require('../../../lib/utils/fp64');

var _utils = require('../../../lib/utils');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _lodash = require('lodash.flattendeep');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getPickingColor(index) {
  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];
}

function parseColor(color) {
  if (!Array.isArray(color)) {
    color = [(0, _utils.get)(color, 0), (0, _utils.get)(color, 1), (0, _utils.get)(color, 2), (0, _utils.get)(color, 3)];
  }
  color[3] = Number.isFinite(color[3]) ? color[3] : 255;
  return color;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

var PolygonTesselatorExtruded = exports.PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return [0, 0, 0, 255];
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = polygons.map(function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return Polygon.normalize(complexPolygon).map(function (polygon) {
        return polygon.map(function (coord) {
          return [(0, _utils.get)(coord, 0), (0, _utils.get)(coord, 1), height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

function countVertices(vertices) {
  return vertices.reduce(function (vertexCount, polygon) {
    return vertexCount + (0, _utils.count)(polygon);
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple polygons
  var multiplier = wireframe ? 2 : 5;
  var offsets = groupedVertices.reduce(function (acc, vertices) {
    return acc.concat(acc[acc.length - 1] + countVertices(vertices) * multiplier);
  }, [0]);

  var indices = groupedVertices.map(function (vertices, polygonIndex) {
    return wireframe ?
    // 1. get sequentially ordered indices of each polygons wireframe
    // 2. offset them by the number of indices in previous polygons
    calculateContourIndices(vertices, offsets[polygonIndex]) :
    // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous polygons
    calculateSurfaceIndices(vertices, offsets[polygonIndex]);
  });

  return new Uint32Array((0, _lodash2.default)(indices));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var positions = groupedVertices.map(function (vertices) {
    var topVertices = Array.prototype.concat.apply([], vertices);
    var baseVertices = topVertices.map(function (v) {
      return [(0, _utils.get)(v, 0), (0, _utils.get)(v, 1), 0];
    });
    return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
  });

  return (0, _lodash2.default)(positions);
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    positionLow = new Float32Array(positionsJS.length / 3 * 2);
    for (var i = 0; i < positionsJS.length / 3; i++) {
      positionLow[i * 2 + 0] = (0, _fp.fp64ify)(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = (0, _fp.fp64ify)(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      wireframe = _ref5.wireframe;

  var up = [0, 1, 0];

  var normals = groupedVertices.map(function (vertices, polygonIndex) {
    var topNormals = new Array(countVertices(vertices)).fill(up);
    var sideNormals = vertices.map(function (polygon) {
      return calculateSideNormals(polygon);
    });
    var sideNormalsForward = sideNormals.map(function (n) {
      return n[0];
    });
    var sideNormalsBackward = sideNormals.map(function (n) {
      return n[1];
    });

    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
  });

  return new Float32Array((0, _lodash2.default)(normals));
}

function calculateSideNormals(vertices) {
  var normals = [];

  var lastVertice = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vertice = _step.value;

      if (lastVertice) {
        // vertex[i-1], vertex[i]
        var n = getNormal(lastVertice, vertice);
        normals.push(n);
      }
      lastVertice = vertice;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [[normals.concat(normals[0])], [[normals[0]].concat(normals)]];
}

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color = parseColor(color);

    var numVertices = countVertices(complexPolygon);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray((0, _lodash2.default)(colors));
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var colors = groupedVertices.map(function (vertices, polygonIndex) {
    var numVertices = countVertices(vertices);
    var color = getPickingColor(polygonIndex);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray((0, _lodash2.default)(colors));
}

function calculateContourIndices(vertices, offset) {
  var stride = countVertices(vertices);

  return vertices.map(function (polygon) {
    var indices = [offset];
    var numVertices = polygon.length;

    // polygon top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // polygon sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
    return indices;
  });
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = countVertices(vertices);
  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

  function drawRectangle(i) {
    return quad.map(function (v) {
      return i + v[0] + stride * v[1] + offset;
    });
  }

  var holes = null;

  if (vertices.length > 1) {
    holes = vertices.reduce(function (acc, polygon) {
      return acc.concat(acc[acc.length - 1] + polygon.length);
    }, [0]).slice(1, vertices.length);
  }

  var topIndices = (0, _earcut2.default)((0, _lodash2.default)(vertices), holes, 3).map(function (index) {
    return index + offset;
  });

  var sideIndices = vertices.map(function (polygon) {
    var numVertices = polygon.length;
    // polygon top
    var indices = [];

    // polygon sides
    for (var i = 0; i < numVertices - 1; i++) {
      indices = indices.concat(drawRectangle(i));
    }

    offset += numVertices;
    return indices;
  });

  return [topIndices, sideIndices];
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  var p1x = (0, _utils.get)(p1, 0);
  var p1y = (0, _utils.get)(p1, 1);
  var p2x = (0, _utils.get)(p2, 0);
  var p2y = (0, _utils.get)(p2, 1);

  if (p1x === p2x && p1y === p2y) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;
  var lon1 = degrees2radians * p1x;
  var lon2 = degrees2radians * p2x;
  var lat1 = degrees2radians * p1y;
  var lat2 = degrees2radians * p2y;
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return _glMatrix.vec3.normalize([], [b, 0, -a]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZ2V0UGlja2luZ0NvbG9yIiwiaW5kZXgiLCJwYXJzZUNvbG9yIiwiY29sb3IiLCJBcnJheSIsImlzQXJyYXkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbnNKUyIsImNhbGN1bGF0ZVBvc2l0aW9uc0pTIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb25zIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiaW5kaWNlcyIsImNhbGN1bGF0ZUluZGljZXMiLCJub3JtYWxzIiwiY2FsY3VsYXRlTm9ybWFscyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwiY2FsY3VsYXRlQ29sb3JzIiwiY291bnRWZXJ0aWNlcyIsInZlcnRpY2VzIiwicmVkdWNlIiwidmVydGV4Q291bnQiLCJtdWx0aXBsaWVyIiwib2Zmc2V0cyIsImFjYyIsImNvbmNhdCIsImxlbmd0aCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJVaW50MzJBcnJheSIsInRvcFZlcnRpY2VzIiwicHJvdG90eXBlIiwiYXBwbHkiLCJiYXNlVmVydGljZXMiLCJ2IiwicG9zaXRpb25Mb3ciLCJGbG9hdDMyQXJyYXkiLCJpIiwicG9zaXRpb25zNjR4eUxvdyIsInVwIiwidG9wTm9ybWFscyIsImZpbGwiLCJzaWRlTm9ybWFscyIsImNhbGN1bGF0ZVNpZGVOb3JtYWxzIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwibiIsInNpZGVOb3JtYWxzQmFja3dhcmQiLCJsYXN0VmVydGljZSIsInZlcnRpY2UiLCJnZXROb3JtYWwiLCJwdXNoIiwiY29sb3JzIiwibnVtVmVydGljZXMiLCJ0b3BDb2xvcnMiLCJiYXNlQ29sb3JzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJvZmZzZXQiLCJzdHJpZGUiLCJxdWFkIiwiZHJhd1JlY3RhbmdsZSIsImhvbGVzIiwic2xpY2UiLCJ0b3BJbmRpY2VzIiwic2lkZUluZGljZXMiLCJwMSIsInAyIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwiZGVncmVlczJyYWRpYW5zIiwiTWF0aCIsIlBJIiwibG9uMSIsImxvbjIiLCJsYXQxIiwibGF0MiIsImEiLCJzaW4iLCJjb3MiLCJiIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7SUFBWUEsTzs7QUFDWjs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUEsU0FBU0MsZUFBVCxDQUF5QkMsS0FBekIsRUFBZ0M7QUFDOUIsU0FBTyxDQUNKQSxRQUFRLENBQVQsR0FBYyxHQURULEVBRUhBLFFBQVEsQ0FBVCxJQUFlLENBQWhCLEdBQXFCLEdBRmhCLEVBR0ZBLFFBQVEsQ0FBVCxJQUFlLENBQWhCLElBQXNCLENBQXZCLEdBQTRCLEdBSHZCLENBQVA7QUFLRDs7QUFFRCxTQUFTQyxVQUFULENBQW9CQyxLQUFwQixFQUEyQjtBQUN6QixNQUFJLENBQUNDLE1BQU1DLE9BQU4sQ0FBY0YsS0FBZCxDQUFMLEVBQTJCO0FBQ3pCQSxZQUFRLENBQUMsZ0JBQUlBLEtBQUosRUFBVyxDQUFYLENBQUQsRUFBZ0IsZ0JBQUlBLEtBQUosRUFB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QVo7QUFDQSxNQUFNRyxNQUFNLGdCQUFJSCxFQUFKLEVBQVEsQ0FBUixDQUFaO0FBQ0EsTUFBTUksTUFBTSxnQkFBSUgsRUFBSixFQUFRLENBQVIsQ0FBWjtBQUNBLE1BQU1JLE1BQU0sZ0JBQUlKLEVBQUosRUFBUSxDQUFSLENBQVo7O0FBRUEsTUFBSUMsUUFBUUUsR0FBUixJQUFlRCxRQUFRRSxHQUEzQixFQUFnQztBQUM5QixXQUFPLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVA7QUFDRDs7QUFFRCxNQUFNQyxrQkFBa0JDLEtBQUtDLEVBQUwsR0FBVSxHQUFsQztBQUNBLE1BQU1DLE9BQU9ILGtCQUFrQkosR0FBL0I7QUFDQSxNQUFNUSxPQUFPSixrQkFBa0JGLEdBQS9CO0FBQ0EsTUFBTU8sT0FBT0wsa0JBQWtCSCxHQUEvQjtBQUNBLE1BQU1TLE9BQU9OLGtCQUFrQkQsR0FBL0I7QUFDQSxNQUFNUSxJQUFJTixLQUFLTyxHQUFMLENBQVNKLE9BQU9ELElBQWhCLElBQXdCRixLQUFLUSxHQUFMLENBQVNILElBQVQsQ0FBbEM7QUFDQSxNQUFNSSxJQUFJVCxLQUFLUSxHQUFMLENBQVNKLElBQVQsSUFBaUJKLEtBQUtPLEdBQUwsQ0FBU0YsSUFBVCxDQUFqQixHQUNSTCxLQUFLTyxHQUFMLENBQVNILElBQVQsSUFBaUJKLEtBQUtRLEdBQUwsQ0FBU0gsSUFBVCxDQUFqQixHQUFrQ0wsS0FBS1EsR0FBTCxDQUFTTCxPQUFPRCxJQUFoQixDQURwQztBQUVBLFNBQU8sZUFBS3pFLFNBQUwsQ0FBZSxFQUFmLEVBQW1CLENBQUNnRixDQUFELEVBQUksQ0FBSixFQUFPLENBQUNILENBQVIsQ0FBbkIsQ0FBUDtBQUNEIiwiZmlsZSI6InBvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQge3ZlYzN9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQge2ZwNjRpZnl9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Z2V0LCBjb3VudH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2guZmxhdHRlbmRlZXAnO1xuXG5mdW5jdGlvbiBnZXRQaWNraW5nQ29sb3IoaW5kZXgpIHtcbiAgcmV0dXJuIFtcbiAgICAoaW5kZXggKyAxKSAmIDI1NSxcbiAgICAoKGluZGV4ICsgMSkgPj4gOCkgJiAyNTUsXG4gICAgKCgoaW5kZXggKyAxKSA+PiA4KSA+PiA4KSAmIDI1NVxuICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKGNvbG9yKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICBjb2xvciA9IFtnZXQoY29sb3IsIDApLCBnZXQoY29sb3IsIDEpLCBnZXQoY29sb3IsIDIpLCBnZXQoY29sb3IsIDMpXTtcbiAgfVxuICBjb2xvclszXSA9IE51bWJlci5pc0Zpbml0ZShjb2xvclszXSkgPyBjb2xvclszXSA6IDI1NTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07IC8vIEJsYWNrXG5cbmV4cG9ydCBjbGFzcyBQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIHtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcG9seWdvbnMsXG4gICAgZ2V0SGVpZ2h0ID0geCA9PiAxMDAwLFxuICAgIGdldENvbG9yID0geCA9PiBbMCwgMCwgMCwgMjU1XSxcbiAgICB3aXJlZnJhbWUgPSBmYWxzZSxcbiAgICBmcDY0ID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuZnA2NCA9IGZwNjQ7XG5cbiAgICAvLyBFeHBlbnNpdmUgb3BlcmF0aW9uLCBjb252ZXJ0IGFsbCBwb2x5Z29ucyB0byBhcnJheXNcbiAgICBwb2x5Z29ucyA9IHBvbHlnb25zLm1hcCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHBvbHlnb25JbmRleCkgfHwgMDtcbiAgICAgIHJldHVybiBQb2x5Z29uLm5vcm1hbGl6ZShjb21wbGV4UG9seWdvbikubWFwKFxuICAgICAgICBwb2x5Z29uID0+IHBvbHlnb24ubWFwKGNvb3JkID0+IFtnZXQoY29vcmQsIDApLCBnZXQoY29vcmQsIDEpLCBoZWlnaHRdKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdyb3VwZWRWZXJ0aWNlcyA9IHBvbHlnb25zO1xuICAgIHRoaXMuZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy53aXJlZnJhbWUgPSB3aXJlZnJhbWU7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGNvbnN0IHBvc2l0aW9uc0pTID0gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uczogY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCB0aGlzLmZwNjQpLFxuICAgICAgaW5kaWNlczogY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIG5vcm1hbHM6IGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSksXG4gICAgICAvLyBjb2xvcnM6IGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSksXG4gICAgICBwaWNraW5nQ29sb3JzOiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pXG4gICAgfSk7XG4gIH1cblxuICBpbmRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuaW5kaWNlcztcbiAgfVxuXG4gIHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9ucztcbiAgfVxuXG4gIG5vcm1hbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ub3JtYWxzO1xuICB9XG5cbiAgY29sb3JzKHtnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUn0gPSB7fSkge1xuICAgIGNvbnN0IHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lLCBnZXRDb2xvcn0pO1xuICB9XG5cbiAgcGlja2luZ0NvbG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBpY2tpbmdDb2xvcnM7XG4gIH1cblxuICAvLyB1cGRhdGVUcmlnZ2Vyczoge1xuICAvLyAgIHBvc2l0aW9uczogWydnZXRIZWlnaHQnXSxcbiAgLy8gICBjb2xvcnM6IFsnZ2V0Q29sb3JzJ11cbiAgLy8gICBwaWNraW5nQ29sb3JzOiAnbm9uZSdcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHJldHVybiB2ZXJ0aWNlcy5yZWR1Y2UoKHZlcnRleENvdW50LCBwb2x5Z29uKSA9PiB2ZXJ0ZXhDb3VudCArIGNvdW50KHBvbHlnb24pLCAwKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgcG9seWdvbnNcbiAgY29uc3QgbXVsdGlwbGllciA9IHdpcmVmcmFtZSA/IDIgOiA1O1xuICBjb25zdCBvZmZzZXRzID0gZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZShcbiAgICAoYWNjLCB2ZXJ0aWNlcykgPT5cbiAgICAgIGFjYy5jb25jYXQoYWNjW2FjYy5sZW5ndGggLSAxXSArIGNvdW50VmVydGljZXModmVydGljZXMpICogbXVsdGlwbGllciksXG4gICAgWzBdXG4gICk7XG5cbiAgY29uc3QgaW5kaWNlcyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKHZlcnRpY2VzLCBwb2x5Z29uSW5kZXgpID0+XG4gICAgd2lyZWZyYW1lID9cbiAgICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggcG9seWdvbnMgd2lyZWZyYW1lXG4gICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgcG9seWdvbnNcbiAgICAgIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW3BvbHlnb25JbmRleF0pIDpcbiAgICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgcG9seWdvbnNcbiAgICAgIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW3BvbHlnb25JbmRleF0pXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShmbGF0dGVuRGVlcChpbmRpY2VzKSk7XG59XG5cbi8vIENhbGN1bGF0ZSBhIGZsYXQgcG9zaXRpb24gYXJyYXkgaW4gSlMgLSBjYW4gYmUgbWFwcGVkIHRvIDMyIG9yIDY0IGJpdCB0eXBlZCBhcnJheXNcbi8vIFJlbWFya3M6XG4vLyAqIGVhY2ggdG9wIHZlcnRleCBpcyBvbiAzIHN1cmZhY2VzXG4vLyAqIGVhY2ggYm90dG9tIHZlcnRleCBpcyBvbiAyIHN1cmZhY2VzXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnNKUyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgcG9zaXRpb25zID0gZ3JvdXBlZFZlcnRpY2VzLm1hcChcbiAgICB2ZXJ0aWNlcyA9PiB7XG4gICAgICBjb25zdCB0b3BWZXJ0aWNlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHZlcnRpY2VzKTtcbiAgICAgIGNvbnN0IGJhc2VWZXJ0aWNlcyA9IHRvcFZlcnRpY2VzLm1hcCh2ID0+IFtnZXQodiwgMCksIGdldCh2LCAxKSwgMF0pO1xuICAgICAgcmV0dXJuIHdpcmVmcmFtZSA/IFt0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXSA6XG4gICAgICAgIFt0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCBiYXNlVmVydGljZXMsIGJhc2VWZXJ0aWNlc107XG4gICAgfVxuICApO1xuXG4gIHJldHVybiBmbGF0dGVuRGVlcChwb3NpdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnMocG9zaXRpb25zSlMsIGZwNjQpIHtcbiAgbGV0IHBvc2l0aW9uTG93O1xuICBpZiAoZnA2NCkge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB4LCB5IGNvbXBvbmVudFxuICAgIHBvc2l0aW9uTG93ID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnNKUy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnNKUy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIHBvc2l0aW9uTG93W2kgKiAyICsgMF0gPSBmcDY0aWZ5KHBvc2l0aW9uc0pTW2kgKiAzICsgMF0pWzFdO1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAxXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAxXSlbMV07XG4gICAgfVxuXG4gIH1cbiAgcmV0dXJuIHtwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zSlMpLCBwb3NpdGlvbnM2NHh5TG93OiBwb3NpdGlvbkxvd307XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSkge1xuICBjb25zdCB1cCA9IFswLCAxLCAwXTtcblxuICBjb25zdCBub3JtYWxzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IHRvcE5vcm1hbHMgPSBuZXcgQXJyYXkoY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykpLmZpbGwodXApO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzID0gdmVydGljZXMubWFwKHBvbHlnb24gPT4gY2FsY3VsYXRlU2lkZU5vcm1hbHMocG9seWdvbikpO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzRm9yd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChuID0+IG5bMF0pO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzQmFja3dhcmQgPSBzaWRlTm9ybWFscy5tYXAobiA9PiBuWzFdKTtcblxuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgIFt0b3BOb3JtYWxzLCB0b3BOb3JtYWxzXSA6XG4gICAgW3RvcE5vcm1hbHMsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZCwgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkXTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbkRlZXAobm9ybWFscykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTaWRlTm9ybWFscyh2ZXJ0aWNlcykge1xuICBjb25zdCBub3JtYWxzID0gW107XG5cbiAgbGV0IGxhc3RWZXJ0aWNlID0gbnVsbDtcbiAgZm9yIChjb25zdCB2ZXJ0aWNlIG9mIHZlcnRpY2VzKSB7XG4gICAgaWYgKGxhc3RWZXJ0aWNlKSB7XG4gICAgICAvLyB2ZXJ0ZXhbaS0xXSwgdmVydGV4W2ldXG4gICAgICBjb25zdCBuID0gZ2V0Tm9ybWFsKGxhc3RWZXJ0aWNlLCB2ZXJ0aWNlKTtcbiAgICAgIG5vcm1hbHMucHVzaChuKTtcbiAgICB9XG4gICAgbGFzdFZlcnRpY2UgPSB2ZXJ0aWNlO1xuICB9XG5cbiAgcmV0dXJuIFtbbm9ybWFscy5jb25jYXQobm9ybWFsc1swXSldLCBbW25vcm1hbHNbMF1dLmNvbmNhdChub3JtYWxzKV1dO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgZ2V0Q29sb3IsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBjb2xvcnMgPSBncm91cGVkVmVydGljZXMubWFwKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgbGV0IGNvbG9yID0gZ2V0Q29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb2xvciA9IHBhcnNlQ29sb3IoY29sb3IpO1xuXG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKGNvbXBsZXhQb2x5Z29uKTtcbiAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIGNvbnN0IGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgY29sb3JzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gICAgY29uc3QgY29sb3IgPSBnZXRQaWNraW5nQ29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIGNvbnN0IGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICByZXR1cm4gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgIGNvbnN0IGluZGljZXMgPSBbb2Zmc2V0XTtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gcG9seWdvbiB0b3BcbiAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBHTC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTEsIG4tMSwgMF1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQpO1xuXG4gICAgLy8gcG9seWdvbiBzaWRlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgc3RyaWRlICsgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHN0cmlkZSA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuICBjb25zdCBxdWFkID0gW1xuICAgIFswLCAxXSwgWzAsIDNdLCBbMSwgMl0sXG4gICAgWzEsIDJdLCBbMCwgM10sIFsxLCA0XVxuICBdO1xuXG4gIGZ1bmN0aW9uIGRyYXdSZWN0YW5nbGUoaSkge1xuICAgIHJldHVybiBxdWFkLm1hcCh2ID0+IGkgKyB2WzBdICsgc3RyaWRlICogdlsxXSArIG9mZnNldCk7XG4gIH1cblxuICBsZXQgaG9sZXMgPSBudWxsO1xuXG4gIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAxKSB7XG4gICAgaG9sZXMgPSB2ZXJ0aWNlcy5yZWR1Y2UoXG4gICAgICAoYWNjLCBwb2x5Z29uKSA9PiBhY2MuY29uY2F0KGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aCksXG4gICAgICBbMF1cbiAgICApLnNsaWNlKDEsIHZlcnRpY2VzLmxlbmd0aCk7XG4gIH1cblxuICBjb25zdCB0b3BJbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW5EZWVwKHZlcnRpY2VzKSwgaG9sZXMsIDMpLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldCk7XG5cbiAgY29uc3Qgc2lkZUluZGljZXMgPSB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICAvLyBwb2x5Z29uIHRvcFxuICAgIGxldCBpbmRpY2VzID0gW107XG5cbiAgICAvLyBwb2x5Z29uIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcyA9IGluZGljZXMuY29uY2F0KGRyYXdSZWN0YW5nbGUoaSkpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSk7XG5cbiAgcmV0dXJuIFt0b3BJbmRpY2VzLCBzaWRlSW5kaWNlc107XG59XG5cbi8vIGhlbHBlcnNcblxuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIGNvbnN0IHAxeCA9IGdldChwMSwgMCk7XG4gIGNvbnN0IHAxeSA9IGdldChwMSwgMSk7XG4gIGNvbnN0IHAyeCA9IGdldChwMiwgMCk7XG4gIGNvbnN0IHAyeSA9IGdldChwMiwgMSk7XG5cbiAgaWYgKHAxeCA9PT0gcDJ4ICYmIHAxeSA9PT0gcDJ5KSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwXTtcbiAgfVxuXG4gIGNvbnN0IGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gIGNvbnN0IGxvbjEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMXg7XG4gIGNvbnN0IGxvbjIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMng7XG4gIGNvbnN0IGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMXk7XG4gIGNvbnN0IGxhdDIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMnk7XG4gIGNvbnN0IGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgY29uc3QgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsb24yIC0gbG9uMSk7XG4gIHJldHVybiB2ZWMzLm5vcm1hbGl6ZShbXSwgW2IsIDAsIC1hXSk7XG59XG4iXX0=