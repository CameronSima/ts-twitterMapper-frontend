'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


var _constants = require('./constants');

var _attributeManager = require('./attribute-manager');

var _attributeManager2 = _interopRequireDefault(_attributeManager);

var _stats = require('./stats');

var _stats2 = _interopRequireDefault(_stats);

var _props2 = require('./props');

var _utils = require('./utils');

var _seerIntegration = require('../debug/seer-integration');

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_UPDATE = 1;

var EMPTY_ARRAY = [];
var noop = function noop() {};

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var defaultProps = {
  // data: Special handling for null, see below
  dataComparator: null,
  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl
  numInstances: undefined,

  visible: true,
  pickable: false,
  opacity: 0.8,

  onHover: noop,
  onClick: noop,

  projectionMode: _constants.COORDINATE_SYSTEM.LNGLAT,

  settings: {},
  uniforms: {},
  framebuffer: null,

  animation: null, // Passed prop animation functions to evaluate props

  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  }
};

var counter = 0;

var Layer = function () {
  /**
   * @class
   * @param {object} props - See docs and defaults above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    // If sublayer has static defaultProps member, getDefaultProps will return it
    var mergedDefaultProps = (0, _props2.getDefaultProps)(this);
    // Merge supplied props with pre-merged default props
    props = Object.assign({}, mergedDefaultProps, props);
    // Accept null as data - otherwise apps and layers need to add ugly checks
    // Use constant fallback so that data change is not triggered
    props.data = props.data || EMPTY_ARRAY;
    // Apply any overrides from the seer debug extension if it is active
    (0, _seerIntegration.applyPropOverrides)(props);
    // Props are immutable
    Object.freeze(props);

    // Define all members
    this.id = props.id; // The layer's id, used for matching with layers' from last render cyckle
    this.props = props; // Current props, a frozen object
    this.animatedProps = null; // Computing animated props requires layer manager state
    this.oldProps = null; // Props from last render used for change detection
    this.state = null; // Will be set to the shared layer state object during layer matching
    this.context = null; // Will reference layer manager's context, contains state shared by layers
    this.count = counter++; // Keep track of how many layer instances you are generating
    this.lifecycle = _constants.LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers
    // CompositeLayer members, need to be defined here because of the `Object.seal`
    this.parentLayer = null; // reference to the composite layer parent that rendered this layer
    this.oldSubLayers = []; // reference to sublayers rendered in the previous cycle
    // Seal the layer
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className !== this.props.id ? '<' + className + ':\'' + this.props.id + '\'>' : '<' + className + '>';
    }
  }, {
    key: 'initializeState',


    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      return changeFlags.propsOrDataChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          oldContext = _ref3.oldContext,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;

      if (changeFlags.dataChanged) {
        this.invalidateAttribute('all');
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref4) {
      var _ref4$uniforms = _ref4.uniforms,
          uniforms = _ref4$uniforms === undefined ? {} : _ref4$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var color = info.color,
          index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      // TODO - move to the JS part of a shader picking shader package
      if (mode === 'hover') {
        var selectedPickingColor = new Float32Array(3);
        selectedPickingColor[0] = color[0];
        selectedPickingColor[1] = color[1];
        selectedPickingColor[2] = color[2];
        this.setUniforms({ selectedPickingColor: selectedPickingColor });
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefine

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

      if (name === 'all') {
        this.state.attributeManager.invalidateAll();
      } else {
        this.state.attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      if (!attributeManager) {
        return;
      }

      // Figure out data length
      var numInstances = this.getNumInstances(props);

      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      (0, _assert2.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return (0, _utils.count)(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      (0, _assert2.default)(this.context.gl, 'Layer context missing gl');
      (0, _assert2.default)(!this.state, 'Layer missing state');

      this.state = {};
      this.state.stats = new _stats2.default({ id: 'draw' });

      // Initialize state only once
      this.setState({
        attributeManager: new _attributeManager2.default({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState();
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        _utils.log.once(0, 'deck.gl v3 ' + this + ': "shouldUpdate" deprecated, renamed to "shouldUpdateState"');
      }

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {
        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this.updateAttributes(updateParams.props);
        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState();
      // End lifecycle method
      (0, _seerIntegration.removeLayerInSeer)(this.id);
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref7) {
      var _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms;
      var getPolygonOffset = this.props.getPolygonOffset;

      // Apply polygon offset to avoid z-fighting

      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      var settings = {
        polygonOffset: offsets
      };

      // Call subclass lifecycle method
      this.draw({ uniforms: uniforms, settings: settings });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // First check if any props have changed (ignore props that will be examined separately)
      var propsChangedReason = (0, _props2.compareProps)({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      // Now check if any data related props have changed
      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var propsOrDataChanged = propsChanged || dataChanged;
      var viewportChanged = context.viewportChanged;
      var somethingChanged = propsChanged || dataChanged || viewportChanged;

      // Check update triggers to determine if any attributes need regeneration
      // Note - if data has changed, all attributes will need regeneration, so skip this step
      if (!dataChanged) {
        this._diffUpdateTriggers(oldProps, newProps);
      }

      // Trace what happened
      if (dataChanged) {
        _utils.log.log(LOG_PRIORITY_UPDATE, 'dataChanged: ' + dataChangedReason + ' in ' + this.id);
      } else if (propsChanged) {
        _utils.log.log(LOG_PRIORITY_UPDATE, 'propsChanged: ' + propsChangedReason + ' in ' + this.id);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        propsOrDataChanged: propsOrDataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason || 'Viewport changed'
      };
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      if (oldProps === null) {
        return 'oldProps is null, initial diff';
      }

      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      // const {attributeManager} = this.state;
      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();
      if (oldProps === null) {
        return true; // oldProps is null, initial diff
      }

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName] || {};
        var newTriggers = newProps.updateTriggers[propName] || {};
        var diffReason = (0, _props2.compareProps)({
          oldProps: oldTriggers,
          newProps: newTriggers,
          triggerName: propName
        });
        if (diffReason) {
          if (propName === 'all') {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
            this.invalidateAttribute('all');
            change = true;
          } else {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            this.invalidateAttribute(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Emits a warning if an old prop is used, optionally suggesting a replacement

  }, {
    key: '_checkRemovedProp',
    value: function _checkRemovedProp(oldProp) {
      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.props[oldProp] !== undefined) {
        var layerName = this.constructor;
        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';
        if (newProp) {
          message += '\nPlease use props.' + newProp + ' instead.';
        }
        _utils.log.once(0, message);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      (0, _utils.log)(3, 'layer.setUniforms', uniformMap);
    }
  }, {
    key: 'stats',
    get: function get() {
      return this.state.stats;
    }
  }]);

  return Layer;
}();

exports.default = Layer;


Layer.layerName = 'Layer';
Layer.propTypes = defaultProps;
Layer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXIuanMiXSwibmFtZXMiOlsiTE9HX1BSSU9SSVRZX1VQREFURSIsIkVNUFRZX0FSUkFZIiwibm9vcCIsImRlZmF1bHRQcm9wcyIsImRhdGFDb21wYXJhdG9yIiwidXBkYXRlVHJpZ2dlcnMiLCJudW1JbnN0YW5jZXMiLCJ1bmRlZmluZWQiLCJ2aXNpYmxlIiwicGlja2FibGUiLCJvcGFjaXR5Iiwib25Ib3ZlciIsIm9uQ2xpY2siLCJwcm9qZWN0aW9uTW9kZSIsIkxOR0xBVCIsInNldHRpbmdzIiwidW5pZm9ybXMiLCJmcmFtZWJ1ZmZlciIsImFuaW1hdGlvbiIsImdldFBvbHlnb25PZmZzZXQiLCJsYXllckluZGV4IiwiY291bnRlciIsIkxheWVyIiwicHJvcHMiLCJtZXJnZWREZWZhdWx0UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJkYXRhIiwiZnJlZXplIiwiaWQiLCJhbmltYXRlZFByb3BzIiwib2xkUHJvcHMiLCJzdGF0ZSIsImNvbnRleHQiLCJjb3VudCIsImxpZmVjeWNsZSIsIk5PX1NUQVRFIiwicGFyZW50TGF5ZXIiLCJvbGRTdWJMYXllcnMiLCJzZWFsIiwiY2xhc3NOYW1lIiwiY29uc3RydWN0b3IiLCJsYXllck5hbWUiLCJuYW1lIiwiRXJyb3IiLCJvbGRDb250ZXh0IiwiY2hhbmdlRmxhZ3MiLCJwcm9wc09yRGF0YUNoYW5nZWQiLCJkYXRhQ2hhbmdlZCIsImludmFsaWRhdGVBdHRyaWJ1dGUiLCJtb2RlbCIsInJlbmRlciIsImluZm8iLCJtb2RlIiwiY29sb3IiLCJpbmRleCIsIkFycmF5IiwiaXNBcnJheSIsIm9iamVjdCIsInNlbGVjdGVkUGlja2luZ0NvbG9yIiwiRmxvYXQzMkFycmF5Iiwic2V0VW5pZm9ybXMiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiaW52YWxpZGF0ZUFsbCIsImludmFsaWRhdGUiLCJnZXROdW1JbnN0YW5jZXMiLCJ1cGRhdGUiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJzZXRBdHRyaWJ1dGVzIiwidXBkYXRlT2JqZWN0IiwibmVlZHNSZWRyYXciLCJyZWRyYXciLCJsbmdMYXQiLCJ2aWV3cG9ydCIsInByb2plY3QiLCJ4eSIsInVucHJvamVjdCIsInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsInNjcmVlblBpeGVscyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJpIiwiVWludDhBcnJheSIsImkxIiwiaTIiLCJpMyIsImF0dHJpYnV0ZSIsInZhbHVlIiwic2l6ZSIsInBpY2tpbmdDb2xvciIsImVuY29kZVBpY2tpbmdDb2xvciIsInVwZGF0ZVBhcmFtcyIsImdsIiwic3RhdHMiLCJzZXRTdGF0ZSIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlUGlja2luZ0NvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzIiwiaW5pdGlhbGl6ZVN0YXRlIiwidXBkYXRlU3RhdGUiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiX3VwZGF0ZUJhc2VVbmlmb3JtcyIsInNldEluc3RhbmNlQ291bnQiLCJwcm9ncmFtIiwiZ2VvbWV0cnkiLCJnZXRBdHRyaWJ1dGVzIiwic2hvdWxkVXBkYXRlIiwib25jZSIsInN0YXRlTmVlZHNVcGRhdGUiLCJzaG91bGRVcGRhdGVTdGF0ZSIsImZpbmFsaXplU3RhdGUiLCJvZmZzZXRzIiwicG9seWdvbk9mZnNldCIsImRyYXciLCJvcHRzIiwiZ2V0UGlja2luZ0luZm8iLCJjbGVhclJlZHJhd0ZsYWdzIiwiZ2V0TmVlZHNSZWRyYXciLCJuZXdQcm9wcyIsInByb3BzQ2hhbmdlZFJlYXNvbiIsImlnbm9yZVByb3BzIiwiZGF0YUNoYW5nZWRSZWFzb24iLCJfZGlmZkRhdGFQcm9wcyIsInByb3BzQ2hhbmdlZCIsIkJvb2xlYW4iLCJ2aWV3cG9ydENoYW5nZWQiLCJzb21ldGhpbmdDaGFuZ2VkIiwiX2RpZmZVcGRhdGVUcmlnZ2VycyIsImxvZyIsInJlYXNvbiIsImNoYW5nZSIsInByb3BOYW1lIiwib2xkVHJpZ2dlcnMiLCJuZXdUcmlnZ2VycyIsImRpZmZSZWFzb24iLCJ0cmlnZ2VyTmFtZSIsInByb3BlcnR5TmFtZSIsImNvbmRpdGlvbiIsIm9sZFByb3AiLCJuZXdQcm9wIiwibWVzc2FnZSIsIk1hdGgiLCJwb3ciLCJPTkUiLCJ1bmlmb3JtTWFwIiwicHJvcFR5cGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztxakJBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNQSxzQkFBc0IsQ0FBNUI7O0FBRUEsSUFBTUMsY0FBYyxFQUFwQjtBQUNBLElBQU1DLE9BQU8sU0FBUEEsSUFBTyxHQUFNLENBQUUsQ0FBckI7O0FBRUE7Ozs7O0FBS0EsSUFBTUMsZUFBZTtBQUNuQjtBQUNBQyxrQkFBZ0IsSUFGRztBQUduQkMsa0JBQWdCLEVBSEcsRUFHQztBQUNwQkMsZ0JBQWNDLFNBSks7O0FBTW5CQyxXQUFTLElBTlU7QUFPbkJDLFlBQVUsS0FQUztBQVFuQkMsV0FBUyxHQVJVOztBQVVuQkMsV0FBU1QsSUFWVTtBQVduQlUsV0FBU1YsSUFYVTs7QUFhbkJXLGtCQUFnQiw2QkFBa0JDLE1BYmY7O0FBZW5CQyxZQUFVLEVBZlM7QUFnQm5CQyxZQUFVLEVBaEJTO0FBaUJuQkMsZUFBYSxJQWpCTTs7QUFtQm5CQyxhQUFXLElBbkJRLEVBbUJGOztBQUVqQjtBQUNBO0FBQ0E7QUFDQUMsb0JBQWtCO0FBQUEsUUFBRUMsVUFBRixRQUFFQSxVQUFGO0FBQUEsV0FBa0IsQ0FBQyxDQUFELEVBQUksQ0FBQ0EsVUFBRCxHQUFjLEdBQWxC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O0FBQ0Esc0JBQUksQ0FBSixFQUFPLG1CQUFQLEVBQTRCNkUsVUFBNUI7QUFDRDs7O3dCQTlmVztBQUNWLGFBQU8sS0FBS3ZILEtBQUwsQ0FBV2tFLEtBQWxCO0FBQ0Q7Ozs7OztrQkF6Q2tCNUUsSzs7O0FBd2lCckJBLE1BQU1vQixTQUFOLEdBQWtCLE9BQWxCO0FBQ0FwQixNQUFNa0ksU0FBTixHQUFrQnJKLFlBQWxCO0FBQ0FtQixNQUFNbkIsWUFBTixHQUFxQkEsWUFBckIiLCJmaWxlIjoibGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTSwgTElGRUNZQ0xFfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgQXR0cmlidXRlTWFuYWdlciBmcm9tICcuL2F0dHJpYnV0ZS1tYW5hZ2VyJztcbmltcG9ydCBTdGF0cyBmcm9tICcuL3N0YXRzJztcbmltcG9ydCB7Z2V0RGVmYXVsdFByb3BzLCBjb21wYXJlUHJvcHN9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHtsb2csIGNvdW50fSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7YXBwbHlQcm9wT3ZlcnJpZGVzLCByZW1vdmVMYXllckluU2Vlcn0gZnJvbSAnLi4vZGVidWcvc2Vlci1pbnRlZ3JhdGlvbic7XG5pbXBvcnQge0dMfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgTE9HX1BSSU9SSVRZX1VQREFURSA9IDE7XG5cbmNvbnN0IEVNUFRZX0FSUkFZID0gW107XG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuaWQgLSBsYXllciBuYW1lXG4gKiBAcGFyYW0ge2FycmF5fSAgcHJvcHMuZGF0YSAtIGFycmF5IG9mIGRhdGEgaW5zdGFuY2VzXG4gKiBAcGFyYW0ge2Jvb2x9IHByb3BzLm9wYWNpdHkgLSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICovXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIC8vIGRhdGE6IFNwZWNpYWwgaGFuZGxpbmcgZm9yIG51bGwsIHNlZSBiZWxvd1xuICBkYXRhQ29tcGFyYXRvcjogbnVsbCxcbiAgdXBkYXRlVHJpZ2dlcnM6IHt9LCAvLyBVcGRhdGUgdHJpZ2dlcnM6IGEgY29yZSBjaGFuZ2UgZGV0ZWN0aW9uIG1lY2hhbmlzbSBpbiBkZWNrLmdsXG4gIG51bUluc3RhbmNlczogdW5kZWZpbmVkLFxuXG4gIHZpc2libGU6IHRydWUsXG4gIHBpY2thYmxlOiBmYWxzZSxcbiAgb3BhY2l0eTogMC44LFxuXG4gIG9uSG92ZXI6IG5vb3AsXG4gIG9uQ2xpY2s6IG5vb3AsXG5cbiAgcHJvamVjdGlvbk1vZGU6IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCxcblxuICBzZXR0aW5nczoge30sXG4gIHVuaWZvcm1zOiB7fSxcbiAgZnJhbWVidWZmZXI6IG51bGwsXG5cbiAgYW5pbWF0aW9uOiBudWxsLCAvLyBQYXNzZWQgcHJvcCBhbmltYXRpb24gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIHByb3BzXG5cbiAgLy8gT2Zmc2V0IGRlcHRoIGJhc2VkIG9uIGxheWVyIGluZGV4IHRvIGF2b2lkIHotZmlnaHRpbmcuXG4gIC8vIE5lZ2F0aXZlIHZhbHVlcyBwdWxsIGxheWVyIHRvd2FyZHMgdGhlIGNhbWVyYVxuICAvLyBodHRwczovL3d3dy5vcGVuZ2wub3JnL2FyY2hpdmVzL3Jlc291cmNlcy9mYXEvdGVjaG5pY2FsL3BvbHlnb25vZmZzZXQuaHRtXG4gIGdldFBvbHlnb25PZmZzZXQ6ICh7bGF5ZXJJbmRleH0pID0+IFswLCAtbGF5ZXJJbmRleCAqIDEwMF1cbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIFNlZSBkb2NzIGFuZCBkZWZhdWx0cyBhYm92ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAvLyBJZiBzdWJsYXllciBoYXMgc3RhdGljIGRlZmF1bHRQcm9wcyBtZW1iZXIsIGdldERlZmF1bHRQcm9wcyB3aWxsIHJldHVybiBpdFxuICAgIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcyh0aGlzKTtcbiAgICAvLyBNZXJnZSBzdXBwbGllZCBwcm9wcyB3aXRoIHByZS1tZXJnZWQgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkRGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQWNjZXB0IG51bGwgYXMgZGF0YSAtIG90aGVyd2lzZSBhcHBzIGFuZCBsYXllcnMgbmVlZCB0byBhZGQgdWdseSBjaGVja3NcbiAgICAvLyBVc2UgY29uc3RhbnQgZmFsbGJhY2sgc28gdGhhdCBkYXRhIGNoYW5nZSBpcyBub3QgdHJpZ2dlcmVkXG4gICAgcHJvcHMuZGF0YSA9IHByb3BzLmRhdGEgfHwgRU1QVFlfQVJSQVk7XG4gICAgLy8gQXBwbHkgYW55IG92ZXJyaWRlcyBmcm9tIHRoZSBzZWVyIGRlYnVnIGV4dGVuc2lvbiBpZiBpdCBpcyBhY3RpdmVcbiAgICBhcHBseVByb3BPdmVycmlkZXMocHJvcHMpO1xuICAgIC8vIFByb3BzIGFyZSBpbW11dGFibGVcbiAgICBPYmplY3QuZnJlZXplKHByb3BzKTtcblxuICAgIC8vIERlZmluZSBhbGwgbWVtYmVyc1xuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDsgLy8gVGhlIGxheWVyJ3MgaWQsIHVzZWQgZm9yIG1hdGNoaW5nIHdpdGggbGF5ZXJzJyBmcm9tIGxhc3QgcmVuZGVyIGN5Y2tsZVxuICAgIHRoaXMucHJvcHMgPSBwcm9wczsgLy8gQ3VycmVudCBwcm9wcywgYSBmcm96ZW4gb2JqZWN0XG4gICAgdGhpcy5hbmltYXRlZFByb3BzID0gbnVsbDsgLy8gQ29tcHV0aW5nIGFuaW1hdGVkIHByb3BzIHJlcXVpcmVzIGxheWVyIG1hbmFnZXIgc3RhdGVcbiAgICB0aGlzLm9sZFByb3BzID0gbnVsbDsgLy8gUHJvcHMgZnJvbSBsYXN0IHJlbmRlciB1c2VkIGZvciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7IC8vIFdpbGwgYmUgc2V0IHRvIHRoZSBzaGFyZWQgbGF5ZXIgc3RhdGUgb2JqZWN0IGR1cmluZyBsYXllciBtYXRjaGluZ1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7IC8vIFdpbGwgcmVmZXJlbmNlIGxheWVyIG1hbmFnZXIncyBjb250ZXh0LCBjb250YWlucyBzdGF0ZSBzaGFyZWQgYnkgbGF5ZXJzXG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKzsgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSBsYXllciBpbnN0YW5jZXMgeW91IGFyZSBnZW5lcmF0aW5nXG4gICAgdGhpcy5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTk9fU1RBVEU7IC8vIEhlbHBzIHRyYWNrIGFuZCBkZWJ1ZyB0aGUgbGlmZSBjeWNsZSBvZiB0aGUgbGF5ZXJzXG4gICAgLy8gQ29tcG9zaXRlTGF5ZXIgbWVtYmVycywgbmVlZCB0byBiZSBkZWZpbmVkIGhlcmUgYmVjYXVzZSBvZiB0aGUgYE9iamVjdC5zZWFsYFxuICAgIHRoaXMucGFyZW50TGF5ZXIgPSBudWxsOyAvLyByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0ZSBsYXllciBwYXJlbnQgdGhhdCByZW5kZXJlZCB0aGlzIGxheWVyXG4gICAgdGhpcy5vbGRTdWJMYXllcnMgPSBbXTsgLy8gcmVmZXJlbmNlIHRvIHN1YmxheWVycyByZW5kZXJlZCBpbiB0aGUgcHJldmlvdXMgY3ljbGVcbiAgICAvLyBTZWFsIHRoZSBsYXllclxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXllck5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBjbGFzc05hbWUgIT09IHRoaXMucHJvcHMuaWQgPyBgPCR7Y2xhc3NOYW1lfTonJHt0aGlzLnByb3BzLmlkfSc+YCA6IGA8JHtjbGFzc05hbWV9PmA7XG4gIH1cblxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHM7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBMSUZFQ1lDTEUgTUVUSE9EUywgb3ZlcnJpZGRlbiBieSB0aGUgbGF5ZXIgc3ViY2xhc3Nlc1xuXG4gIC8vIENhbGxlZCBvbmNlIHRvIHNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgJHt0aGlzfSBoYXMgbm90IGRlZmluZWQgaW5pdGlhbGl6ZVN0YXRlYCk7XG4gIH1cblxuICAvLyBMZXQncyBsYXllciBjb250cm9sIGlmIHVwZGF0ZVN0YXRlIHNob3VsZCBiZSBjYWxsZWRcbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnByb3BzT3JEYXRhQ2hhbmdlZDtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24sIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIHVwZGF0ZWRcbiAgLy8gd2hlbiBkYXRhIGNoYW5nZXNcbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVBdHRyaWJ1dGUoJ2FsbCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBvbmNlIHdoZW4gbGF5ZXIgaXMgbm8gbG9uZ2VyIG1hdGNoZWQgYW5kIHN0YXRlIHdpbGwgYmUgZGlzY2FyZGVkXG4gIC8vIEFwcCBjYW4gZGVzdHJveSBXZWJHTCByZXNvdXJjZXMgaGVyZVxuICBmaW5hbGl6ZVN0YXRlKCkge1xuICB9XG5cbiAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuICBkcmF3KHt1bmlmb3JtcyA9IHt9fSkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbGVkIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlclxuICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvLCBtb2RlfSkge1xuICAgIGNvbnN0IHtjb2xvciwgaW5kZXh9ID0gaW5mbztcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAvLyBJZiBwcm9wcy5kYXRhIGlzIGFuIGluZGV4YWJsZSBhcnJheSwgZ2V0IHRoZSBvYmplY3RcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZGF0YSkpIHtcbiAgICAgICAgaW5mby5vYmplY3QgPSB0aGlzLnByb3BzLmRhdGFbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gLSBtb3ZlIHRvIHRoZSBKUyBwYXJ0IG9mIGEgc2hhZGVyIHBpY2tpbmcgc2hhZGVyIHBhY2thZ2VcbiAgICBpZiAobW9kZSA9PT0gJ2hvdmVyJykge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRQaWNraW5nQ29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMF0gPSBjb2xvclswXTtcbiAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzFdID0gY29sb3JbMV07XG4gICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclsyXSA9IGNvbG9yWzJdO1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7c2VsZWN0ZWRQaWNraW5nQ29sb3J9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIC8vIEVORCBMSUZFQ1lDTEUgTUVUSE9EU1xuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYXR0cmlidXRlIGludmFsaWRhdGlvbiwgY2FuIGJlIHJlZGVmaW5lXG4gIGludmFsaWRhdGVBdHRyaWJ1dGUobmFtZSA9ICdhbGwnKSB7XG4gICAgaWYgKG5hbWUgPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxscyBhdHRyaWJ1dGUgbWFuYWdlciB0byB1cGRhdGUgYW55IFdlYkdMIGF0dHJpYnV0ZXMsIGNhbiBiZSByZWRlZmluZWRcbiAgdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgZGF0YSBsZW5ndGhcbiAgICBjb25zdCBudW1JbnN0YW5jZXMgPSB0aGlzLmdldE51bUluc3RhbmNlcyhwcm9wcyk7XG5cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgcHJvcHMsXG4gICAgICBidWZmZXJzOiBwcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAvLyBEb24ndCB3b3JyeSBhYm91dCBub24tYXR0cmlidXRlIHByb3BzXG4gICAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzOiB0cnVlfSk7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGNoYW5nZWRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWMgQVBJXG5cbiAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcbiAgc2V0U3RhdGUodXBkYXRlT2JqZWN0KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB1cGRhdGVPYmplY3QpO1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIH1cbiAgfVxuXG4gIC8vIFBST0pFQ1RJT04gTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyBhIHBvaW50IHdpdGggY3VycmVudCBtYXAgc3RhdGUgKGxhdCwgbG9uLCB6b29tLCBwaXRjaCwgYmVhcmluZylcbiAgICpcbiAgICogTm90ZTogUG9zaXRpb24gY29udmVyc2lvbiBpcyBkb25lIGluIHNoYWRlciwgc28gaW4gbWFueSBjYXNlcyB0aGVyZSBpcyBubyBuZWVkXG4gICAqIGZvciB0aGlzIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gbG5nTGF0IC0gbG9uZyBhbmQgbGF0IHZhbHVlc1xuICAgKiBAcmV0dXJuIHtBcnJheXxUeXBlZEFycmF5fSAtIHgsIHkgY29vcmRpbmF0ZXNcbiAgICovXG4gIHByb2plY3QobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdChsbmdMYXQpO1xuICB9XG5cbiAgdW5wcm9qZWN0KHh5KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh4eSksICdMYXllci51bnByb2plY3QgbmVlZHMgW3gseV0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQudW5wcm9qZWN0KHh5KTtcbiAgfVxuXG4gIHByb2plY3RGbGF0KGxuZ0xhdCkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3RGbGF0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3RGbGF0KHh5KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh4eSksICdMYXllci51bnByb2plY3QgbmVlZHMgW3gseV0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQudW5wcm9qZWN0RmxhdCh4eSk7XG4gIH1cblxuICBzY3JlZW5Ub0RldmljZVBpeGVscyhzY3JlZW5QaXhlbHMpIHtcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICAgIHJldHVybiBzY3JlZW5QaXhlbHMgKiBkZXZpY2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHJldHVybiB7QXJyYXl9IC0gYSBibGFjayBjb2xvclxuICAgKi9cbiAgbnVsbFBpY2tpbmdDb2xvcigpIHtcbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtpbnR9IGkgLSBpbmRleCB0byBiZSBkZWNvZGVkXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBkZWNvZGVkIGNvbG9yXG4gICAqL1xuICBlbmNvZGVQaWNraW5nQ29sb3IoaSkge1xuICAgIHJldHVybiBbXG4gICAgICAoaSArIDEpICYgMjU1LFxuICAgICAgKChpICsgMSkgPj4gOCkgJiAyNTUsXG4gICAgICAoKChpICsgMSkgPj4gOCkgPj4gOCkgJiAyNTVcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb2xvciAtIGNvbG9yIGFycmF5IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgcGlja2luZyBjb2xvclxuICAgKi9cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgLy8gMSB3YXMgYWRkZWQgdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBjb25zdCBpbmRleCA9IGkxICsgaTIgKiAyNTYgKyBpMyAqIDY1NTM2IC0gMTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgLy8gYWRkIDEgdG8gaW5kZXggdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCBwaWNraW5nQ29sb3IgPSB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpKTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMF0gPSBwaWNraW5nQ29sb3JbMF07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAyXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICB9XG4gIH1cblxuICAvLyBEQVRBIEFDQ0VTUyBBUElcbiAgLy8gRGF0YSBjYW4gdXNlIGl0ZXJhdG9ycyBhbmQgbWF5IG5vdCBiZSByYW5kb20gYWNjZXNzXG5cbiAgLy8gVXNlIGl0ZXJhdGlvbiAodGhlIG9ubHkgcmVxdWlyZWQgY2FwYWJpbGl0eSBvbiBkYXRhKSB0byBnZXQgZmlyc3QgZWxlbWVudFxuICBnZXRGaXJzdE9iamVjdCgpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIERlZHVjZXMgbnVtZXIgb2YgaW5zdGFuY2VzLiBJbnRlbnRpb24gaXMgdG8gc3VwcG9ydDpcbiAgLy8gLSBFeHBsaWNpdCBzZXR0aW5nIG9mIG51bUluc3RhbmNlc1xuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBFUzYgY29udGFpbmVycyB0aGF0IGRlZmluZSBhIHNpemUgbWVtYmVyXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIHZpYSBhcnJheXNcbiAgZ2V0TnVtSW5zdGFuY2VzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGxheWVyIGhhcyBzZXQgaXRzIG93biB2YWx1ZVxuICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhcHAgaGFzIHByb3ZpZGVkIGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgaWYgKHByb3BzLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvcHMubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIFVzZSBjb250YWluZXIgbGlicmFyeSB0byBnZXQgYSBjb3VudCBmb3IgYW55IEVTNiBjb250YWluZXIgb3Igb2JqZWN0XG4gICAgY29uc3Qge2RhdGF9ID0gcHJvcHM7XG4gICAgcmV0dXJuIGNvdW50KGRhdGEpO1xuICB9XG5cbiAgLy8gTEFZRVIgTUFOQUdFUiBBUElcbiAgLy8gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IHRoZSBkZWNrLmdsIExheWVyTWFuYWdlciBjbGFzc1xuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gYSBuZXcgbGF5ZXIgaXMgZm91bmRcbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgaW5pdGlhbGl6ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQuZ2wsICdMYXllciBjb250ZXh0IG1pc3NpbmcgZ2wnKTtcbiAgICBhc3NlcnQoIXRoaXMuc3RhdGUsICdMYXllciBtaXNzaW5nIHN0YXRlJyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5zdGF0ZS5zdGF0cyA9IG5ldyBTdGF0cyh7aWQ6ICdkcmF3J30pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzdGF0ZSBvbmx5IG9uY2VcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXI6IG5ldyBBdHRyaWJ1dGVNYW5hZ2VyKHtpZDogdGhpcy5wcm9wcy5pZH0pLFxuICAgICAgbW9kZWw6IG51bGwsXG4gICAgICBuZWVkc1JlZHJhdzogdHJ1ZSxcbiAgICAgIGRhdGFDaGFuZ2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAvLyBUaGVpciBzaGFkZXJzIGNhbiB1c2UgaXQgdG8gcmVuZGVyIGEgcGlja2luZyBzY2VuZVxuICAgIC8vIFRPRE8gLSB0aGlzIHNsb3dzIGRvd24gbm9uIGluc3RhbmNlZCBsYXllcnNcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQWRkIGFueSBzdWJjbGFzcyBhdHRyaWJ1dGVzXG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgbW9kZWwuaWQgPSB0aGlzLnByb3BzLmlkO1xuICAgICAgbW9kZWwucHJvZ3JhbS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LXByb2dyYW1gO1xuICAgICAgbW9kZWwuZ2VvbWV0cnkuaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1nZW9tZXRyeWA7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuZ2V0QXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGV4aXN0aW5nIGxheWVyIGlzIGdldHRpbmcgbmV3IHByb3BzXG4gIHVwZGF0ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIC8vIENoZWNrIGZvciBkZXByZWNhdGVkIG1ldGhvZFxuICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgdjMgJHt0aGlzfTogXCJzaG91bGRVcGRhdGVcIiBkZXByZWNhdGVkLCByZW5hbWVkIHRvIFwic2hvdWxkVXBkYXRlU3RhdGVcImApO1xuICAgIH1cblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIGNvbnN0IHN0YXRlTmVlZHNVcGRhdGUgPSB0aGlzLnNob3VsZFVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgIGlmIChzdGF0ZU5lZWRzVXBkYXRlKSB7XG4gICAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICAgIC8vIFJ1biB0aGUgYXR0cmlidXRlIHVwZGF0ZXJzXG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModXBkYXRlUGFyYW1zLnByb3BzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvLyBDYWxsZWQgYnkgbWFuYWdlciB3aGVuIGxheWVyIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkXG4gIC8vIE5vdGU6IG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbiBhcHBsaWNhdGlvbiBzaHV0ZG93blxuICBmaW5hbGl6ZUxheWVyKCkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHRoaXMuZmluYWxpemVTdGF0ZSgpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmVtb3ZlTGF5ZXJJblNlZXIodGhpcy5pZCk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHVuaWZvcm1zXG4gIGRyYXdMYXllcih7dW5pZm9ybXMgPSB7fX0pIHtcbiAgICBjb25zdCB7Z2V0UG9seWdvbk9mZnNldH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQXBwbHkgcG9seWdvbiBvZmZzZXQgdG8gYXZvaWQgei1maWdodGluZ1xuICAgIGNvbnN0IG9mZnNldHMgPSBnZXRQb2x5Z29uT2Zmc2V0ICYmIGdldFBvbHlnb25PZmZzZXQodW5pZm9ybXMpIHx8IFswLCAwXTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIHBvbHlnb25PZmZzZXQ6IG9mZnNldHNcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgdGhpcy5kcmF3KHt1bmlmb3Jtcywgc2V0dGluZ3N9KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8ge3VuaWZvcm1zID0ge30sIC4uLm9wdHN9XG4gIHBpY2tMYXllcihvcHRzKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMuZ2V0UGlja2luZ0luZm8ob3B0cyk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICAvLyBUT0RPIC0gaXMgYXR0cmlidXRlIG1hbmFnZXIgbmVlZGVkPyAtIE1vZGVsIHNob3VsZCBiZSBlbm91Z2guXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICAvLyB0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJ5IHRoZSByZW5kZXIgbG9vcCBhcyBzb29uIGEgdGhlIGxheWVyXG4gICAgLy8gaGFzIGJlZW4gY3JlYXRlZCwgc28gZ3VhcmQgYWdhaW5zdCB1bmluaXRpYWxpemVkIHN0YXRlXG4gICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IChhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KSk7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IChtb2RlbCAmJiBtb2RlbC5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pKTtcblxuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICBkaWZmUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgYW55IHByb3BzIGhhdmUgY2hhbmdlZCAoaWdub3JlIHByb3BzIHRoYXQgd2lsbCBiZSBleGFtaW5lZCBzZXBhcmF0ZWx5KVxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZFJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFByb3BzLFxuICAgICAgaWdub3JlUHJvcHM6IHtkYXRhOiBudWxsLCB1cGRhdGVUcmlnZ2VyczogbnVsbH1cbiAgICB9KTtcblxuICAgIC8vIE5vdyBjaGVjayBpZiBhbnkgZGF0YSByZWxhdGVkIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgIGNvbnN0IGRhdGFDaGFuZ2VkUmVhc29uID0gdGhpcy5fZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpO1xuXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gQm9vbGVhbihwcm9wc0NoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IGRhdGFDaGFuZ2VkID0gQm9vbGVhbihkYXRhQ2hhbmdlZFJlYXNvbik7XG4gICAgY29uc3QgcHJvcHNPckRhdGFDaGFuZ2VkID0gcHJvcHNDaGFuZ2VkIHx8IGRhdGFDaGFuZ2VkO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IGNvbnRleHQudmlld3BvcnRDaGFuZ2VkO1xuICAgIGNvbnN0IHNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc0NoYW5nZWQgfHwgZGF0YUNoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgLy8gQ2hlY2sgdXBkYXRlIHRyaWdnZXJzIHRvIGRldGVybWluZSBpZiBhbnkgYXR0cmlidXRlcyBuZWVkIHJlZ2VuZXJhdGlvblxuICAgIC8vIE5vdGUgLSBpZiBkYXRhIGhhcyBjaGFuZ2VkLCBhbGwgYXR0cmlidXRlcyB3aWxsIG5lZWQgcmVnZW5lcmF0aW9uLCBzbyBza2lwIHRoaXMgc3RlcFxuICAgIGlmICghZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2RpZmZVcGRhdGVUcmlnZ2VycyhvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH1cblxuICAgIC8vIFRyYWNlIHdoYXQgaGFwcGVuZWRcbiAgICBpZiAoZGF0YUNoYW5nZWQpIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSwgYGRhdGFDaGFuZ2VkOiAke2RhdGFDaGFuZ2VkUmVhc29ufSBpbiAke3RoaXMuaWR9YCk7XG4gICAgfSBlbHNlIGlmIChwcm9wc0NoYW5nZWQpIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSwgYHByb3BzQ2hhbmdlZDogJHtwcm9wc0NoYW5nZWRSZWFzb259IGluICR7dGhpcy5pZH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvcHNDaGFuZ2VkLFxuICAgICAgZGF0YUNoYW5nZWQsXG4gICAgICBwcm9wc09yRGF0YUNoYW5nZWQsXG4gICAgICB2aWV3cG9ydENoYW5nZWQsXG4gICAgICBzb21ldGhpbmdDaGFuZ2VkLFxuICAgICAgcmVhc29uOiBkYXRhQ2hhbmdlZFJlYXNvbiB8fCBwcm9wc0NoYW5nZWRSZWFzb24gfHwgJ1ZpZXdwb3J0IGNoYW5nZWQnXG4gICAgfTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIFRoZSBjb21wYXJpc29uIG9mIHRoZSBkYXRhIHByb3AgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZ1xuICAvLyB0aGUgZGF0YUNvbXBhcmF0b3Igc2hvdWxkIGJlIHVzZWQgaWYgc3VwcGxpZWRcbiAgX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ29sZFByb3BzIGlzIG51bGwsIGluaXRpYWwgZGlmZic7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBvcHRpb25hbCBhcHAgZGVmaW5lZCBjb21wYXJpc29uIG9mIGRhdGFcbiAgICBjb25zdCB7ZGF0YUNvbXBhcmF0b3J9ID0gbmV3UHJvcHM7XG4gICAgaWYgKGRhdGFDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoIWRhdGFDb21wYXJhdG9yKG5ld1Byb3BzLmRhdGEsIG9sZFByb3BzLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnRGF0YSBjb21wYXJhdG9yIGRldGVjdGVkIGEgY2hhbmdlJztcbiAgICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICAgIH0gZWxzZSBpZiAobmV3UHJvcHMuZGF0YSAhPT0gb2xkUHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuICdBIG5ldyBkYXRhIGNvbnRhaW5lciB3YXMgc3VwcGxpZWQnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkLCBhbmQgaW52YWxpZGF0ZVxuICAvLyBhdHRyaWJ1dGVzIGFjY29yZGluZ2x5LlxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIC8vIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLy8gY29uc3QgdXBkYXRlVHJpZ2dlck1hcCA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0VXBkYXRlVHJpZ2dlck1hcCgpO1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIG9sZFByb3BzIGlzIG51bGwsIGluaXRpYWwgZGlmZlxuICAgIH1cblxuICAgIGxldCBjaGFuZ2UgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnMpIHtcbiAgICAgIGNvbnN0IG9sZFRyaWdnZXJzID0gb2xkUHJvcHMudXBkYXRlVHJpZ2dlcnNbcHJvcE5hbWVdIHx8IHt9O1xuICAgICAgY29uc3QgbmV3VHJpZ2dlcnMgPSBuZXdQcm9wcy51cGRhdGVUcmlnZ2Vyc1twcm9wTmFtZV0gfHwge307XG4gICAgICBjb25zdCBkaWZmUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICAgICAgb2xkUHJvcHM6IG9sZFRyaWdnZXJzLFxuICAgICAgICBuZXdQcm9wczogbmV3VHJpZ2dlcnMsXG4gICAgICAgIHRyaWdnZXJOYW1lOiBwcm9wTmFtZVxuICAgICAgfSk7XG4gICAgICBpZiAoZGlmZlJlYXNvbikge1xuICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFLFxuICAgICAgICAgICAgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhbGwgYXR0cmlidXRlczogJHtkaWZmUmVhc29ufWApO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZSgnYWxsJyk7XG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsXG4gICAgICAgICAgICBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGF0dHJpYnV0ZSAke3Byb3BOYW1lfTogJHtkaWZmUmVhc29ufWApO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIF9jaGVja1JlcXVpcmVkUHJvcChwcm9wZXJ0eU5hbWUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wc1twcm9wZXJ0eU5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSB1bmRlZmluZWQgaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uICYmICFjb25kaXRpb24odmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVtaXRzIGEgd2FybmluZyBpZiBhbiBvbGQgcHJvcCBpcyB1c2VkLCBvcHRpb25hbGx5IHN1Z2dlc3RpbmcgYSByZXBsYWNlbWVudFxuICBfY2hlY2tSZW1vdmVkUHJvcChvbGRQcm9wLCBuZXdQcm9wID0gbnVsbCkge1xuICAgIGlmICh0aGlzLnByb3BzW29sZFByb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICBsZXQgbWVzc2FnZSA9IGAke2xheWVyTmFtZX0gbm8gbG9uZ2VyIGFjY2VwdHMgcHJvcHMuJHtvbGRQcm9wfSBpbiB0aGlzIHZlcnNpb24gb2YgZGVjay5nbC5gO1xuICAgICAgaWYgKG5ld1Byb3ApIHtcbiAgICAgICAgbWVzc2FnZSArPSBgXFxuUGxlYXNlIHVzZSBwcm9wcy4ke25ld1Byb3B9IGluc3RlYWQuYDtcbiAgICAgIH1cbiAgICAgIGxvZy5vbmNlKDAsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVCYXNlVW5pZm9ybXMoKSB7XG4gICAgdGhpcy5zZXRVbmlmb3Jtcyh7XG4gICAgICAvLyBhcHBseSBnYW1tYSB0byBvcGFjaXR5IHRvIG1ha2UgaXQgdmlzdWFsbHkgXCJsaW5lYXJcIlxuICAgICAgb3BhY2l0eTogTWF0aC5wb3codGhpcy5wcm9wcy5vcGFjaXR5LCAxIC8gMi4yKSxcbiAgICAgIE9ORTogMS4wXG4gICAgfSk7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybU1hcCk7XG4gICAgfVxuICAgIC8vIFRPRE8gLSBzZXQgbmVlZHNSZWRyYXcgb24gdGhlIG1vZGVsP1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIGxvZygzLCAnbGF5ZXIuc2V0VW5pZm9ybXMnLCB1bmlmb3JtTWFwKTtcbiAgfVxufVxuXG5MYXllci5sYXllck5hbWUgPSAnTGF5ZXInO1xuTGF5ZXIucHJvcFR5cGVzID0gZGVmYXVsdFByb3BzO1xuTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19