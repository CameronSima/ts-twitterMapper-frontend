'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawLayers = drawLayers;
exports.queryLayers = queryLayers;
exports.pickLayers = pickLayers;

var _luma = require('luma.gl');

var _viewportUniforms = require('./viewport-uniforms');

var _utils = require('./utils');

var EMPTY_PIXEL = new Uint8Array(4); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */

var renderCount = 0;

function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  // render layers in normal colors
  var visibleCount = 0;
  var compositeCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.isComposite) {
      compositeCount++;
    } else if (layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });
  var totalCount = layers.length;
  var primitiveCount = totalCount - compositeCount;
  var hiddenCount = primitiveCount - visibleCount;

  var message = '#' + renderCount++ + ': Rendering ' + visibleCount + ' of ' + totalCount + ' layers ' + pass + ' (' + hiddenCount + ' hidden, ' + compositeCount + ' composite)';

  _utils.log.log(2, message);
}

// Pick all objects within the given bounding box
function queryLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      viewport = _ref2.viewport,
      mode = _ref2.mode;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  var pickInfos = getUniquesFromPickingBuffer(gl, {
    layers: layers,
    pickingFBO: pickingFBO,
    deviceRect: {
      x: deviceLeft,
      y: deviceTop,
      width: deviceRight - deviceLeft,
      height: deviceBottom - deviceTop
    }
  });

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  pickInfos.forEach(function (pickInfo) {
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
function pickLayers(gl, _ref3) {
  var layers = _ref3.layers,
      pickingFBO = _ref3.pickingFBO,
      x = _ref3.x,
      y = _ref3.y,
      radius = _ref3.radius,
      viewport = _ref3.viewport,
      mode = _ref3.mode,
      lastPickedInfo = _ref3.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var _getClosestFromPickin = getClosestFromPickingBuffer(gl, {
    layers: layers,
    pickingFBO: pickingFBO,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius
  }),
      pickedColor = _getClosestFromPickin.pickedColor,
      pickedLayer = _getClosestFromPickin.pickedLayer,
      pickedObjectIndex = _getClosestFromPickin.pickedObjectIndex;

  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();
  var unhandledPickInfos = [];

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }
  });

  infos.forEach(function (info) {
    var handled = false;
    // Per-layer event handlers (e.g. onClick, onHover) are provided by the
    // user and out of deck.gl's control. It's very much possible that
    // the user calls React lifecycle methods in these function, such as
    // ReactComponent.setState(). React lifecycle methods sometimes induce
    // a re-render and re-generation of props of deck.gl and its layers,
    // which invalidates all layers currently passed to this very function.

    // Therefore, per-layer event handlers must be invoked at the end
    // of this function. NO operation that relies on the states of current
    // layers should be called after this code.
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);break;
      case 'hover':
        handled = info.layer.props.onHover(info);break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getClosestFromPickingBuffer(gl, _ref4) {
  var layers = _ref4.layers,
      pickingFBO = _ref4.pickingFBO,
      deviceX = _ref4.deviceX,
      deviceY = _ref4.deviceY,
      deviceRadius = _ref4.deviceRadius;

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;
  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;

  var pickedColors = getPickedColors(gl, { layers: layers, pickingFBO: pickingFBO, deviceRect: { x: x, y: y, width: width, height: height } });

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var closestResultToCenter = {
    pickedColor: EMPTY_PIXEL,
    pickedLayer: null,
    pickedObjectIndex: -1
  };
  var i = 0;

  for (var row = 0; row < height; row++) {
    for (var col = 0; col < width; col++) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var dx = col + x - deviceX;
        var dy = row + y - deviceY;
        var d2 = dx * dx + dy * dy;

        if (d2 <= minSquareDistanceToCenter) {
          minSquareDistanceToCenter = d2;

          // Decode picked object index from color
          var pickedColor = pickedColors.slice(i, i + 4);
          var pickedLayer = layers[pickedLayerIndex];
          var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
          closestResultToCenter = { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
        }
      }
      i += 4;
    }
  }

  return closestResultToCenter;
}
/* eslint-enable max-depth, max-statements */

/**
 * Query within a specified rectangle
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref5) {
  var layers = _ref5.layers,
      pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  var pickedColors = getPickedColors(gl, { layers: layers, pickingFBO: pickingFBO, deviceRect: { x: x, y: y, width: width, height: height } });
  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  for (var i = 0; i < pickedColors.length; i += 4) {
    // Decode picked layer from color
    var pickedLayerIndex = pickedColors[i + 3] - 1;

    if (pickedLayerIndex >= 0) {
      var pickedColor = pickedColors.slice(i, i + 4);
      var colorKey = pickedColor.join(',');
      if (!uniqueColors.has(colorKey)) {
        var pickedLayer = layers[pickedLayerIndex];
        uniqueColors.set(colorKey, {
          pickedColor: pickedColor,
          pickedLayer: pickedLayer,
          pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
        });
      }
    }
  }

  return Array.from(uniqueColors.values());
}

// Returns an Uint8ClampedArray of picked pixels
function getPickedColors(gl, _ref6) {
  var layers = _ref6.layers,
      pickingFBO = _ref6.pickingFBO,
      _ref6$deviceRect = _ref6.deviceRect,
      x = _ref6$deviceRect.x,
      y = _ref6$deviceRect.y,
      width = _ref6$deviceRect.width,
      height = _ref6$deviceRect.height;

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  // Note that the callback here is called synchronously.
  return (0, _luma.withParameters)(gl, {
    framebuffer: pickingFBO,
    scissorTest: true,
    scissor: [x, y, width, height],
    blend: true,
    blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
    blendEquation: gl.FUNC_ADD
    // TODO - Set clear color
  }, function () {

    // Clear the frame buffer
    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);

    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    var settings = {
      blend: true,
      blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
      blendEquation: gl.FUNC_ADD
    };

    (0, _luma.withParameters)(gl, settings, function () {
      // Render all pickable layers in picking colors
      layers.forEach(function (layer, layerIndex) {
        if (!layer.isComposite && layer.props.visible && layer.props.pickable) {

          // Encode layerIndex with alpha
          (0, _luma.setParameters)(gl, { blendColor: [0, 0, 0, (layerIndex + 1) / 255] });
          layer.drawLayer({
            uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
          });
        }
      });
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColors = new Uint8Array(width * height * 4);
    gl.readPixels(x, y, width, height, _luma.GL.RGBA, _luma.GL.UNSIGNED_BYTE, pickedColors);

    return pickedColors;
  });
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref7) {
  var layer = _ref7.layer,
      info = _ref7.info,
      mode = _ref7.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJkcmF3TGF5ZXJzIiwicXVlcnlMYXllcnMiLCJwaWNrTGF5ZXJzIiwiRU1QVFlfUElYRUwiLCJVaW50OEFycmF5IiwicmVuZGVyQ291bnQiLCJsYXllcnMiLCJwYXNzIiwidmlzaWJsZUNvdW50IiwiY29tcG9zaXRlQ291bnQiLCJmb3JFYWNoIiwibGF5ZXIiLCJsYXllckluZGV4IiwiaXNDb21wb3NpdGUiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJ1bmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImNvbnRleHQiLCJ2aWV3cG9ydCIsInRvdGFsQ291bnQiLCJsZW5ndGgiLCJwcmltaXRpdmVDb3VudCIsImhpZGRlbkNvdW50IiwibWVzc2FnZSIsImxvZyIsImdsIiwicGlja2luZ0ZCTyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJtb2RlIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VMZWZ0IiwiTWF0aCIsInJvdW5kIiwiZGV2aWNlQm90dG9tIiwiY2FudmFzIiwiZGV2aWNlUmlnaHQiLCJkZXZpY2VUb3AiLCJwaWNrSW5mb3MiLCJnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIiLCJkZXZpY2VSZWN0IiwidW5pcXVlSW5mb3MiLCJNYXAiLCJpbmZvIiwiY3JlYXRlSW5mbyIsInBpY2tJbmZvIiwiZGV2aWNlUGl4ZWwiLCJjb2xvciIsInBpY2tlZENvbG9yIiwiaW5kZXgiLCJwaWNrZWRPYmplY3RJbmRleCIsInBpY2tlZCIsImdldExheWVyUGlja2luZ0luZm8iLCJwaWNrZWRMYXllciIsImhhcyIsIm9iamVjdCIsInNldCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInJhZGl1cyIsImxhc3RQaWNrZWRJbmZvIiwiZGV2aWNlWCIsImRldmljZVkiLCJkZXZpY2VSYWRpdXMiLCJnZXRDbG9zZXN0RnJvbVBpY2tpbmdCdWZmZXIiLCJhZmZlY3RlZExheWVycyIsImxhc3RQaWNrZWRPYmplY3RJbmRleCIsImxhc3RQaWNrZWRMYXllcklkIiwibGF5ZXJJZCIsInBpY2tlZExheWVySWQiLCJpZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJ1bnNoaWZ0IiwiYmFzZUluZm8iLCJpbmZvcyIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImhhbmRsZWQiLCJvbkNsaWNrIiwib25Ib3ZlciIsIkVycm9yIiwicHVzaCIsIm1heCIsIm1pbiIsInBpY2tlZENvbG9ycyIsImdldFBpY2tlZENvbG9ycyIsIm1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIiLCJjbG9zZXN0UmVzdWx0VG9DZW50ZXIiLCJpIiwicm93IiwiY29sIiwicGlja2VkTGF5ZXJJbmRleCIsImR4IiwiZHkiLCJkMiIsInNsaWNlIiwiZGVjb2RlUGlja2luZ0NvbG9yIiwidW5pcXVlQ29sb3JzIiwiY29sb3JLZXkiLCJqb2luIiwiZnJhbWVidWZmZXIiLCJzY2lzc29yVGVzdCIsInNjaXNzb3IiLCJibGVuZCIsImJsZW5kRnVuYyIsIk9ORSIsIlpFUk8iLCJDT05TVEFOVF9BTFBIQSIsImJsZW5kRXF1YXRpb24iLCJGVU5DX0FERCIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJzZXR0aW5ncyIsInBpY2thYmxlIiwiYmxlbmRDb2xvciIsInJlYWRQaXhlbHMiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInBpeGVsIiwibG5nTGF0IiwidW5wcm9qZWN0Iiwic291cmNlTGF5ZXIiLCJwaWNrTGF5ZXIiLCJwYXJlbnRMYXllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUE0QmdCQSxVLEdBQUFBLFU7UUFnQ0FDLFcsR0FBQUEsVztRQW9EQUMsVSxHQUFBQSxVOztBQTNGaEI7O0FBQ0E7O0FBQ0E7O0FBRUEsSUFBTUMsY0FBYyxJQUFJQyxVQUFKLENBQWUsQ0FBZixD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LE1BQU0sQ0FBTixDQU5FO0FBT0xBLGdCQVBLO0FBUUxDLFlBQVEzRyxTQUFTNEcsU0FBVCxDQUFtQkYsS0FBbkI7QUFSSCxHQUFQO0FBVUQ7O0FBRUQ7QUFDQSxTQUFTcEUsbUJBQVQsUUFBa0Q7QUFBQSxNQUFwQmxELEtBQW9CLFNBQXBCQSxLQUFvQjtBQUFBLE1BQWJ5QyxJQUFhLFNBQWJBLElBQWE7QUFBQSxNQUFQaEIsSUFBTyxTQUFQQSxJQUFPOztBQUNoRCxTQUFPekIsU0FBU3lDLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTWdGLGNBQWNoRixLQUFLekMsS0FBTCxJQUFjQSxLQUFsQztBQUNBeUMsU0FBS3pDLEtBQUwsR0FBYUEsS0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBeUMsV0FBT3pDLE1BQU0wSCxTQUFOLENBQWdCLEVBQUNqRixVQUFELEVBQU9oQixVQUFQLEVBQWFnRyx3QkFBYixFQUFoQixDQUFQO0FBQ0F6SCxZQUFRQSxNQUFNMkgsV0FBZDtBQUNEO0FBQ0QsU0FBT2xGLElBQVA7QUFDRCIsImZpbGUiOiJkcmF3LWFuZC1waWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7R0wsIHdpdGhQYXJhbWV0ZXJzLCBzZXRQYXJhbWV0ZXJzfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7Z2V0VW5pZm9ybXNGcm9tVmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnQtdW5pZm9ybXMnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBFTVBUWV9QSVhFTCA9IG5ldyBVaW50OEFycmF5KDQpO1xubGV0IHJlbmRlckNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoe2xheWVycywgcGFzc30pIHtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxldCB2aXNpYmxlQ291bnQgPSAwO1xuICBsZXQgY29tcG9zaXRlQ291bnQgPSAwO1xuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgaWYgKGxheWVyLmlzQ29tcG9zaXRlKSB7XG4gICAgICBjb21wb3NpdGVDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSkge1xuICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwfSxcbiAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB2aXNpYmxlQ291bnQrKztcbiAgICB9XG4gIH0pO1xuICBjb25zdCB0b3RhbENvdW50ID0gbGF5ZXJzLmxlbmd0aDtcbiAgY29uc3QgcHJpbWl0aXZlQ291bnQgPSB0b3RhbENvdW50IC0gY29tcG9zaXRlQ291bnQ7XG4gIGNvbnN0IGhpZGRlbkNvdW50ID0gcHJpbWl0aXZlQ291bnQgLSB2aXNpYmxlQ291bnQ7XG5cbiAgY29uc3QgbWVzc2FnZSA9IGBcXFxuIyR7cmVuZGVyQ291bnQrK306IFJlbmRlcmluZyAke3Zpc2libGVDb3VudH0gb2YgJHt0b3RhbENvdW50fSBsYXllcnMgJHtwYXNzfSBcXFxuKCR7aGlkZGVuQ291bnR9IGhpZGRlbiwgJHtjb21wb3NpdGVDb3VudH0gY29tcG9zaXRlKWA7XG5cbiAgbG9nLmxvZygyLCBtZXNzYWdlKTtcbn1cblxuLy8gUGljayBhbGwgb2JqZWN0cyB3aXRoaW4gdGhlIGdpdmVuIGJvdW5kaW5nIGJveFxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5TGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgeCxcbiAgeSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgdmlld3BvcnQsXG4gIG1vZGVcbn0pIHtcblxuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgZGV2aWNlTGVmdCA9IE1hdGgucm91bmQoeCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VCb3R0b20gPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVJpZ2h0ID0gTWF0aC5yb3VuZCgoeCArIHdpZHRoKSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VUb3AgPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5oZWlnaHQgLSAoeSArIGhlaWdodCkgKiBwaXhlbFJhdGlvKTtcblxuICBjb25zdCBwaWNrSW5mb3MgPSBnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgICBsYXllcnMsXG4gICAgcGlja2luZ0ZCTyxcbiAgICBkZXZpY2VSZWN0OiB7XG4gICAgICB4OiBkZXZpY2VMZWZ0LFxuICAgICAgeTogZGV2aWNlVG9wLFxuICAgICAgd2lkdGg6IGRldmljZVJpZ2h0IC0gZGV2aWNlTGVmdCxcbiAgICAgIGhlaWdodDogZGV2aWNlQm90dG9tIC0gZGV2aWNlVG9wXG4gICAgfVxuICB9KTtcblxuICAvLyBPbmx5IHJldHVybiB1bmlxdWUgaW5mb3MsIGlkZW50aWZpZWQgYnkgaW5mby5vYmplY3RcbiAgY29uc3QgdW5pcXVlSW5mb3MgPSBuZXcgTWFwKCk7XG5cbiAgcGlja0luZm9zLmZvckVhY2gocGlja0luZm8gPT4ge1xuICAgIGxldCBpbmZvID0gY3JlYXRlSW5mbyhbcGlja0luZm8ueCAvIHBpeGVsUmF0aW8sIHBpY2tJbmZvLnkgLyBwaXhlbFJhdGlvXSwgdmlld3BvcnQpO1xuICAgIGluZm8uZGV2aWNlUGl4ZWwgPSBbcGlja0luZm8ueCwgcGlja0luZm8ueV07XG4gICAgaW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBpbmZvLmNvbG9yID0gcGlja0luZm8ucGlja2VkQ29sb3I7XG4gICAgaW5mby5pbmRleCA9IHBpY2tJbmZvLnBpY2tlZE9iamVjdEluZGV4O1xuICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcblxuICAgIGluZm8gPSBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllcjogcGlja0luZm8ucGlja2VkTGF5ZXIsIGluZm8sIG1vZGV9KTtcbiAgICBpZiAoIXVuaXF1ZUluZm9zLmhhcyhpbmZvLm9iamVjdCkpIHtcbiAgICAgIHVuaXF1ZUluZm9zLnNldChpbmZvLm9iamVjdCwgaW5mbyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVJbmZvcy52YWx1ZXMoKSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbi8vIFBpY2sgdGhlIGNsb3Nlc3Qgb2JqZWN0IGF0IHRoZSBnaXZlbiAoeCx5KSBjb29yZGluYXRlXG5leHBvcnQgZnVuY3Rpb24gcGlja0xheWVycyhnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIHgsXG4gIHksXG4gIHJhZGl1cyxcbiAgdmlld3BvcnQsXG4gIG1vZGUsXG4gIGxhc3RQaWNrZWRJbmZvXG59KSB7XG5cbiAgLy8gQ29udmVydCBmcm9tIGNhbnZhcyB0b3AtbGVmdCB0byBXZWJHTCBib3R0b20tbGVmdCBjb29yZGluYXRlc1xuICAvLyBBbmQgY29tcGVuc2F0ZSBmb3IgcGl4ZWxSYXRpb1xuICBjb25zdCBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGRldmljZVggPSBNYXRoLnJvdW5kKHggKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlWSA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlUmFkaXVzID0gTWF0aC5yb3VuZChyYWRpdXMgKiBwaXhlbFJhdGlvKTtcblxuICBjb25zdCB7XG4gICAgcGlja2VkQ29sb3IsXG4gICAgcGlja2VkTGF5ZXIsXG4gICAgcGlja2VkT2JqZWN0SW5kZXhcbiAgfSA9IGdldENsb3Nlc3RGcm9tUGlja2luZ0J1ZmZlcihnbCwge1xuICAgIGxheWVycyxcbiAgICBwaWNraW5nRkJPLFxuICAgIGRldmljZVgsXG4gICAgZGV2aWNlWSxcbiAgICBkZXZpY2VSYWRpdXNcbiAgfSk7XG4gIGNvbnN0IGFmZmVjdGVkTGF5ZXJzID0gcGlja2VkTGF5ZXIgPyBbcGlja2VkTGF5ZXJdIDogW107XG5cbiAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgY29uc3QgbGFzdFBpY2tlZE9iamVjdEluZGV4ID0gbGFzdFBpY2tlZEluZm8uaW5kZXg7XG4gICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuICAgIGNvbnN0IHBpY2tlZExheWVySWQgPSBwaWNrZWRMYXllciAmJiBwaWNrZWRMYXllci5wcm9wcy5pZDtcblxuICAgIC8vIHByb2NlZWQgb25seSBpZiBwaWNrZWQgb2JqZWN0IGNoYW5nZWRcbiAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQgfHwgcGlja2VkT2JqZWN0SW5kZXggIT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzdG9yZSBhIHJlZiB0byBsYXN0UGlja2VkTGF5ZXIgaW4gdGhlIGNvbnRleHQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChsYXllciA9PiBsYXllci5wcm9wcy5pZCA9PT0gbGFzdFBpY2tlZExheWVySWQpO1xuICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgLy8gTGV0IGxlYXZlIGV2ZW50IGZpcmUgYmVmb3JlIGVudGVyIGV2ZW50XG4gICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgbGFzdFBpY2tlZEluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBiYXNlSW5mbyA9IGNyZWF0ZUluZm8oW3gsIHldLCB2aWV3cG9ydCk7XG4gIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICBiYXNlSW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAvLyBVc2UgYSBNYXAgdG8gc3RvcmUgYWxsIHBpY2tpbmcgaW5mb3MuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZvckVhY2ggbG9vcHMgYXJlIHRoZSByZXN1bHQgb2ZcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9pc3N1ZXMvNDQzXG4gIC8vIFBsZWFzZSBiZSB2ZXJ5IGNhcmVmdWwgd2hlbiBjaGFuZ2luZyB0aGlzIHBhdHRlcm5cbiAgY29uc3QgaW5mb3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIGFmZmVjdGVkTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgIGxldCBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUluZm8pO1xuXG4gICAgaWYgKGxheWVyID09PSBwaWNrZWRMYXllcikge1xuICAgICAgaW5mby5jb2xvciA9IHBpY2tlZENvbG9yO1xuICAgICAgaW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgICAgaW5mby5waWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGluZm8gPSBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllciwgaW5mbywgbW9kZX0pO1xuXG4gICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBjb3B5IG9mIGluZm8gZm9yXG4gICAgLy8gb25lIGNvbXBvc2l0ZSBsYXllclxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvcy5zZXQoaW5mby5sYXllci5pZCwgaW5mbyk7XG4gICAgfVxuICB9KTtcblxuICBpbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgLy8gUGVyLWxheWVyIGV2ZW50IGhhbmRsZXJzIChlLmcuIG9uQ2xpY2ssIG9uSG92ZXIpIGFyZSBwcm92aWRlZCBieSB0aGVcbiAgICAvLyB1c2VyIGFuZCBvdXQgb2YgZGVjay5nbCdzIGNvbnRyb2wuIEl0J3MgdmVyeSBtdWNoIHBvc3NpYmxlIHRoYXRcbiAgICAvLyB0aGUgdXNlciBjYWxscyBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBpbiB0aGVzZSBmdW5jdGlvbiwgc3VjaCBhc1xuICAgIC8vIFJlYWN0Q29tcG9uZW50LnNldFN0YXRlKCkuIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIHNvbWV0aW1lcyBpbmR1Y2VcbiAgICAvLyBhIHJlLXJlbmRlciBhbmQgcmUtZ2VuZXJhdGlvbiBvZiBwcm9wcyBvZiBkZWNrLmdsIGFuZCBpdHMgbGF5ZXJzLFxuICAgIC8vIHdoaWNoIGludmFsaWRhdGVzIGFsbCBsYXllcnMgY3VycmVudGx5IHBhc3NlZCB0byB0aGlzIHZlcnkgZnVuY3Rpb24uXG5cbiAgICAvLyBUaGVyZWZvcmUsIHBlci1sYXllciBldmVudCBoYW5kbGVycyBtdXN0IGJlIGludm9rZWQgYXQgdGhlIGVuZFxuICAgIC8vIG9mIHRoaXMgZnVuY3Rpb24uIE5PIG9wZXJhdGlvbiB0aGF0IHJlbGllcyBvbiB0aGUgc3RhdGVzIG9mIGN1cnJlbnRcbiAgICAvLyBsYXllcnMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzIGNvZGUuXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnY2xpY2snOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkNsaWNrKGluZm8pOyBicmVhaztcbiAgICBjYXNlICdob3Zlcic6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uSG92ZXIoaW5mbyk7IGJyZWFrO1xuICAgIGNhc2UgJ3F1ZXJ5JzogYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgIH1cblxuICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdW5oYW5kbGVkUGlja0luZm9zO1xufVxuXG4vKipcbiAqIFBpY2sgYXQgYSBzcGVjaWZpZWQgcGl4ZWwgd2l0aCBhIHRvbGVyYW5jZSByYWRpdXNcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3Qgb2JqZWN0IHRvIHRoZSBwaXhlbCBpbiBzaGFwZSBge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9YFxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0RnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICBkZXZpY2VYLFxuICBkZXZpY2VZLFxuICBkZXZpY2VSYWRpdXNcbn0pIHtcbiAgLy8gQ3JlYXRlIGEgYm94IG9mIHNpemUgYHJhZGl1cyAqIDIgKyAxYCBjZW50ZXJlZCBhdCBbZGV2aWNlWCwgZGV2aWNlWV1cbiAgY29uc3QgeCA9IE1hdGgubWF4KDAsIGRldmljZVggLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB5ID0gTWF0aC5tYXgoMCwgZGV2aWNlWSAtIGRldmljZVJhZGl1cyk7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5taW4ocGlja2luZ0ZCTy53aWR0aCwgZGV2aWNlWCArIGRldmljZVJhZGl1cykgLSB4ICsgMTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4ocGlja2luZ0ZCTy5oZWlnaHQsIGRldmljZVkgKyBkZXZpY2VSYWRpdXMpIC0geSArIDE7XG5cbiAgY29uc3QgcGlja2VkQ29sb3JzID0gZ2V0UGlja2VkQ29sb3JzKGdsLCB7bGF5ZXJzLCBwaWNraW5nRkJPLCBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH19KTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgcGl4ZWxzIGluIHBpY2tpbmcgcmVzdWx0cyBhbmQgZmluZCB0aGUgb25lIGNsb3Nlc3QgdG8gdGhlIHN1cHBsaWVkXG4gIC8vIFtkZXZpY2VYLCBkZXZpY2VZXVxuICBsZXQgbWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlciA9IGRldmljZVJhZGl1cyAqIGRldmljZVJhZGl1cztcbiAgbGV0IGNsb3Nlc3RSZXN1bHRUb0NlbnRlciA9IHtcbiAgICBwaWNrZWRDb2xvcjogRU1QVFlfUElYRUwsXG4gICAgcGlja2VkTGF5ZXI6IG51bGwsXG4gICAgcGlja2VkT2JqZWN0SW5kZXg6IC0xXG4gIH07XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBoZWlnaHQ7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgd2lkdGg7IGNvbCsrKSB7XG4gICAgICAvLyBEZWNvZGUgcGlja2VkIGxheWVyIGZyb20gY29sb3JcbiAgICAgIGNvbnN0IHBpY2tlZExheWVySW5kZXggPSBwaWNrZWRDb2xvcnNbaSArIDNdIC0gMTtcblxuICAgICAgaWYgKHBpY2tlZExheWVySW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBkeCA9IGNvbCArIHggLSBkZXZpY2VYO1xuICAgICAgICBjb25zdCBkeSA9IHJvdyArIHkgLSBkZXZpY2VZO1xuICAgICAgICBjb25zdCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuXG4gICAgICAgIGlmIChkMiA8PSBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyKSB7XG4gICAgICAgICAgbWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlciA9IGQyO1xuXG4gICAgICAgICAgLy8gRGVjb2RlIHBpY2tlZCBvYmplY3QgaW5kZXggZnJvbSBjb2xvclxuICAgICAgICAgIGNvbnN0IHBpY2tlZENvbG9yID0gcGlja2VkQ29sb3JzLnNsaWNlKGksIGkgKyA0KTtcbiAgICAgICAgICBjb25zdCBwaWNrZWRMYXllciA9IGxheWVyc1twaWNrZWRMYXllckluZGV4XTtcbiAgICAgICAgICBjb25zdCBwaWNrZWRPYmplY3RJbmRleCA9IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcik7XG4gICAgICAgICAgY2xvc2VzdFJlc3VsdFRvQ2VudGVyID0ge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpICs9IDQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RSZXN1bHRUb0NlbnRlcjtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIFF1ZXJ5IHdpdGhpbiBhIHNwZWNpZmllZCByZWN0YW5nbGVcbiAqIFJldHVybnMgYXJyYXkgb2YgdW5pcXVlIG9iamVjdHMgaW4gc2hhcGUgYHt4LCB5LCBwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fWBcbiAqL1xuZnVuY3Rpb24gZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgZGV2aWNlUmVjdDoge3gsIHksIHdpZHRoLCBoZWlnaHR9XG59KSB7XG4gIGNvbnN0IHBpY2tlZENvbG9ycyA9IGdldFBpY2tlZENvbG9ycyhnbCwge2xheWVycywgcGlja2luZ0ZCTywgZGV2aWNlUmVjdDoge3gsIHksIHdpZHRoLCBoZWlnaHR9fSk7XG4gIGNvbnN0IHVuaXF1ZUNvbG9ycyA9IG5ldyBNYXAoKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgcGl4ZWxzIGluIHBpY2tpbmcgcmVzdWx0cyBhbmQgZ2V0IHVuaXF1ZSBjb2xvcnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWNrZWRDb2xvcnMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAvLyBEZWNvZGUgcGlja2VkIGxheWVyIGZyb20gY29sb3JcbiAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2kgKyAzXSAtIDE7XG5cbiAgICBpZiAocGlja2VkTGF5ZXJJbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBwaWNrZWRDb2xvciA9IHBpY2tlZENvbG9ycy5zbGljZShpLCBpICsgNCk7XG4gICAgICBjb25zdCBjb2xvcktleSA9IHBpY2tlZENvbG9yLmpvaW4oJywnKTtcbiAgICAgIGlmICghdW5pcXVlQ29sb3JzLmhhcyhjb2xvcktleSkpIHtcbiAgICAgICAgY29uc3QgcGlja2VkTGF5ZXIgPSBsYXllcnNbcGlja2VkTGF5ZXJJbmRleF07XG4gICAgICAgIHVuaXF1ZUNvbG9ycy5zZXQoY29sb3JLZXksIHtcbiAgICAgICAgICBwaWNrZWRDb2xvcixcbiAgICAgICAgICBwaWNrZWRMYXllcixcbiAgICAgICAgICBwaWNrZWRPYmplY3RJbmRleDogcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVDb2xvcnMudmFsdWVzKCkpO1xufVxuXG4vLyBSZXR1cm5zIGFuIFVpbnQ4Q2xhbXBlZEFycmF5IG9mIHBpY2tlZCBwaXhlbHNcbmZ1bmN0aW9uIGdldFBpY2tlZENvbG9ycyhnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxufSkge1xuICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgc2Npc3NvciB0ZXN0IGFuZCBmYm8gYmluZGluZ3MgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb25lIHBpeGVsLCBubyBuZWVkIHRvIHJlbmRlciBhbnl0aGluZyBlbHNlXG4gIC8vIE5vdGUgdGhhdCB0aGUgY2FsbGJhY2sgaGVyZSBpcyBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgcmV0dXJuIHdpdGhQYXJhbWV0ZXJzKGdsLCB7XG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHRydWUsXG4gICAgc2Npc3NvcjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLFxuICAgIGJsZW5kOiB0cnVlLFxuICAgIGJsZW5kRnVuYzogW2dsLk9ORSwgZ2wuWkVSTywgZ2wuQ09OU1RBTlRfQUxQSEEsIGdsLlpFUk9dLFxuICAgIGJsZW5kRXF1YXRpb246IGdsLkZVTkNfQUREXG4gICAgLy8gVE9ETyAtIFNldCBjbGVhciBjb2xvclxuICB9LCAoKSA9PiB7XG5cbiAgICAvLyBDbGVhciB0aGUgZnJhbWUgYnVmZmVyXG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG4gICAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICBibGVuZDogdHJ1ZSxcbiAgICAgIGJsZW5kRnVuYzogW2dsLk9ORSwgZ2wuWkVSTywgZ2wuQ09OU1RBTlRfQUxQSEEsIGdsLlpFUk9dLFxuICAgICAgYmxlbmRFcXVhdGlvbjogZ2wuRlVOQ19BRERcbiAgICB9O1xuXG4gICAgd2l0aFBhcmFtZXRlcnMoZ2wsIHNldHRpbmdzLCAoKSA9PiB7XG4gICAgICAvLyBSZW5kZXIgYWxsIHBpY2thYmxlIGxheWVycyBpbiBwaWNraW5nIGNvbG9yc1xuICAgICAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgICAgIGlmICghbGF5ZXIuaXNDb21wb3NpdGUgJiYgbGF5ZXIucHJvcHMudmlzaWJsZSAmJiBsYXllci5wcm9wcy5waWNrYWJsZSkge1xuXG4gICAgICAgICAgLy8gRW5jb2RlIGxheWVySW5kZXggd2l0aCBhbHBoYVxuICAgICAgICAgIHNldFBhcmFtZXRlcnMoZ2wsIHtibGVuZENvbG9yOiBbMCwgMCwgMCwgKGxheWVySW5kZXggKyAxKSAvIDI1NV19KTtcbiAgICAgICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHtyZW5kZXJQaWNraW5nQnVmZmVyOiAxLCBwaWNraW5nRW5hYmxlZDogMX0sXG4gICAgICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICAgICAge2xheWVySW5kZXh9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVhZCBjb2xvciBpbiB0aGUgY2VudHJhbCBwaXhlbCwgdG8gYmUgbWFwcGVkIHdpdGggcGlja2luZyBjb2xvcnNcbiAgICBjb25zdCBwaWNrZWRDb2xvcnMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgcGlja2VkQ29sb3JzKTtcblxuICAgIHJldHVybiBwaWNrZWRDb2xvcnM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogRU1QVFlfUElYRUwsXG4gICAgbGF5ZXI6IG51bGwsXG4gICAgaW5kZXg6IC0xLFxuICAgIHBpY2tlZDogZmFsc2UsXG4gICAgeDogcGl4ZWxbMF0sXG4gICAgeTogcGl4ZWxbMV0sXG4gICAgcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG5cbi8vIFdhbGsgdXAgdGhlIGxheWVyIGNvbXBvc2l0ZSBjaGFpbiB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbmZ1bmN0aW9uIGdldExheWVyUGlja2luZ0luZm8oe2xheWVyLCBpbmZvLCBtb2RlfSkge1xuICB3aGlsZSAobGF5ZXIgJiYgaW5mbykge1xuICAgIC8vIEZvciBhIGNvbXBvc2l0ZSBsYXllciwgc291cmNlTGF5ZXIgd2lsbCBwb2ludCB0byB0aGUgc3VibGF5ZXJcbiAgICAvLyB3aGVyZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tLlxuICAgIC8vIEl0IHByb3ZpZGVzIGFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0ZSBsYXllcidzXG4gICAgLy8gZ2V0UGlja2luZ0luZm8oKSBtZXRob2QgdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0XG4gICAgY29uc3Qgc291cmNlTGF5ZXIgPSBpbmZvLmxheWVyIHx8IGxheWVyO1xuICAgIGluZm8ubGF5ZXIgPSBsYXllcjtcbiAgICAvLyBsYXllci5waWNrTGF5ZXIoKSBmdW5jdGlvbiByZXF1aXJlcyBhIG5vbi1udWxsIGBgYGxheWVyLnN0YXRlYGBgXG4gICAgLy8gb2JqZWN0IHRvIGZ1bnRpb24gcHJvcGVybHkuIFNvIHRoZSBsYXllciByZWZlcmVjZWQgaGVyZVxuICAgIC8vIG11c3QgYmUgdGhlIFwiY3VycmVudFwiIGxheWVyLCBub3QgYW4gXCJvdXQtZGF0ZWRcIiAvIFwiaW52YWxpZGF0ZWRcIiBsYXllclxuICAgIGluZm8gPSBsYXllci5waWNrTGF5ZXIoe2luZm8sIG1vZGUsIHNvdXJjZUxheWVyfSk7XG4gICAgbGF5ZXIgPSBsYXllci5wYXJlbnRMYXllcjtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cbiJdfQ==