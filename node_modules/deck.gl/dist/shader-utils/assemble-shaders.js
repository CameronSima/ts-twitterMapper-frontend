'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkRendererVendor = checkRendererVendor;
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.assembleShaders = assembleShaders;

var _luma = require('luma.gl');

var _shaderChunks = require('./shader-chunks');

var SHADER_CHUNKS = _interopRequireWildcard(_shaderChunks);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function checkRendererVendor(debugInfo, gpuVendor) {
  var vendor = debugInfo.vendor,
      renderer = debugInfo.renderer;

  var result = void 0;
  switch (gpuVendor) {
    case 'nvidia':
      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);
      break;
    case 'intel':
      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);
      break;
    case 'amd':
      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);
      break;
    default:
      result = false;
  }
  return result;
}
// Load shader chunks
// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';
function getPlatformShaderDefines(gl) {
  /* eslint-disable */
  var platformDefines = '';
  var debugInfo = (0, _luma.glGetDebugInfo)(gl);

  if (checkRendererVendor(debugInfo, 'nvidia')) {
    platformDefines += '#define NVIDIA_GPU\n#define NVIDIA_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'intel')) {
    platformDefines += '#define INTEL_GPU\n#define INTEL_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n #define INTEL_TAN_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'amd')) {
    platformDefines += '#define AMD_GPU\n';
  } else {
    platformDefines += '#define DEFAULT_GPU\n';
  }

  return platformDefines;
}

function assembleShader(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts = opts,
      vs = _opts.vs,
      _opts$project = _opts.project,
      project = _opts$project === undefined ? true : _opts$project,
      _opts$project2 = _opts.project64,
      project64 = _opts$project2 === undefined ? false : _opts$project2;
  var _opts2 = opts,
      _opts2$fp = _opts2.fp64,
      fp64 = _opts2$fp === undefined ? false : _opts2$fp;

  if (project64 === true) {
    fp64 = true;
  }
  var source = getPlatformShaderDefines(gl) + '\n';
  opts = Object.assign({}, opts, { project: project, project64: project64, fp64: fp64 });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(SHADER_CHUNKS)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var chunkName = _step.value;

      if (opts[chunkName]) {
        source += SHADER_CHUNKS[chunkName].source + '\n';
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (opts.modules || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _chunkName = _step2.value;

      if (SHADER_CHUNKS[_chunkName]) {
        source += SHADER_CHUNKS[_chunkName].source + '\n';
      } else {
        throw new Error('Shader module ' + _chunkName + ' not found');
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  source += vs;
  return source;
}

function assembleShaders(gl, opts) {
  var vsSource = assembleShader(gl, opts);
  var fsSource = opts.fs;

  // If shaderCache presents, output compiled shaders from luma.gl/shadeCache
  if (opts.shaderCache) {
    return {
      gl: gl,
      vs: opts.shaderCache.getVertexShader(gl, vsSource),
      fs: opts.shaderCache.getFragmentShader(gl, fsSource)
    };
  };
  // Otherwise just output shader source
  return {
    gl: gl,
    vs: vsSource,
    fs: fsSource
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXItdXRpbHMvYXNzZW1ibGUtc2hhZGVycy5qcyJdLCJuYW1lcyI6WyJjaGVja1JlbmRlcmVyVmVuZG9yIiwiZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzIiwiYXNzZW1ibGVTaGFkZXJzIiwiU0hBREVSX0NIVU5LUyIsImRlYnVnSW5mbyIsImdwdVZlbmRvciIsInZlbmRvciIsInJlbmRlcmVyIiwicmVzdWx0IiwibWF0Y2giLCJnbCIsInBsYXRmb3JtRGVmaW5lcyIsImFzc2VtYmxlU2hhZGVyIiwib3B0cyIsInZzIiwicHJvamVjdCIsInByb2plY3Q2NCIsImZwNjQiLCJzb3VyY2UiLCJPYmplY3QiLCJhc3NpZ24iLCJrZXlzIiwiY2h1bmtOYW1lIiwibW9kdWxlcyIsIkVycm9yIiwidnNTb3VyY2UiLCJmc1NvdXJjZSIsImZzIiwic2hhZGVyQ2FjaGUiLCJnZXRWZXJ0ZXhTaGFkZXIiLCJnZXRGcmFnbWVudFNoYWRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUF5QmdCQSxtQixHQUFBQSxtQjtRQXFCQUMsd0IsR0FBQUEsd0I7UUF1REFDLGUsR0FBQUEsZTs7QUFqRmhCOztBQUdBOztJQUFZQyxhOzs7O0FBdkJaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9PLFNBQVNILG1CQUFULENBQTZCSSxTQUE3QixFQUF3Q0MsU0FBeEMsRUFBbUQ7QUFBQSxNQUNqREMsTUFEaUQsR0FDN0JGLFNBRDZCLENBQ2pERSxNQURpRDtBQUFBLE1BQ3pDQyxRQUR5QyxHQUM3QkgsU0FENkIsQ0FDekNHLFFBRHlDOztBQUV4RCxNQUFJQyxlQUFKO0FBQ0EsVUFBUUgsU0FBUjtBQUNBLFNBQUssUUFBTDtBQUNFRyxlQUFTRixPQUFPRyxLQUFQLENBQWEsU0FBYixLQUEyQkYsU0FBU0UsS0FBVCxDQUFlLFNBQWYsQ0FBcEM7QUFD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LEtBQUtjLEVBQXRCOztBQUVBO0FBQ0EsTUFBSWQsS0FBS2UsV0FBVCxFQUFzQjtBQUNwQixXQUFPO0FBQ0xsQixZQURLO0FBRUxJLFVBQUlELEtBQUtlLFdBQUwsQ0FBaUJDLGVBQWpCLENBQWlDbkIsRUFBakMsRUFBcUNlLFFBQXJDLENBRkM7QUFHTEUsVUFBSWQsS0FBS2UsV0FBTCxDQUFpQkUsaUJBQWpCLENBQW1DcEIsRUFBbkMsRUFBdUNnQixRQUF2QztBQUhDLEtBQVA7QUFLRDtBQUNEO0FBQ0EsU0FBTztBQUNMaEIsVUFESztBQUVMSSxRQUFJVyxRQUZDO0FBR0xFLFFBQUlEO0FBSEMsR0FBUDtBQUtEIiwiZmlsZSI6ImFzc2VtYmxlLXNoYWRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtnbEdldERlYnVnSW5mb30gZnJvbSAnbHVtYS5nbCc7XG4vLyBMb2FkIHNoYWRlciBjaHVua3Ncbi8vIGltcG9ydCBTSEFERVJfQ0hVTktTIGZyb20gJy4uLy4uL2Rpc3Qvc2hhZGVybGliL3NoYWRlci1jaHVua3MnO1xuaW1wb3J0ICogYXMgU0hBREVSX0NIVU5LUyBmcm9tICcuL3NoYWRlci1jaHVua3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sIGdwdVZlbmRvcikge1xuICBjb25zdCB7dmVuZG9yLCByZW5kZXJlcn0gPSBkZWJ1Z0luZm87XG4gIGxldCByZXN1bHQ7XG4gIHN3aXRjaCAoZ3B1VmVuZG9yKSB7XG4gIGNhc2UgJ252aWRpYSc6XG4gICAgcmVzdWx0ID0gdmVuZG9yLm1hdGNoKC9OVklESUEvaSkgfHwgcmVuZGVyZXIubWF0Y2goL05WSURJQS9pKTtcbiAgICBicmVhaztcbiAgY2FzZSAnaW50ZWwnOlxuICAgIHJlc3VsdCA9IHZlbmRvci5tYXRjaCgvSU5URUwvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0lOVEVML2kpO1xuICAgIGJyZWFrO1xuICBjYXNlICdhbWQnOlxuICAgIHJlc3VsdCA9XG4gICAgICB2ZW5kb3IubWF0Y2goL0FNRC9pKSB8fCByZW5kZXJlci5tYXRjaCgvQU1EL2kpIHx8XG4gICAgICB2ZW5kb3IubWF0Y2goL0FUSS9pKSB8fCByZW5kZXJlci5tYXRjaCgvQVRJL2kpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHJlc3VsdCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGF0Zm9ybVNoYWRlckRlZmluZXMoZ2wpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgbGV0IHBsYXRmb3JtRGVmaW5lcyA9ICcnO1xuICBjb25zdCBkZWJ1Z0luZm8gPSBnbEdldERlYnVnSW5mbyhnbCk7XG5cbiAgaWYgKGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCAnbnZpZGlhJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIE5WSURJQV9HUFVcbiNkZWZpbmUgTlZJRElBX0ZQNjRfV09SS0FST1VORCAxXG4jZGVmaW5lIE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EIDFcbmA7XG4gIH0gZWxzZSBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdpbnRlbCcpKSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9IGBcXFxuI2RlZmluZSBJTlRFTF9HUFVcbiNkZWZpbmUgSU5URUxfRlA2NF9XT1JLQVJPVU5EIDFcbiNkZWZpbmUgTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQgMVxcbiBcXFxuI2RlZmluZSBJTlRFTF9UQU5fV09SS0FST1VORCAxXG5gO1xuICB9IGVsc2UgaWYgKGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCAnYW1kJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIEFNRF9HUFVcbmA7XG4gIH0gZWxzZSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9IGBcXFxuI2RlZmluZSBERUZBVUxUX0dQVVxuYDtcbiAgfVxuXG4gIHJldHVybiBwbGF0Zm9ybURlZmluZXM7XG59XG5cbmZ1bmN0aW9uIGFzc2VtYmxlU2hhZGVyKGdsLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge3ZzLCBwcm9qZWN0ID0gdHJ1ZSwgcHJvamVjdDY0ID0gZmFsc2V9ID0gb3B0cztcbiAgbGV0IHtmcDY0ID0gZmFsc2V9ID0gb3B0cztcbiAgaWYgKHByb2plY3Q2NCA9PT0gdHJ1ZSkge1xuICAgIGZwNjQgPSB0cnVlO1xuICB9XG4gIGxldCBzb3VyY2UgPSBgJHtnZXRQbGF0Zm9ybVNoYWRlckRlZmluZXMoZ2wpfVxcbmA7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7cHJvamVjdCwgcHJvamVjdDY0LCBmcDY0fSk7XG4gIGZvciAoY29uc3QgY2h1bmtOYW1lIG9mIE9iamVjdC5rZXlzKFNIQURFUl9DSFVOS1MpKSB7XG4gICAgaWYgKG9wdHNbY2h1bmtOYW1lXSkge1xuICAgICAgc291cmNlICs9IGAke1NIQURFUl9DSFVOS1NbY2h1bmtOYW1lXS5zb3VyY2V9XFxuYDtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBjaHVua05hbWUgb2Ygb3B0cy5tb2R1bGVzIHx8IFtdKSB7XG4gICAgaWYgKFNIQURFUl9DSFVOS1NbY2h1bmtOYW1lXSkge1xuICAgICAgc291cmNlICs9IGAke1NIQURFUl9DSFVOS1NbY2h1bmtOYW1lXS5zb3VyY2V9XFxuYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFkZXIgbW9kdWxlICR7Y2h1bmtOYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgc291cmNlICs9IHZzO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXJzKGdsLCBvcHRzKSB7XG4gIGNvbnN0IHZzU291cmNlID0gYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMpO1xuICBjb25zdCBmc1NvdXJjZSA9IG9wdHMuZnM7XG5cbiAgLy8gSWYgc2hhZGVyQ2FjaGUgcHJlc2VudHMsIG91dHB1dCBjb21waWxlZCBzaGFkZXJzIGZyb20gbHVtYS5nbC9zaGFkZUNhY2hlXG4gIGlmIChvcHRzLnNoYWRlckNhY2hlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdsLFxuICAgICAgdnM6IG9wdHMuc2hhZGVyQ2FjaGUuZ2V0VmVydGV4U2hhZGVyKGdsLCB2c1NvdXJjZSksXG4gICAgICBmczogb3B0cy5zaGFkZXJDYWNoZS5nZXRGcmFnbWVudFNoYWRlcihnbCwgZnNTb3VyY2UpXG4gICAgfVxuICB9O1xuICAvLyBPdGhlcndpc2UganVzdCBvdXRwdXQgc2hhZGVyIHNvdXJjZVxuICByZXR1cm4ge1xuICAgIGdsLFxuICAgIHZzOiB2c1NvdXJjZSxcbiAgICBmczogZnNTb3VyY2VcbiAgfVxufVxuIl19