// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { GL, withParameters, setParameters } from 'luma.gl';
import { getUniformsFromViewport } from './viewport-uniforms';
import { log } from './utils';

var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

export function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  // render layers in normal colors
  var visibleCount = 0;
  var compositeCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.isComposite) {
      compositeCount++;
    } else if (layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });
  var totalCount = layers.length;
  var primitiveCount = totalCount - compositeCount;
  var hiddenCount = primitiveCount - visibleCount;

  var message = '#' + renderCount++ + ': Rendering ' + visibleCount + ' of ' + totalCount + ' layers ' + pass + ' (' + hiddenCount + ' hidden, ' + compositeCount + ' composite)';

  log.log(2, message);
}

// Pick all objects within the given bounding box
export function queryLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      viewport = _ref2.viewport,
      mode = _ref2.mode;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  var pickInfos = getUniquesFromPickingBuffer(gl, {
    layers: layers,
    pickingFBO: pickingFBO,
    deviceRect: {
      x: deviceLeft,
      y: deviceTop,
      width: deviceRight - deviceLeft,
      height: deviceBottom - deviceTop
    }
  });

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  pickInfos.forEach(function (pickInfo) {
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
export function pickLayers(gl, _ref3) {
  var layers = _ref3.layers,
      pickingFBO = _ref3.pickingFBO,
      x = _ref3.x,
      y = _ref3.y,
      radius = _ref3.radius,
      viewport = _ref3.viewport,
      mode = _ref3.mode,
      lastPickedInfo = _ref3.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var _getClosestFromPickin = getClosestFromPickingBuffer(gl, {
    layers: layers,
    pickingFBO: pickingFBO,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius
  }),
      pickedColor = _getClosestFromPickin.pickedColor,
      pickedLayer = _getClosestFromPickin.pickedLayer,
      pickedObjectIndex = _getClosestFromPickin.pickedObjectIndex;

  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();
  var unhandledPickInfos = [];

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }
  });

  infos.forEach(function (info) {
    var handled = false;
    // Per-layer event handlers (e.g. onClick, onHover) are provided by the
    // user and out of deck.gl's control. It's very much possible that
    // the user calls React lifecycle methods in these function, such as
    // ReactComponent.setState(). React lifecycle methods sometimes induce
    // a re-render and re-generation of props of deck.gl and its layers,
    // which invalidates all layers currently passed to this very function.

    // Therefore, per-layer event handlers must be invoked at the end
    // of this function. NO operation that relies on the states of current
    // layers should be called after this code.
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);break;
      case 'hover':
        handled = info.layer.props.onHover(info);break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getClosestFromPickingBuffer(gl, _ref4) {
  var layers = _ref4.layers,
      pickingFBO = _ref4.pickingFBO,
      deviceX = _ref4.deviceX,
      deviceY = _ref4.deviceY,
      deviceRadius = _ref4.deviceRadius;

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;
  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;

  var pickedColors = getPickedColors(gl, { layers: layers, pickingFBO: pickingFBO, deviceRect: { x: x, y: y, width: width, height: height } });

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var closestResultToCenter = {
    pickedColor: EMPTY_PIXEL,
    pickedLayer: null,
    pickedObjectIndex: -1
  };
  var i = 0;

  for (var row = 0; row < height; row++) {
    for (var col = 0; col < width; col++) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var dx = col + x - deviceX;
        var dy = row + y - deviceY;
        var d2 = dx * dx + dy * dy;

        if (d2 <= minSquareDistanceToCenter) {
          minSquareDistanceToCenter = d2;

          // Decode picked object index from color
          var pickedColor = pickedColors.slice(i, i + 4);
          var pickedLayer = layers[pickedLayerIndex];
          var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
          closestResultToCenter = { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
        }
      }
      i += 4;
    }
  }

  return closestResultToCenter;
}
/* eslint-enable max-depth, max-statements */

/**
 * Query within a specified rectangle
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref5) {
  var layers = _ref5.layers,
      pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  var pickedColors = getPickedColors(gl, { layers: layers, pickingFBO: pickingFBO, deviceRect: { x: x, y: y, width: width, height: height } });
  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  for (var i = 0; i < pickedColors.length; i += 4) {
    // Decode picked layer from color
    var pickedLayerIndex = pickedColors[i + 3] - 1;

    if (pickedLayerIndex >= 0) {
      var pickedColor = pickedColors.slice(i, i + 4);
      var colorKey = pickedColor.join(',');
      if (!uniqueColors.has(colorKey)) {
        var pickedLayer = layers[pickedLayerIndex];
        uniqueColors.set(colorKey, {
          pickedColor: pickedColor,
          pickedLayer: pickedLayer,
          pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
        });
      }
    }
  }

  return Array.from(uniqueColors.values());
}

// Returns an Uint8ClampedArray of picked pixels
function getPickedColors(gl, _ref6) {
  var layers = _ref6.layers,
      pickingFBO = _ref6.pickingFBO,
      _ref6$deviceRect = _ref6.deviceRect,
      x = _ref6$deviceRect.x,
      y = _ref6$deviceRect.y,
      width = _ref6$deviceRect.width,
      height = _ref6$deviceRect.height;

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  // Note that the callback here is called synchronously.
  return withParameters(gl, {
    framebuffer: pickingFBO,
    scissorTest: true,
    scissor: [x, y, width, height],
    blend: true,
    blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
    blendEquation: gl.FUNC_ADD
    // TODO - Set clear color
  }, function () {

    // Clear the frame buffer
    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    var settings = {
      blend: true,
      blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
      blendEquation: gl.FUNC_ADD
    };

    withParameters(gl, settings, function () {
      // Render all pickable layers in picking colors
      layers.forEach(function (layer, layerIndex) {
        if (!layer.isComposite && layer.props.visible && layer.props.pickable) {

          // Encode layerIndex with alpha
          setParameters(gl, { blendColor: [0, 0, 0, (layerIndex + 1) / 255] });
          layer.drawLayer({
            uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
          });
        }
      });
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColors = new Uint8Array(width * height * 4);
    gl.readPixels(x, y, width, height, GL.RGBA, GL.UNSIGNED_BYTE, pickedColors);

    return pickedColors;
  });
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref7) {
  var layer = _ref7.layer,
      info = _ref7.info,
      mode = _ref7.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJHTCIsIndpdGhQYXJhbWV0ZXJzIiwic2V0UGFyYW1ldGVycyIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IiwibG9nIiwiRU1QVFlfUElYRUwiLCJVaW50OEFycmF5IiwicmVuZGVyQ291bnQiLCJkcmF3TGF5ZXJzIiwibGF5ZXJzIiwicGFzcyIsInZpc2libGVDb3VudCIsImNvbXBvc2l0ZUNvdW50IiwiZm9yRWFjaCIsImxheWVyIiwibGF5ZXJJbmRleCIsImlzQ29tcG9zaXRlIiwicHJvcHMiLCJ2aXNpYmxlIiwiZHJhd0xheWVyIiwidW5pZm9ybXMiLCJPYmplY3QiLCJhc3NpZ24iLCJyZW5kZXJQaWNraW5nQnVmZmVyIiwicGlja2luZ0VuYWJsZWQiLCJjb250ZXh0Iiwidmlld3BvcnQiLCJ0b3RhbENvdW50IiwibGVuZ3RoIiwicHJpbWl0aXZlQ291bnQiLCJoaWRkZW5Db3VudCIsIm1lc3NhZ2UiLCJxdWVyeUxheWVycyIsImdsIiwicGlja2luZ0ZCTyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJtb2RlIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VMZWZ0IiwiTWF0aCIsInJvdW5kIiwiZGV2aWNlQm90dG9tIiwiY2FudmFzIiwiZGV2aWNlUmlnaHQiLCJkZXZpY2VUb3AiLCJwaWNrSW5mb3MiLCJnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIiLCJkZXZpY2VSZWN0IiwidW5pcXVlSW5mb3MiLCJNYXAiLCJpbmZvIiwiY3JlYXRlSW5mbyIsInBpY2tJbmZvIiwiZGV2aWNlUGl4ZWwiLCJjb2xvciIsInBpY2tlZENvbG9yIiwiaW5kZXgiLCJwaWNrZWRPYmplY3RJbmRleCIsInBpY2tlZCIsImdldExheWVyUGlja2luZ0luZm8iLCJwaWNrZWRMYXllciIsImhhcyIsIm9iamVjdCIsInNldCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInBpY2tMYXllcnMiLCJyYWRpdXMiLCJsYXN0UGlja2VkSW5mbyIsImRldmljZVgiLCJkZXZpY2VZIiwiZGV2aWNlUmFkaXVzIiwiZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyIiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJsYXN0UGlja2VkTGF5ZXJJZCIsImxheWVySWQiLCJwaWNrZWRMYXllcklkIiwiaWQiLCJsYXN0UGlja2VkTGF5ZXIiLCJmaW5kIiwidW5zaGlmdCIsImJhc2VJbmZvIiwiaW5mb3MiLCJ1bmhhbmRsZWRQaWNrSW5mb3MiLCJoYW5kbGVkIiwib25DbGljayIsIm9uSG92ZXIiLCJFcnJvciIsInB1c2giLCJtYXgiLCJtaW4iLCJwaWNrZWRDb2xvcnMiLCJnZXRQaWNrZWRDb2xvcnMiLCJtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyIiwiY2xvc2VzdFJlc3VsdFRvQ2VudGVyIiwiaSIsInJvdyIsImNvbCIsInBpY2tlZExheWVySW5kZXgiLCJkeCIsImR5IiwiZDIiLCJzbGljZSIsImRlY29kZVBpY2tpbmdDb2xvciIsInVuaXF1ZUNvbG9ycyIsImNvbG9yS2V5Iiwiam9pbiIsImZyYW1lYnVmZmVyIiwic2Npc3NvclRlc3QiLCJzY2lzc29yIiwiYmxlbmQiLCJibGVuZEZ1bmMiLCJPTkUiLCJaRVJPIiwiQ09OU1RBTlRfQUxQSEEiLCJibGVuZEVxdWF0aW9uIiwiRlVOQ19BREQiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwic2V0dGluZ3MiLCJwaWNrYWJsZSIsImJsZW5kQ29sb3IiLCJyZWFkUGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJwaXhlbCIsImxuZ0xhdCIsInVucHJvamVjdCIsInNvdXJjZUxheWVyIiwicGlja0xheWVyIiwicGFyZW50TGF5ZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QztBQUNBLFNBQU87QUFDTGlDLFdBQU90RCxXQURGO0FBRUxTLFdBQU8sSUFGRjtBQUdMK0MsV0FBTyxDQUFDLENBSEg7QUFJTEUsWUFBUSxLQUpIO0FBS0w1QixPQUFHa0csTUFBTSxDQUFOLENBTEU7QUFNTGpHLE9BQUdpRyxNQUFNLENBQU4sQ0FORTtBQU9MQSxnQkFQSztBQVFMQyxZQUFRNUcsU0FBUzZHLFNBQVQsQ0FBbUJGLEtBQW5CO0FBUkgsR0FBUDtBQVVEOztBQUVEO0FBQ0EsU0FBU3JFLG1CQUFULFFBQWtEO0FBQUEsTUFBcEJsRCxLQUFvQixTQUFwQkEsS0FBb0I7QUFBQSxNQUFieUMsSUFBYSxTQUFiQSxJQUFhO0FBQUEsTUFBUGhCLElBQU8sU0FBUEEsSUFBTzs7QUFDaEQsU0FBT3pCLFNBQVN5QyxJQUFoQixFQUFzQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU1pRixjQUFjakYsS0FBS3pDLEtBQUwsSUFBY0EsS0FBbEM7QUFDQXlDLFNBQUt6QyxLQUFMLEdBQWFBLEtBQWI7QUFDQTtBQUNBO0FBQ0E7QUFDQXlDLFdBQU96QyxNQUFNMkgsU0FBTixDQUFnQixFQUFDbEYsVUFBRCxFQUFPaEIsVUFBUCxFQUFhaUcsd0JBQWIsRUFBaEIsQ0FBUDtBQUNBMUgsWUFBUUEsTUFBTTRILFdBQWQ7QUFDRDtBQUNELFNBQU9uRixJQUFQO0FBQ0QiLCJmaWxlIjoiZHJhdy1hbmQtcGljay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCB3aXRoUGFyYW1ldGVycywgc2V0UGFyYW1ldGVyc30gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2dldFVuaWZvcm1zRnJvbVZpZXdwb3J0fSBmcm9tICcuL3ZpZXdwb3J0LXVuaWZvcm1zJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgRU1QVFlfUElYRUwgPSBuZXcgVWludDhBcnJheSg0KTtcbmxldCByZW5kZXJDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TGF5ZXJzKHtsYXllcnMsIHBhc3N9KSB7XG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsZXQgdmlzaWJsZUNvdW50ID0gMDtcbiAgbGV0IGNvbXBvc2l0ZUNvdW50ID0gMDtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5pc0NvbXBvc2l0ZSkge1xuICAgICAgY29tcG9zaXRlQ291bnQrKztcbiAgICB9IGVsc2UgaWYgKGxheWVyLnByb3BzLnZpc2libGUpIHtcbiAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtyZW5kZXJQaWNraW5nQnVmZmVyOiAwLCBwaWNraW5nRW5hYmxlZDogMH0sXG4gICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAge2xheWVySW5kZXh9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdmlzaWJsZUNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgdG90YWxDb3VudCA9IGxheWVycy5sZW5ndGg7XG4gIGNvbnN0IHByaW1pdGl2ZUNvdW50ID0gdG90YWxDb3VudCAtIGNvbXBvc2l0ZUNvdW50O1xuICBjb25zdCBoaWRkZW5Db3VudCA9IHByaW1pdGl2ZUNvdW50IC0gdmlzaWJsZUNvdW50O1xuXG4gIGNvbnN0IG1lc3NhZ2UgPSBgXFxcbiMke3JlbmRlckNvdW50Kyt9OiBSZW5kZXJpbmcgJHt2aXNpYmxlQ291bnR9IG9mICR7dG90YWxDb3VudH0gbGF5ZXJzICR7cGFzc30gXFxcbigke2hpZGRlbkNvdW50fSBoaWRkZW4sICR7Y29tcG9zaXRlQ291bnR9IGNvbXBvc2l0ZSlgO1xuXG4gIGxvZy5sb2coMiwgbWVzc2FnZSk7XG59XG5cbi8vIFBpY2sgYWxsIG9iamVjdHMgd2l0aGluIHRoZSBnaXZlbiBib3VuZGluZyBib3hcbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUxheWVycyhnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIHgsXG4gIHksXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHZpZXdwb3J0LFxuICBtb2RlXG59KSB7XG5cbiAgLy8gQ29udmVydCBmcm9tIGNhbnZhcyB0b3AtbGVmdCB0byBXZWJHTCBib3R0b20tbGVmdCBjb29yZGluYXRlc1xuICAvLyBBbmQgY29tcGVuc2F0ZSBmb3IgcGl4ZWxSYXRpb1xuICBjb25zdCBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGRldmljZUxlZnQgPSBNYXRoLnJvdW5kKHggKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlQm90dG9tID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0geSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VSaWdodCA9IE1hdGgucm91bmQoKHggKyB3aWR0aCkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlVG9wID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0gKHkgKyBoZWlnaHQpICogcGl4ZWxSYXRpbyk7XG5cbiAgY29uc3QgcGlja0luZm9zID0gZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlUmVjdDoge1xuICAgICAgeDogZGV2aWNlTGVmdCxcbiAgICAgIHk6IGRldmljZVRvcCxcbiAgICAgIHdpZHRoOiBkZXZpY2VSaWdodCAtIGRldmljZUxlZnQsXG4gICAgICBoZWlnaHQ6IGRldmljZUJvdHRvbSAtIGRldmljZVRvcFxuICAgIH1cbiAgfSk7XG5cbiAgLy8gT25seSByZXR1cm4gdW5pcXVlIGluZm9zLCBpZGVudGlmaWVkIGJ5IGluZm8ub2JqZWN0XG4gIGNvbnN0IHVuaXF1ZUluZm9zID0gbmV3IE1hcCgpO1xuXG4gIHBpY2tJbmZvcy5mb3JFYWNoKHBpY2tJbmZvID0+IHtcbiAgICBsZXQgaW5mbyA9IGNyZWF0ZUluZm8oW3BpY2tJbmZvLnggLyBwaXhlbFJhdGlvLCBwaWNrSW5mby55IC8gcGl4ZWxSYXRpb10sIHZpZXdwb3J0KTtcbiAgICBpbmZvLmRldmljZVBpeGVsID0gW3BpY2tJbmZvLngsIHBpY2tJbmZvLnldO1xuICAgIGluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgaW5mby5jb2xvciA9IHBpY2tJbmZvLnBpY2tlZENvbG9yO1xuICAgIGluZm8uaW5kZXggPSBwaWNrSW5mby5waWNrZWRPYmplY3RJbmRleDtcbiAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG5cbiAgICBpbmZvID0gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXI6IHBpY2tJbmZvLnBpY2tlZExheWVyLCBpbmZvLCBtb2RlfSk7XG4gICAgaWYgKCF1bmlxdWVJbmZvcy5oYXMoaW5mby5vYmplY3QpKSB7XG4gICAgICB1bmlxdWVJbmZvcy5zZXQoaW5mby5vYmplY3QsIGluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlSW5mb3MudmFsdWVzKCkpO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG4vLyBQaWNrIHRoZSBjbG9zZXN0IG9iamVjdCBhdCB0aGUgZ2l2ZW4gKHgseSkgY29vcmRpbmF0ZVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tMYXllcnMoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICB4LFxuICB5LFxuICByYWRpdXMsXG4gIHZpZXdwb3J0LFxuICBtb2RlLFxuICBsYXN0UGlja2VkSW5mb1xufSkge1xuXG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBkZXZpY2VYID0gTWF0aC5yb3VuZCh4ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVkgPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVJhZGl1cyA9IE1hdGgucm91bmQocmFkaXVzICogcGl4ZWxSYXRpbyk7XG5cbiAgY29uc3Qge1xuICAgIHBpY2tlZENvbG9yLFxuICAgIHBpY2tlZExheWVyLFxuICAgIHBpY2tlZE9iamVjdEluZGV4XG4gIH0gPSBnZXRDbG9zZXN0RnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgICBsYXllcnMsXG4gICAgcGlja2luZ0ZCTyxcbiAgICBkZXZpY2VYLFxuICAgIGRldmljZVksXG4gICAgZGV2aWNlUmFkaXVzXG4gIH0pO1xuICBjb25zdCBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgLy8gb25seSBpbnZva2Ugb25Ib3ZlciBldmVudHMgaWYgcGlja2VkIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgIGNvbnN0IGxhc3RQaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8ubGF5ZXJJZDtcbiAgICBjb25zdCBwaWNrZWRMYXllcklkID0gcGlja2VkTGF5ZXIgJiYgcGlja2VkTGF5ZXIucHJvcHMuaWQ7XG5cbiAgICAvLyBwcm9jZWVkIG9ubHkgaWYgcGlja2VkIG9iamVjdCBjaGFuZ2VkXG4gICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkIHx8IHBpY2tlZE9iamVjdEluZGV4ICE9PSBsYXN0UGlja2VkT2JqZWN0SW5kZXgpIHtcbiAgICAgIGlmIChwaWNrZWRMYXllcklkICE9PSBsYXN0UGlja2VkTGF5ZXJJZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3Qgc3RvcmUgYSByZWYgdG8gbGFzdFBpY2tlZExheWVyIGluIHRoZSBjb250ZXh0IGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIHN0YXRlIG9mIGFuIG91dGRhdGVkIGxheWVyIGlzIG5vIGxvbmdlciB2YWxpZFxuICAgICAgICAvLyBhbmQgdGhlIHByb3BzIG1heSBoYXZlIGNoYW5nZWRcbiAgICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVyID0gbGF5ZXJzLmZpbmQobGF5ZXIgPT4gbGF5ZXIucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkKTtcbiAgICAgICAgaWYgKGxhc3RQaWNrZWRMYXllcikge1xuICAgICAgICAgIC8vIExldCBsZWF2ZSBldmVudCBmaXJlIGJlZm9yZSBlbnRlciBldmVudFxuICAgICAgICAgIGFmZmVjdGVkTGF5ZXJzLnVuc2hpZnQobGFzdFBpY2tlZExheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbGF5ZXIgbWFuYWdlciBjb250ZXh0XG4gICAgICBsYXN0UGlja2VkSW5mby5sYXllcklkID0gcGlja2VkTGF5ZXJJZDtcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYmFzZUluZm8gPSBjcmVhdGVJbmZvKFt4LCB5XSwgdmlld3BvcnQpO1xuICBiYXNlSW5mby5kZXZpY2VQaXhlbCA9IFtkZXZpY2VYLCBkZXZpY2VZXTtcbiAgYmFzZUluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgLy8gVXNlIGEgTWFwIHRvIHN0b3JlIGFsbCBwaWNraW5nIGluZm9zLlxuICAvLyBUaGUgZm9sbG93aW5nIHR3byBmb3JFYWNoIGxvb3BzIGFyZSB0aGUgcmVzdWx0IG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzQ0M1xuICAvLyBQbGVhc2UgYmUgdmVyeSBjYXJlZnVsIHdoZW4gY2hhbmdpbmcgdGhpcyBwYXR0ZXJuXG4gIGNvbnN0IGluZm9zID0gbmV3IE1hcCgpO1xuICBjb25zdCB1bmhhbmRsZWRQaWNrSW5mb3MgPSBbXTtcblxuICBhZmZlY3RlZExheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbmZvKTtcblxuICAgIGlmIChsYXllciA9PT0gcGlja2VkTGF5ZXIpIHtcbiAgICAgIGluZm8uY29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICAgIGluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmZvID0gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXIsIGluZm8sIG1vZGV9KTtcblxuICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIHdpbGwgYmUgb25seSBvbmUgY29weSBvZiBpbmZvIGZvclxuICAgIC8vIG9uZSBjb21wb3NpdGUgbGF5ZXJcbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mb3Muc2V0KGluZm8ubGF5ZXIuaWQsIGluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5mb3MuZm9yRWFjaChpbmZvID0+IHtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgIC8vIFBlci1sYXllciBldmVudCBoYW5kbGVycyAoZS5nLiBvbkNsaWNrLCBvbkhvdmVyKSBhcmUgcHJvdmlkZWQgYnkgdGhlXG4gICAgLy8gdXNlciBhbmQgb3V0IG9mIGRlY2suZ2wncyBjb250cm9sLiBJdCdzIHZlcnkgbXVjaCBwb3NzaWJsZSB0aGF0XG4gICAgLy8gdGhlIHVzZXIgY2FsbHMgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgaW4gdGhlc2UgZnVuY3Rpb24sIHN1Y2ggYXNcbiAgICAvLyBSZWFjdENvbXBvbmVudC5zZXRTdGF0ZSgpLiBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBzb21ldGltZXMgaW5kdWNlXG4gICAgLy8gYSByZS1yZW5kZXIgYW5kIHJlLWdlbmVyYXRpb24gb2YgcHJvcHMgb2YgZGVjay5nbCBhbmQgaXRzIGxheWVycyxcbiAgICAvLyB3aGljaCBpbnZhbGlkYXRlcyBhbGwgbGF5ZXJzIGN1cnJlbnRseSBwYXNzZWQgdG8gdGhpcyB2ZXJ5IGZ1bmN0aW9uLlxuXG4gICAgLy8gVGhlcmVmb3JlLCBwZXItbGF5ZXIgZXZlbnQgaGFuZGxlcnMgbXVzdCBiZSBpbnZva2VkIGF0IHRoZSBlbmRcbiAgICAvLyBvZiB0aGlzIGZ1bmN0aW9uLiBOTyBvcGVyYXRpb24gdGhhdCByZWxpZXMgb24gdGhlIHN0YXRlcyBvZiBjdXJyZW50XG4gICAgLy8gbGF5ZXJzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyBjb2RlLlxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2NsaWNrJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25DbGljayhpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAnaG92ZXInOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkhvdmVyKGluZm8pOyBicmVhaztcbiAgICBjYXNlICdxdWVyeSc6IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBwaWNrIHR5cGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgIHVuaGFuZGxlZFBpY2tJbmZvcy5wdXNoKGluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cblxuLyoqXG4gKiBQaWNrIGF0IGEgc3BlY2lmaWVkIHBpeGVsIHdpdGggYSB0b2xlcmFuY2UgcmFkaXVzXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IG9iamVjdCB0byB0aGUgcGl4ZWwgaW4gc2hhcGUgYHtwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fWBcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgZGV2aWNlWCxcbiAgZGV2aWNlWSxcbiAgZGV2aWNlUmFkaXVzXG59KSB7XG4gIC8vIENyZWF0ZSBhIGJveCBvZiBzaXplIGByYWRpdXMgKiAyICsgMWAgY2VudGVyZWQgYXQgW2RldmljZVgsIGRldmljZVldXG4gIGNvbnN0IHggPSBNYXRoLm1heCgwLCBkZXZpY2VYIC0gZGV2aWNlUmFkaXVzKTtcbiAgY29uc3QgeSA9IE1hdGgubWF4KDAsIGRldmljZVkgLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB3aWR0aCA9IE1hdGgubWluKHBpY2tpbmdGQk8ud2lkdGgsIGRldmljZVggKyBkZXZpY2VSYWRpdXMpIC0geCArIDE7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKHBpY2tpbmdGQk8uaGVpZ2h0LCBkZXZpY2VZICsgZGV2aWNlUmFkaXVzKSAtIHkgKyAxO1xuXG4gIGNvbnN0IHBpY2tlZENvbG9ycyA9IGdldFBpY2tlZENvbG9ycyhnbCwge2xheWVycywgcGlja2luZ0ZCTywgZGV2aWNlUmVjdDoge3gsIHksIHdpZHRoLCBoZWlnaHR9fSk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIHBpeGVscyBpbiBwaWNraW5nIHJlc3VsdHMgYW5kIGZpbmQgdGhlIG9uZSBjbG9zZXN0IHRvIHRoZSBzdXBwbGllZFxuICAvLyBbZGV2aWNlWCwgZGV2aWNlWV1cbiAgbGV0IG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIgPSBkZXZpY2VSYWRpdXMgKiBkZXZpY2VSYWRpdXM7XG4gIGxldCBjbG9zZXN0UmVzdWx0VG9DZW50ZXIgPSB7XG4gICAgcGlja2VkQ29sb3I6IEVNUFRZX1BJWEVMLFxuICAgIHBpY2tlZExheWVyOiBudWxsLFxuICAgIHBpY2tlZE9iamVjdEluZGV4OiAtMVxuICB9O1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHdpZHRoOyBjb2wrKykge1xuICAgICAgLy8gRGVjb2RlIHBpY2tlZCBsYXllciBmcm9tIGNvbG9yXG4gICAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2kgKyAzXSAtIDE7XG5cbiAgICAgIGlmIChwaWNrZWRMYXllckluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgZHggPSBjb2wgKyB4IC0gZGV2aWNlWDtcbiAgICAgICAgY29uc3QgZHkgPSByb3cgKyB5IC0gZGV2aWNlWTtcbiAgICAgICAgY29uc3QgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICBpZiAoZDIgPD0gbWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlcikge1xuICAgICAgICAgIG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIgPSBkMjtcblxuICAgICAgICAgIC8vIERlY29kZSBwaWNrZWQgb2JqZWN0IGluZGV4IGZyb20gY29sb3JcbiAgICAgICAgICBjb25zdCBwaWNrZWRDb2xvciA9IHBpY2tlZENvbG9ycy5zbGljZShpLCBpICsgNCk7XG4gICAgICAgICAgY29uc3QgcGlja2VkTGF5ZXIgPSBsYXllcnNbcGlja2VkTGF5ZXJJbmRleF07XG4gICAgICAgICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpO1xuICAgICAgICAgIGNsb3Nlc3RSZXN1bHRUb0NlbnRlciA9IHtwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSArPSA0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0UmVzdWx0VG9DZW50ZXI7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBRdWVyeSB3aXRoaW4gYSBzcGVjaWZpZWQgcmVjdGFuZ2xlXG4gKiBSZXR1cm5zIGFycmF5IG9mIHVuaXF1ZSBvYmplY3RzIGluIHNoYXBlIGB7eCwgeSwgcGlja2VkQ29sb3IsIHBpY2tlZExheWVyLCBwaWNrZWRPYmplY3RJbmRleH1gXG4gKi9cbmZ1bmN0aW9uIGdldFVuaXF1ZXNGcm9tUGlja2luZ0J1ZmZlcihnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxufSkge1xuICBjb25zdCBwaWNrZWRDb2xvcnMgPSBnZXRQaWNrZWRDb2xvcnMoZ2wsIHtsYXllcnMsIHBpY2tpbmdGQk8sIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fX0pO1xuICBjb25zdCB1bmlxdWVDb2xvcnMgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIHBpeGVscyBpbiBwaWNraW5nIHJlc3VsdHMgYW5kIGdldCB1bmlxdWUgY29sb3JzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGlja2VkQ29sb3JzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgLy8gRGVjb2RlIHBpY2tlZCBsYXllciBmcm9tIGNvbG9yXG4gICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yc1tpICsgM10gLSAxO1xuXG4gICAgaWYgKHBpY2tlZExheWVySW5kZXggPj0gMCkge1xuICAgICAgY29uc3QgcGlja2VkQ29sb3IgPSBwaWNrZWRDb2xvcnMuc2xpY2UoaSwgaSArIDQpO1xuICAgICAgY29uc3QgY29sb3JLZXkgPSBwaWNrZWRDb2xvci5qb2luKCcsJyk7XG4gICAgICBpZiAoIXVuaXF1ZUNvbG9ycy5oYXMoY29sb3JLZXkpKSB7XG4gICAgICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgICAgICB1bmlxdWVDb2xvcnMuc2V0KGNvbG9yS2V5LCB7XG4gICAgICAgICAgcGlja2VkQ29sb3IsXG4gICAgICAgICAgcGlja2VkTGF5ZXIsXG4gICAgICAgICAgcGlja2VkT2JqZWN0SW5kZXg6IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlQ29sb3JzLnZhbHVlcygpKTtcbn1cblxuLy8gUmV0dXJucyBhbiBVaW50OENsYW1wZWRBcnJheSBvZiBwaWNrZWQgcGl4ZWxzXG5mdW5jdGlvbiBnZXRQaWNrZWRDb2xvcnMoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbn0pIHtcbiAgLy8gTWFrZSBzdXJlIHdlIGNsZWFyIHNjaXNzb3IgdGVzdCBhbmQgZmJvIGJpbmRpbmdzIGluIGNhc2Ugb2YgZXhjZXB0aW9uc1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG9uZSBwaXhlbCwgbm8gbmVlZCB0byByZW5kZXIgYW55dGhpbmcgZWxzZVxuICAvLyBOb3RlIHRoYXQgdGhlIGNhbGxiYWNrIGhlcmUgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gIHJldHVybiB3aXRoUGFyYW1ldGVycyhnbCwge1xuICAgIGZyYW1lYnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIHNjaXNzb3JUZXN0OiB0cnVlLFxuICAgIHNjaXNzb3I6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSxcbiAgICBibGVuZDogdHJ1ZSxcbiAgICBibGVuZEZ1bmM6IFtnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPXSxcbiAgICBibGVuZEVxdWF0aW9uOiBnbC5GVU5DX0FERFxuICAgIC8vIFRPRE8gLSBTZXQgY2xlYXIgY29sb3JcbiAgfSwgKCkgPT4ge1xuXG4gICAgLy8gQ2xlYXIgdGhlIGZyYW1lIGJ1ZmZlclxuICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgIC8vIFNldCBibGVuZCBtb2RlIGZvciBwaWNraW5nXG4gICAgLy8gYWx3YXlzIG92ZXJ3cml0ZSBleGlzdGluZyBwaXhlbCB3aXRoIFtyLGcsYixsYXllckluZGV4XVxuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICBibGVuZEZ1bmM6IFtnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPXSxcbiAgICAgIGJsZW5kRXF1YXRpb246IGdsLkZVTkNfQUREXG4gICAgfTtcblxuICAgIHdpdGhQYXJhbWV0ZXJzKGdsLCBzZXR0aW5ncywgKCkgPT4ge1xuICAgICAgLy8gUmVuZGVyIGFsbCBwaWNrYWJsZSBsYXllcnMgaW4gcGlja2luZyBjb2xvcnNcbiAgICAgIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgICAgICBpZiAoIWxheWVyLmlzQ29tcG9zaXRlICYmIGxheWVyLnByb3BzLnZpc2libGUgJiYgbGF5ZXIucHJvcHMucGlja2FibGUpIHtcblxuICAgICAgICAgIC8vIEVuY29kZSBsYXllckluZGV4IHdpdGggYWxwaGFcbiAgICAgICAgICBzZXRQYXJhbWV0ZXJzKGdsLCB7YmxlbmRDb2xvcjogWzAsIDAsIDAsIChsYXllckluZGV4ICsgMSkgLyAyNTVdfSk7XG4gICAgICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMSwgcGlja2luZ0VuYWJsZWQ6IDF9LFxuICAgICAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlYWQgY29sb3IgaW4gdGhlIGNlbnRyYWwgcGl4ZWwsIHRvIGJlIG1hcHBlZCB3aXRoIHBpY2tpbmcgY29sb3JzXG4gICAgY29uc3QgcGlja2VkQ29sb3JzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIEdMLlJHQkEsIEdMLlVOU0lHTkVEX0JZVEUsIHBpY2tlZENvbG9ycyk7XG5cbiAgICByZXR1cm4gcGlja2VkQ29sb3JzO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5mbyhwaXhlbCwgdmlld3BvcnQpIHtcbiAgLy8gQXNzaWduIGEgbnVtYmVyIG9mIHBvdGVudGlhbGx5IHVzZWZ1bCBwcm9wcyB0byB0aGUgXCJpbmZvXCIgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgY29sb3I6IEVNUFRZX1BJWEVMLFxuICAgIGxheWVyOiBudWxsLFxuICAgIGluZGV4OiAtMSxcbiAgICBwaWNrZWQ6IGZhbHNlLFxuICAgIHg6IHBpeGVsWzBdLFxuICAgIHk6IHBpeGVsWzFdLFxuICAgIHBpeGVsLFxuICAgIGxuZ0xhdDogdmlld3BvcnQudW5wcm9qZWN0KHBpeGVsKVxuICB9O1xufVxuXG4vLyBXYWxrIHVwIHRoZSBsYXllciBjb21wb3NpdGUgY2hhaW4gdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0XG5mdW5jdGlvbiBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllciwgaW5mbywgbW9kZX0pIHtcbiAgd2hpbGUgKGxheWVyICYmIGluZm8pIHtcbiAgICAvLyBGb3IgYSBjb21wb3NpdGUgbGF5ZXIsIHNvdXJjZUxheWVyIHdpbGwgcG9pbnQgdG8gdGhlIHN1YmxheWVyXG4gICAgLy8gd2hlcmUgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbS5cbiAgICAvLyBJdCBwcm92aWRlcyBhZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGUgbGF5ZXInc1xuICAgIC8vIGdldFBpY2tpbmdJbmZvKCkgbWV0aG9kIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuICAgIGNvbnN0IHNvdXJjZUxheWVyID0gaW5mby5sYXllciB8fCBsYXllcjtcbiAgICBpbmZvLmxheWVyID0gbGF5ZXI7XG4gICAgLy8gbGF5ZXIucGlja0xheWVyKCkgZnVuY3Rpb24gcmVxdWlyZXMgYSBub24tbnVsbCBgYGBsYXllci5zdGF0ZWBgYFxuICAgIC8vIG9iamVjdCB0byBmdW50aW9uIHByb3Blcmx5LiBTbyB0aGUgbGF5ZXIgcmVmZXJlY2VkIGhlcmVcbiAgICAvLyBtdXN0IGJlIHRoZSBcImN1cnJlbnRcIiBsYXllciwgbm90IGFuIFwib3V0LWRhdGVkXCIgLyBcImludmFsaWRhdGVkXCIgbGF5ZXJcbiAgICBpbmZvID0gbGF5ZXIucGlja0xheWVyKHtpbmZvLCBtb2RlLCBzb3VyY2VMYXllcn0pO1xuICAgIGxheWVyID0gbGF5ZXIucGFyZW50TGF5ZXI7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG4iXX0=