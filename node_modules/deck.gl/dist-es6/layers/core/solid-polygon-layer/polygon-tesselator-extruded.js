var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import * as Polygon from './polygon';
import { vec3 } from 'gl-matrix';
import { fp64ify } from '../../../lib/utils/fp64';
import { get, count } from '../../../lib/utils';
import earcut from 'earcut';
import flattenDeep from 'lodash.flattendeep';

function getPickingColor(index) {
  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];
}

function parseColor(color) {
  if (!Array.isArray(color)) {
    color = [get(color, 0), get(color, 1), get(color, 2), get(color, 3)];
  }
  color[3] = Number.isFinite(color[3]) ? color[3] : 255;
  return color;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

export var PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return [0, 0, 0, 255];
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = polygons.map(function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return Polygon.normalize(complexPolygon).map(function (polygon) {
        return polygon.map(function (coord) {
          return [get(coord, 0), get(coord, 1), height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

function countVertices(vertices) {
  return vertices.reduce(function (vertexCount, polygon) {
    return vertexCount + count(polygon);
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple polygons
  var multiplier = wireframe ? 2 : 5;
  var offsets = groupedVertices.reduce(function (acc, vertices) {
    return acc.concat(acc[acc.length - 1] + countVertices(vertices) * multiplier);
  }, [0]);

  var indices = groupedVertices.map(function (vertices, polygonIndex) {
    return wireframe ?
    // 1. get sequentially ordered indices of each polygons wireframe
    // 2. offset them by the number of indices in previous polygons
    calculateContourIndices(vertices, offsets[polygonIndex]) :
    // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous polygons
    calculateSurfaceIndices(vertices, offsets[polygonIndex]);
  });

  return new Uint32Array(flattenDeep(indices));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var positions = groupedVertices.map(function (vertices) {
    var topVertices = Array.prototype.concat.apply([], vertices);
    var baseVertices = topVertices.map(function (v) {
      return [get(v, 0), get(v, 1), 0];
    });
    return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
  });

  return flattenDeep(positions);
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    positionLow = new Float32Array(positionsJS.length / 3 * 2);
    for (var i = 0; i < positionsJS.length / 3; i++) {
      positionLow[i * 2 + 0] = fp64ify(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = fp64ify(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      wireframe = _ref5.wireframe;

  var up = [0, 1, 0];

  var normals = groupedVertices.map(function (vertices, polygonIndex) {
    var topNormals = new Array(countVertices(vertices)).fill(up);
    var sideNormals = vertices.map(function (polygon) {
      return calculateSideNormals(polygon);
    });
    var sideNormalsForward = sideNormals.map(function (n) {
      return n[0];
    });
    var sideNormalsBackward = sideNormals.map(function (n) {
      return n[1];
    });

    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
  });

  return new Float32Array(flattenDeep(normals));
}

function calculateSideNormals(vertices) {
  var normals = [];

  var lastVertice = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vertice = _step.value;

      if (lastVertice) {
        // vertex[i-1], vertex[i]
        var n = getNormal(lastVertice, vertice);
        normals.push(n);
      }
      lastVertice = vertice;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [[normals.concat(normals[0])], [[normals[0]].concat(normals)]];
}

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color = parseColor(color);

    var numVertices = countVertices(complexPolygon);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray(flattenDeep(colors));
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var colors = groupedVertices.map(function (vertices, polygonIndex) {
    var numVertices = countVertices(vertices);
    var color = getPickingColor(polygonIndex);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray(flattenDeep(colors));
}

function calculateContourIndices(vertices, offset) {
  var stride = countVertices(vertices);

  return vertices.map(function (polygon) {
    var indices = [offset];
    var numVertices = polygon.length;

    // polygon top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // polygon sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
    return indices;
  });
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = countVertices(vertices);
  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

  function drawRectangle(i) {
    return quad.map(function (v) {
      return i + v[0] + stride * v[1] + offset;
    });
  }

  var holes = null;

  if (vertices.length > 1) {
    holes = vertices.reduce(function (acc, polygon) {
      return acc.concat(acc[acc.length - 1] + polygon.length);
    }, [0]).slice(1, vertices.length);
  }

  var topIndices = earcut(flattenDeep(vertices), holes, 3).map(function (index) {
    return index + offset;
  });

  var sideIndices = vertices.map(function (polygon) {
    var numVertices = polygon.length;
    // polygon top
    var indices = [];

    // polygon sides
    for (var i = 0; i < numVertices - 1; i++) {
      indices = indices.concat(drawRectangle(i));
    }

    offset += numVertices;
    return indices;
  });

  return [topIndices, sideIndices];
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  var p1x = get(p1, 0);
  var p1y = get(p1, 1);
  var p2x = get(p2, 0);
  var p2y = get(p2, 1);

  if (p1x === p2x && p1y === p2y) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;
  var lon1 = degrees2radians * p1x;
  var lon2 = degrees2radians * p2x;
  var lat1 = degrees2radians * p1y;
  var lat2 = degrees2radians * p2y;
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return vec3.normalize([], [b, 0, -a]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwidmVjMyIsImZwNjRpZnkiLCJnZXQiLCJjb3VudCIsImVhcmN1dCIsImZsYXR0ZW5EZWVwIiwiZ2V0UGlja2luZ0NvbG9yIiwiaW5kZXgiLCJwYXJzZUNvbG9yIiwiY29sb3IiLCJBcnJheSIsImlzQXJyYXkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbnNKUyIsImNhbGN1bGF0ZVBvc2l0aW9uc0pTIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb25zIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiaW5kaWNlcyIsImNhbGN1bGF0ZUluZGljZXMiLCJub3JtYWxzIiwiY2FsY3VsYXRlTm9ybWFscyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwiY2FsY3VsYXRlQ29sb3JzIiwiY291bnRWZXJ0aWNlcyIsInZlcnRpY2VzIiwicmVkdWNlIiwidmVydGV4Q291bnQiLCJtdWx0aXBsaWVyIiwib2Zmc2V0cyIsImFjYyIsImNvbmNhdCIsImxlbmd0aCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJVaW50MzJBcnJheSIsInRvcFZlcnRpY2VzIiwicHJvdG90eXBlIiwiYXBwbHkiLCJiYXNlVmVydGljZXMiLCJ2IiwicG9zaXRpb25Mb3ciLCJGbG9hdDMyQXJyYXkiLCJpIiwicG9zaXRpb25zNjR4eUxvdyIsInVwIiwidG9wTm9ybWFscyIsImZpbGwiLCJzaWRlTm9ybWFscyIsImNhbGN1bGF0ZVNpZGVOb3JtYWxzIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwibiIsInNpZGVOb3JtYWxzQmFja3dhcmQiLCJsYXN0VmVydGljZSIsInZlcnRpY2UiLCJnZXROb3JtYWwiLCJwdXNoIiwiY29sb3JzIiwibnVtVmVydGljZXMiLCJ0b3BDb2xvcnMiLCJiYXNlQ29sb3JzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJvZmZzZXQiLCJzdHJpZGUiLCJxdWFkIiwiZHJhd1JlY3RhbmdsZSIsImhvbGVzIiwic2xpY2UiLCJ0b3BJbmRpY2VzIiwic2lkZUluZGljZXMiLCJwMSIsInAyIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwiZGVncmVlczJyYWRpYW5zIiwiTWF0aCIsIlBJIiwibG9uMSIsImxvbjIiLCJsYXQxIiwibGF0MiIsImEiLCJzaW4iLCJjb3MiLCJiIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxLQUFLQSxPQUFaLE1BQXlCLFdBQXpCO0FBQ0EsU0FBUUMsSUFBUixRQUFtQixXQUFuQjtBQUNBLFNBQVFDLE9BQVIsUUFBc0IseUJBQXRCO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxLQUFiLFFBQXlCLG9CQUF6QjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLG9CQUF4Qjs7QUFFQSxTQUFTQyxlQUFULENBQXlCQyxLQUF6QixFQUFnQztBQUM5QixTQUFPLENBQ0pBLFFBQVEsQ0FBVCxHQUFjLEdBRFQsRUFFSEEsUUFBUSxDQUFULElBQWUsQ0FBaEIsR0FBcUIsR0FGaEIsRUFHRkEsUUFBUSxDQUFULElBQWUsQ0FBaEIsSUFB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SUFBVCxDQUFqQixHQUFrQ0wsS0FBS1EsR0FBTCxDQUFTTCxPQUFPRCxJQUFoQixDQURwQztBQUVBLFNBQU9sRyxLQUFLeUIsU0FBTCxDQUFlLEVBQWYsRUFBbUIsQ0FBQ2dGLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQ0gsQ0FBUixDQUFuQixDQUFQO0FBQ0QiLCJmaWxlIjoicG9seWdvbi10ZXNzZWxhdG9yLWV4dHJ1ZGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCB7dmVjM30gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7ZnA2NGlmeX0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtnZXQsIGNvdW50fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5cbmZ1bmN0aW9uIGdldFBpY2tpbmdDb2xvcihpbmRleCkge1xuICByZXR1cm4gW1xuICAgIChpbmRleCArIDEpICYgMjU1LFxuICAgICgoaW5kZXggKyAxKSA+PiA4KSAmIDI1NSxcbiAgICAoKChpbmRleCArIDEpID4+IDgpID4+IDgpICYgMjU1XG4gIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoY29sb3IpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIGNvbG9yID0gW2dldChjb2xvciwgMCksIGdldChjb2xvciwgMSksIGdldChjb2xvciwgMiksIGdldChjb2xvciwgMyldO1xuICB9XG4gIGNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogMjU1O1xuICByZXR1cm4gY29sb3I7XG59XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTsgLy8gQmxhY2tcblxuZXhwb3J0IGNsYXNzIFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQge1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb2x5Z29ucyxcbiAgICBnZXRIZWlnaHQgPSB4ID0+IDEwMDAsXG4gICAgZ2V0Q29sb3IgPSB4ID0+IFswLCAwLCAwLCAyNTVdLFxuICAgIHdpcmVmcmFtZSA9IGZhbHNlLFxuICAgIGZwNjQgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy5mcDY0ID0gZnA2NDtcblxuICAgIC8vIEV4cGVuc2l2ZSBvcGVyYXRpb24sIGNvbnZlcnQgYWxsIHBvbHlnb25zIHRvIGFycmF5c1xuICAgIHBvbHlnb25zID0gcG9seWdvbnMubWFwKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQocG9seWdvbkluZGV4KSB8fCAwO1xuICAgICAgcmV0dXJuIFBvbHlnb24ubm9ybWFsaXplKGNvbXBsZXhQb2x5Z29uKS5tYXAoXG4gICAgICAgIHBvbHlnb24gPT4gcG9seWdvbi5tYXAoY29vcmQgPT4gW2dldChjb29yZCwgMCksIGdldChjb29yZCwgMSksIGhlaWdodF0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy5ncm91cGVkVmVydGljZXMgPSBwb2x5Z29ucztcbiAgICB0aGlzLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgY29uc3QgcG9zaXRpb25zSlMgPSBjYWxjdWxhdGVQb3NpdGlvbnNKUyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcywge1xuICAgICAgcG9zaXRpb25zOiBjYWxjdWxhdGVQb3NpdGlvbnMocG9zaXRpb25zSlMsIHRoaXMuZnA2NCksXG4gICAgICBpbmRpY2VzOiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pLFxuICAgICAgbm9ybWFsczogY2FsY3VsYXRlTm9ybWFscyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIC8vIGNvbG9yczogY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSwgZ2V0Q29sb3J9KSxcbiAgICAgIHBpY2tpbmdDb2xvcnM6IGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSlcbiAgICB9KTtcbiAgfVxuXG4gIGluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5pbmRpY2VzO1xuICB9XG5cbiAgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb25zO1xuICB9XG5cbiAgbm9ybWFscygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbHM7XG4gIH1cblxuICBjb2xvcnMoe2dldENvbG9yID0geCA9PiBERUZBVUxUX0NPTE9SfSA9IHt9KSB7XG4gICAgY29uc3Qge2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSk7XG4gIH1cblxuICBwaWNraW5nQ29sb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucGlja2luZ0NvbG9ycztcbiAgfVxuXG4gIC8vIHVwZGF0ZVRyaWdnZXJzOiB7XG4gIC8vICAgcG9zaXRpb25zOiBbJ2dldEhlaWdodCddLFxuICAvLyAgIGNvbG9yczogWydnZXRDb2xvcnMnXVxuICAvLyAgIHBpY2tpbmdDb2xvcnM6ICdub25lJ1xuICAvLyB9XG59XG5cbmZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGljZXMpIHtcbiAgcmV0dXJuIHZlcnRpY2VzLnJlZHVjZSgodmVydGV4Q291bnQsIHBvbHlnb24pID0+IHZlcnRleENvdW50ICsgY291bnQocG9seWdvbiksIDApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBwb2x5Z29uc1xuICBjb25zdCBtdWx0aXBsaWVyID0gd2lyZWZyYW1lID8gMiA6IDU7XG4gIGNvbnN0IG9mZnNldHMgPSBncm91cGVkVmVydGljZXMucmVkdWNlKFxuICAgIChhY2MsIHZlcnRpY2VzKSA9PlxuICAgICAgYWNjLmNvbmNhdChhY2NbYWNjLmxlbmd0aCAtIDFdICsgY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykgKiBtdWx0aXBsaWVyKSxcbiAgICBbMF1cbiAgKTtcblxuICBjb25zdCBpbmRpY2VzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT5cbiAgICB3aXJlZnJhbWUgP1xuICAgICAgLy8gMS4gZ2V0IHNlcXVlbnRpYWxseSBvcmRlcmVkIGluZGljZXMgb2YgZWFjaCBwb2x5Z29ucyB3aXJlZnJhbWVcbiAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICAgICAgY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldHNbcG9seWdvbkluZGV4XSkgOlxuICAgICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICAgICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldHNbcG9seWdvbkluZGV4XSlcbiAgKTtcblxuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGZsYXR0ZW5EZWVwKGluZGljZXMpKTtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgZmxhdCBwb3NpdGlvbiBhcnJheSBpbiBKUyAtIGNhbiBiZSBtYXBwZWQgdG8gMzIgb3IgNjQgYml0IHR5cGVkIGFycmF5c1xuLy8gUmVtYXJrczpcbi8vICogZWFjaCB0b3AgdmVydGV4IGlzIG9uIDMgc3VyZmFjZXNcbi8vICogZWFjaCBib3R0b20gdmVydGV4IGlzIG9uIDIgc3VyZmFjZXNcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uc0pTKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBwb3NpdGlvbnMgPSBncm91cGVkVmVydGljZXMubWFwKFxuICAgIHZlcnRpY2VzID0+IHtcbiAgICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdmVydGljZXMpO1xuICAgICAgY29uc3QgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKHYgPT4gW2dldCh2LCAwKSwgZ2V0KHYsIDEpLCAwXSk7XG4gICAgICByZXR1cm4gd2lyZWZyYW1lID8gW3RvcFZlcnRpY2VzLCBiYXNlVmVydGljZXNdIDpcbiAgICAgICAgW3RvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXTtcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIGZsYXR0ZW5EZWVwKHBvc2l0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnNKUywgZnA2NCkge1xuICBsZXQgcG9zaXRpb25Mb3c7XG4gIGlmIChmcDY0KSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHgsIHkgY29tcG9uZW50XG4gICAgcG9zaXRpb25Mb3cgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uc0pTLmxlbmd0aCAvIDMgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uc0pTLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAwXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAwXSlbMV07XG4gICAgICBwb3NpdGlvbkxvd1tpICogMiArIDFdID0gZnA2NGlmeShwb3NpdGlvbnNKU1tpICogMyArIDFdKVsxXTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4ge3Bvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnNKUyksIHBvc2l0aW9uczY0eHlMb3c6IHBvc2l0aW9uTG93fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFscyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSB7XG4gIGNvbnN0IHVwID0gWzAsIDEsIDBdO1xuXG4gIGNvbnN0IG5vcm1hbHMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgdG9wTm9ybWFscyA9IG5ldyBBcnJheShjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSkuZmlsbCh1cCk7XG4gICAgY29uc3Qgc2lkZU5vcm1hbHMgPSB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiBjYWxjdWxhdGVTaWRlTm9ybWFscyhwb2x5Z29uKSk7XG4gICAgY29uc3Qgc2lkZU5vcm1hbHNGb3J3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblswXSk7XG4gICAgY29uc3Qgc2lkZU5vcm1hbHNCYWNrd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChuID0+IG5bMV0pO1xuXG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgW3RvcE5vcm1hbHMsIHRvcE5vcm1hbHNdIDpcbiAgICBbdG9wTm9ybWFscywgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmRdO1xuICB9KTtcblxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShmbGF0dGVuRGVlcChub3JtYWxzKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHZlcnRpY2VzKSB7XG4gIGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuICBsZXQgbGFzdFZlcnRpY2UgPSBudWxsO1xuICBmb3IgKGNvbnN0IHZlcnRpY2Ugb2YgdmVydGljZXMpIHtcbiAgICBpZiAobGFzdFZlcnRpY2UpIHtcbiAgICAgIC8vIHZlcnRleFtpLTFdLCB2ZXJ0ZXhbaV1cbiAgICAgIGNvbnN0IG4gPSBnZXROb3JtYWwobGFzdFZlcnRpY2UsIHZlcnRpY2UpO1xuICAgICAgbm9ybWFscy5wdXNoKG4pO1xuICAgIH1cbiAgICBsYXN0VmVydGljZSA9IHZlcnRpY2U7XG4gIH1cblxuICByZXR1cm4gW1tub3JtYWxzLmNvbmNhdChub3JtYWxzWzBdKV0sIFtbbm9ybWFsc1swXV0uY29uY2F0KG5vcm1hbHMpXV07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBnZXRDb2xvciwgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IGNvbG9ycyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBsZXQgY29sb3IgPSBnZXRDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbG9yID0gcGFyc2VDb2xvcihjb2xvcik7XG5cbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IGNvdW50VmVydGljZXMoY29tcGxleFBvbHlnb24pO1xuICAgIGNvbnN0IHRvcENvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgICBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBjb2xvcnMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgICBjb25zdCBjb2xvciA9IGdldFBpY2tpbmdDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbnN0IHRvcENvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgICBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHN0cmlkZSA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IFtvZmZzZXRdO1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyBwb2x5Z29uIHRvcFxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIEdMLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMSwgbi0xLCAwXVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCk7XG5cbiAgICAvLyBwb2x5Z29uIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBzdHJpZGUgKyBvZmZzZXQpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gIGNvbnN0IHF1YWQgPSBbXG4gICAgWzAsIDFdLCBbMCwgM10sIFsxLCAyXSxcbiAgICBbMSwgMl0sIFswLCAzXSwgWzEsIDRdXG4gIF07XG5cbiAgZnVuY3Rpb24gZHJhd1JlY3RhbmdsZShpKSB7XG4gICAgcmV0dXJuIHF1YWQubWFwKHYgPT4gaSArIHZbMF0gKyBzdHJpZGUgKiB2WzFdICsgb2Zmc2V0KTtcbiAgfVxuXG4gIGxldCBob2xlcyA9IG51bGw7XG5cbiAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IHZlcnRpY2VzLnJlZHVjZShcbiAgICAgIChhY2MsIHBvbHlnb24pID0+IGFjYy5jb25jYXQoYWNjW2FjYy5sZW5ndGggLSAxXSArIHBvbHlnb24ubGVuZ3RoKSxcbiAgICAgIFswXVxuICAgICkuc2xpY2UoMSwgdmVydGljZXMubGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IHRvcEluZGljZXMgPSBlYXJjdXQoZmxhdHRlbkRlZXAodmVydGljZXMpLCBob2xlcywgMykubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0KTtcblxuICBjb25zdCBzaWRlSW5kaWNlcyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIC8vIHBvbHlnb24gdG9wXG4gICAgbGV0IGluZGljZXMgPSBbXTtcblxuICAgIC8vIHBvbHlnb24gc2lkZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzID0gaW5kaWNlcy5jb25jYXQoZHJhd1JlY3RhbmdsZShpKSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9KTtcblxuICByZXR1cm4gW3RvcEluZGljZXMsIHNpZGVJbmRpY2VzXTtcbn1cblxuLy8gaGVscGVyc1xuXG4vLyBnZXQgbm9ybWFsIHZlY3RvciBvZiBsaW5lIHNlZ21lbnRcbmZ1bmN0aW9uIGdldE5vcm1hbChwMSwgcDIpIHtcbiAgY29uc3QgcDF4ID0gZ2V0KHAxLCAwKTtcbiAgY29uc3QgcDF5ID0gZ2V0KHAxLCAxKTtcbiAgY29uc3QgcDJ4ID0gZ2V0KHAyLCAwKTtcbiAgY29uc3QgcDJ5ID0gZ2V0KHAyLCAxKTtcblxuICBpZiAocDF4ID09PSBwMnggJiYgcDF5ID09PSBwMnkpIHtcbiAgICByZXR1cm4gWzEsIDAsIDBdO1xuICB9XG5cbiAgY29uc3QgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiAgY29uc3QgbG9uMSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxeDtcbiAgY29uc3QgbG9uMiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyeDtcbiAgY29uc3QgbGF0MSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxeTtcbiAgY29uc3QgbGF0MiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyeTtcbiAgY29uc3QgYSA9IE1hdGguc2luKGxvbjIgLSBsb24xKSAqIE1hdGguY29zKGxhdDIpO1xuICBjb25zdCBiID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIgLSBsb24xKTtcbiAgcmV0dXJuIHZlYzMubm9ybWFsaXplKFtdLCBbYiwgMCwgLWFdKTtcbn1cbiJdfQ==