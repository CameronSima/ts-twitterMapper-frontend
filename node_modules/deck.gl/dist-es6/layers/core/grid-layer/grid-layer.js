var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { CompositeLayer } from '../../../lib';
import GridCellLayer from '../grid-cell-layer/grid-cell-layer';

import { pointToDensityGridData } from './grid-aggregator';
import { linearScale, quantizeScale } from '../../../utils/scale-utils';
import { defaultColorRange } from '../../../utils/color-utils';

import BinSorter from '../../../utils/bin-sorter';

var defaultProps = {
  cellSize: 1000,
  colorRange: defaultColorRange,
  colorDomain: null,
  elevationRange: [0, 1000],
  elevationDomain: null,
  elevationScale: 1,
  lowerPercentile: 0,
  upperPercentile: 100,
  coverage: 1,
  getPosition: function getPosition(x) {
    return x.position;
  },
  getColorValue: function getColorValue(points) {
    return points.length;
  },
  extruded: false,
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

function _needsReProjectPoints(oldProps, props) {
  return oldProps.cellSize !== props.cellSize;
}

function _percentileChanged(oldProps, props) {
  return oldProps.lowerPercentile !== props.lowerPercentile || oldProps.upperPercentile !== props.upperPercentile;
}

function _needsReSortBins(oldProps, props) {
  return oldProps.getColorValue !== props.getColorValue;
}

var GridLayer = function (_CompositeLayer) {
  _inherits(GridLayer, _CompositeLayer);

  function GridLayer() {
    _classCallCheck(this, GridLayer);

    return _possibleConstructorReturn(this, (GridLayer.__proto__ || Object.getPrototypeOf(GridLayer)).apply(this, arguments));
  }

  _createClass(GridLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        layerData: [],
        sortedBins: null,
        valueDomain: null
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {
        // project data into hexagons, and get sortedBins
        this.getLayerData();
        this.getSortedBins();

        // this needs sortedBins to be set
        this.getValueDomain();
      } else if (_needsReSortBins(oldProps, props)) {

        this.getSortedBins();
        this.getValueDomain();
      } else if (_percentileChanged(oldProps, props)) {

        this.getValueDomain();
      }
    }
  }, {
    key: 'getLayerData',
    value: function getLayerData() {
      var _props = this.props,
          data = _props.data,
          cellSize = _props.cellSize,
          getPosition = _props.getPosition;

      var _pointToDensityGridDa = pointToDensityGridData(data, cellSize, getPosition),
          layerData = _pointToDensityGridDa.layerData;

      this.setState({ layerData: layerData });
    }
  }, {
    key: 'getSortedBins',
    value: function getSortedBins() {
      var sortedBins = new BinSorter(this.state.layerData || [], this.props.getColorValue);
      this.setState({ sortedBins: sortedBins });
    }
  }, {
    key: 'getValueDomain',
    value: function getValueDomain() {
      var _props2 = this.props,
          lowerPercentile = _props2.lowerPercentile,
          upperPercentile = _props2.upperPercentile;


      this.state.valueDomain = this.state.sortedBins.getValueRange([lowerPercentile, upperPercentile]);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;

      var pickedCell = info.picked && info.index > -1 ? this.state.layerData[info.index] : null;

      return Object.assign(info, {
        picked: Boolean(pickedCell),
        // override object with picked cell
        object: pickedCell
      });
    }
  }, {
    key: 'getUpdateTriggers',
    value: function getUpdateTriggers() {
      return {
        getColor: {
          colorRange: this.props.colorRange,
          colorDomain: this.props.colorDomain,
          getColorValue: this.props.getColorValue,
          lowerPercentile: this.props.lowerPercentile,
          upperPercentile: this.props.upperPercentile
        },
        getElevation: {
          elevationRange: this.props.elevationRange,
          elevationDomain: this.props.elevationDomain
        }
      };
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var colorRange = this.props.colorRange;
      var _state = this.state,
          valueDomain = _state.valueDomain,
          sortedBins = _state.sortedBins;

      var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;

      var colorDomain = this.props.colorDomain || valueDomain;
      var color = quantizeScale(colorDomain, colorRange, value);

      // if cell value is outside domain, set alpha to 0
      var alpha = value >= valueDomain[0] && value <= valueDomain[1] ? Number.isFinite(color[3]) ? color[3] : 255 : 0;

      // add final alpha to color
      color[3] = alpha;

      return color;
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var _props3 = this.props,
          elevationDomain = _props3.elevationDomain,
          elevationRange = _props3.elevationRange;
      var sortedBins = this.state.sortedBins;

      // elevation is based on counts, it is not affected by percentile

      var domain = elevationDomain || [0, sortedBins.maxCount];
      return linearScale(domain, elevationRange, cell.points.length);
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var _props4 = this.props,
          id = _props4.id,
          elevationScale = _props4.elevationScale,
          fp64 = _props4.fp64,
          extruded = _props4.extruded,
          cellSize = _props4.cellSize,
          coverage = _props4.coverage,
          lightSettings = _props4.lightSettings;

      // base layer props

      var _props5 = this.props,
          opacity = _props5.opacity,
          pickable = _props5.pickable,
          visible = _props5.visible,
          getPolygonOffset = _props5.getPolygonOffset;

      // viewport props

      var _props6 = this.props,
          positionOrigin = _props6.positionOrigin,
          projectionMode = _props6.projectionMode,
          modelMatrix = _props6.modelMatrix;


      return new GridCellLayer({
        id: id + '-grid-cell',
        data: this.state.layerData,
        cellSize: cellSize,
        coverage: coverage,
        lightSettings: lightSettings,
        elevationScale: elevationScale,
        extruded: extruded,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        getPosition: function getPosition(d) {
          return d.position;
        },
        updateTriggers: this.getUpdateTriggers()
      });
    }
  }]);

  return GridLayer;
}(CompositeLayer);

export default GridLayer;


GridLayer.layerName = 'GridLayer';
GridLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJHcmlkQ2VsbExheWVyIiwicG9pbnRUb0RlbnNpdHlHcmlkRGF0YSIsImxpbmVhclNjYWxlIiwicXVhbnRpemVTY2FsZSIsImRlZmF1bHRDb2xvclJhbmdlIiwiQmluU29ydGVyIiwiZGVmYXVsdFByb3BzIiwiY2VsbFNpemUiLCJjb2xvclJhbmdlIiwiY29sb3JEb21haW4iLCJlbGV2YXRpb25SYW5nZSIsImVsZXZhdGlvbkRvbWFpbiIsImVsZXZhdGlvblNjYWxlIiwibG93ZXJQZXJjZW50aWxlIiwidXBwZXJQZXJjZW50aWxlIiwiY292ZXJhZ2UiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsImdldENvbG9yVmFsdWUiLCJwb2ludHMiLCJsZW5ndGgiLCJleHRydWRlZCIsImZwNjQiLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsIl9uZWVkc1JlUHJvamVjdFBvaW50cyIsIm9sZFByb3BzIiwicHJvcHMiLCJfcGVyY2VudGlsZUNoYW5nZWQiLCJfbmVlZHNSZVNvcnRCaW5zIiwiR3JpZExheWVyIiwic3RhdGUiLCJsYXllckRhdGEiLCJzb3J0ZWRCaW5zIiwidmFsdWVEb21haW4iLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwiZ2V0TGF5ZXJEYXRhIiwiZ2V0U29ydGVkQmlucyIsImdldFZhbHVlRG9tYWluIiwiZGF0YSIsInNldFN0YXRlIiwiZ2V0VmFsdWVSYW5nZSIsImluZm8iLCJwaWNrZWRDZWxsIiwicGlja2VkIiwiaW5kZXgiLCJPYmplY3QiLCJhc3NpZ24iLCJCb29sZWFuIiwib2JqZWN0IiwiZ2V0Q29sb3IiLCJnZXRFbGV2YXRpb24iLCJjZWxsIiwidmFsdWUiLCJiaW5NYXAiLCJjb2xvciIsImFscGhhIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJkb21haW4iLCJtYXhDb3VudCIsImlkIiwib3BhY2l0eSIsInBpY2thYmxlIiwidmlzaWJsZSIsImdldFBvbHlnb25PZmZzZXQiLCJwb3NpdGlvbk9yaWdpbiIsInByb2plY3Rpb25Nb2RlIiwibW9kZWxNYXRyaXgiLCJfb25HZXRTdWJsYXllckNvbG9yIiwiYmluZCIsIl9vbkdldFN1YmxheWVyRWxldmF0aW9uIiwiZCIsInVwZGF0ZVRyaWdnZXJzIiwiZ2V0VXBkYXRlVHJpZ2dlcnMiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsY0FBUixRQUE2QixjQUE3QjtBQUNBLE9BQU9DLGFBQVAsTUFBMEIsb0NBQTFCOztBQUVBLFNBQVFDLHNCQUFSLFFBQXFDLG1CQUFyQztBQUNBLFNBQVFDLFdBQVIsRUFBcUJDLGFBQXJCLFFBQXlDLDRCQUF6QztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLDRCQUFoQzs7QUFFQSxPQUFPQyxTQUFQLE1BQXNCLDJCQUF0Qjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CQyxZQUFVLElBRFM7QUFFbkJDLGNBQVlKLGlCQUZPO0FBR25CSyxlQUFhLElBSE07QUFJbkJDLGtCQUFnQixDQUFDLENBQUQsRUFBSSxJQUFKLENBSkc7QUFLbkJDLG1CQUFpQixJQUxFO0FBTW5CQyxrQkFBZ0IsQ0FORztBQU9uQkMsbUJBQWlCLENBUEU7QUFRbkJDLG1CQUFpQixHQVJFO0FBU25CQyxZQUFVLENBVFM7QUFVbkJDLGVBQWE7QUFBQSxXQUFLQyxFQUFFQyxRQUFQO0FBQUEsR0FWTTtBQVduQkMsaUJBQWU7QUFBQSxXQUFVQyxPQUFPQyxNQUFqQjtBQUFBLEdBWEk7QUFZ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QkMsZ0JBSnRCLFdBSXNCQSxnQkFKdEI7O0FBTWI7O0FBTmEsb0JBT3lDLEtBQUt2QyxLQVA5QztBQUFBLFVBT053QyxjQVBNLFdBT05BLGNBUE07QUFBQSxVQU9VQyxjQVBWLFdBT1VBLGNBUFY7QUFBQSxVQU8wQkMsV0FQMUIsV0FPMEJBLFdBUDFCOzs7QUFTYixhQUFPLElBQUkzRSxhQUFKLENBQWtCO0FBQ3ZCb0UsWUFBT0EsRUFBUCxlQUR1QjtBQUV2QnRCLGNBQU0sS0FBS1QsS0FBTCxDQUFXQyxTQUZNO0FBR3ZCL0IsMEJBSHVCO0FBSXZCUSwwQkFKdUI7QUFLdkJTLG9DQUx1QjtBQU12Qlosc0NBTnVCO0FBT3ZCVSwwQkFQdUI7QUFRdkJDLGtCQVJ1QjtBQVN2QjhDLHdCQVR1QjtBQVV2QkMsMEJBVnVCO0FBV3ZCQyx3QkFYdUI7QUFZdkJDLDBDQVp1QjtBQWF2QkUsc0NBYnVCO0FBY3ZCRCxzQ0FkdUI7QUFldkJFLGdDQWZ1QjtBQWdCdkJsQixrQkFBVSxLQUFLbUIsbUJBQUwsQ0FBeUJDLElBQXpCLENBQThCLElBQTlCLENBaEJhO0FBaUJ2Qm5CLHNCQUFjLEtBQUtvQix1QkFBTCxDQUE2QkQsSUFBN0IsQ0FBa0MsSUFBbEMsQ0FqQlM7QUFrQnZCN0QscUJBQWE7QUFBQSxpQkFBSytELEVBQUU3RCxRQUFQO0FBQUEsU0FsQlU7QUFtQnZCOEQsd0JBQWdCLEtBQUtDLGlCQUFMO0FBbkJPLE9BQWxCLENBQVA7QUFxQkQ7Ozs7RUFuSW9DbEYsYzs7ZUFBbEJxQyxTOzs7QUFzSXJCQSxVQUFVOEMsU0FBVixHQUFzQixXQUF0QjtBQUNBOUMsVUFBVTlCLFlBQVYsR0FBeUJBLFlBQXpCIiwiZmlsZSI6ImdyaWQtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCBHcmlkQ2VsbExheWVyIGZyb20gJy4uL2dyaWQtY2VsbC1sYXllci9ncmlkLWNlbGwtbGF5ZXInO1xuXG5pbXBvcnQge3BvaW50VG9EZW5zaXR5R3JpZERhdGF9IGZyb20gJy4vZ3JpZC1hZ2dyZWdhdG9yJztcbmltcG9ydCB7bGluZWFyU2NhbGUsIHF1YW50aXplU2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3NjYWxlLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdENvbG9yUmFuZ2V9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yLXV0aWxzJztcblxuaW1wb3J0IEJpblNvcnRlciBmcm9tICcuLi8uLi8uLi91dGlscy9iaW4tc29ydGVyJztcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjZWxsU2l6ZTogMTAwMCxcbiAgY29sb3JSYW5nZTogZGVmYXVsdENvbG9yUmFuZ2UsXG4gIGNvbG9yRG9tYWluOiBudWxsLFxuICBlbGV2YXRpb25SYW5nZTogWzAsIDEwMDBdLFxuICBlbGV2YXRpb25Eb21haW46IG51bGwsXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICBsb3dlclBlcmNlbnRpbGU6IDAsXG4gIHVwcGVyUGVyY2VudGlsZTogMTAwLFxuICBjb3ZlcmFnZTogMSxcbiAgZ2V0UG9zaXRpb246IHggPT4geC5wb3NpdGlvbixcbiAgZ2V0Q29sb3JWYWx1ZTogcG9pbnRzID0+IHBvaW50cy5sZW5ndGgsXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLmNlbGxTaXplICE9PSBwcm9wcy5jZWxsU2l6ZTtcbn1cblxuZnVuY3Rpb24gX3BlcmNlbnRpbGVDaGFuZ2VkKG9sZFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gb2xkUHJvcHMubG93ZXJQZXJjZW50aWxlICE9PSBwcm9wcy5sb3dlclBlcmNlbnRpbGUgfHxcbiAgICBvbGRQcm9wcy51cHBlclBlcmNlbnRpbGUgIT09IHByb3BzLnVwcGVyUGVyY2VudGlsZTtcbn1cblxuZnVuY3Rpb24gX25lZWRzUmVTb3J0QmlucyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLmdldENvbG9yVmFsdWUgIT09IHByb3BzLmdldENvbG9yVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRMYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsYXllckRhdGE6IFtdLFxuICAgICAgc29ydGVkQmluczogbnVsbCxcbiAgICAgIHZhbHVlRG9tYWluOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSkge1xuICAgICAgLy8gcHJvamVjdCBkYXRhIGludG8gaGV4YWdvbnMsIGFuZCBnZXQgc29ydGVkQmluc1xuICAgICAgdGhpcy5nZXRMYXllckRhdGEoKTtcbiAgICAgIHRoaXMuZ2V0U29ydGVkQmlucygpO1xuXG4gICAgICAvLyB0aGlzIG5lZWRzIHNvcnRlZEJpbnMgdG8gYmUgc2V0XG4gICAgICB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG4gICAgfSBlbHNlIGlmIChfbmVlZHNSZVNvcnRCaW5zKG9sZFByb3BzLCBwcm9wcykpIHtcblxuICAgICAgdGhpcy5nZXRTb3J0ZWRCaW5zKCk7XG4gICAgICB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG5cbiAgICB9IGVsc2UgaWYgKF9wZXJjZW50aWxlQ2hhbmdlZChvbGRQcm9wcywgcHJvcHMpKSB7XG5cbiAgICAgIHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICB9XG4gIH1cblxuICBnZXRMYXllckRhdGEoKSB7XG4gICAgY29uc3Qge2RhdGEsIGNlbGxTaXplLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtsYXllckRhdGF9ID0gcG9pbnRUb0RlbnNpdHlHcmlkRGF0YShkYXRhLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7bGF5ZXJEYXRhfSk7XG4gIH1cblxuICBnZXRTb3J0ZWRCaW5zKCkge1xuICAgIGNvbnN0IHNvcnRlZEJpbnMgPSBuZXcgQmluU29ydGVyKHRoaXMuc3RhdGUubGF5ZXJEYXRhIHx8IFtdLCB0aGlzLnByb3BzLmdldENvbG9yVmFsdWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoe3NvcnRlZEJpbnN9KTtcbiAgfVxuXG4gIGdldFZhbHVlRG9tYWluKCkge1xuICAgIGNvbnN0IHtsb3dlclBlcmNlbnRpbGUsIHVwcGVyUGVyY2VudGlsZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zdGF0ZS52YWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuc29ydGVkQmluc1xuICAgICAgLmdldFZhbHVlUmFuZ2UoW2xvd2VyUGVyY2VudGlsZSwgdXBwZXJQZXJjZW50aWxlXSk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyh7aW5mb30pIHtcbiAgICBjb25zdCBwaWNrZWRDZWxsID0gaW5mby5waWNrZWQgJiYgaW5mby5pbmRleCA+IC0xID9cbiAgICAgIHRoaXMuc3RhdGUubGF5ZXJEYXRhW2luZm8uaW5kZXhdIDogbnVsbDtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIHBpY2tlZDogQm9vbGVhbihwaWNrZWRDZWxsKSxcbiAgICAgIC8vIG92ZXJyaWRlIG9iamVjdCB3aXRoIHBpY2tlZCBjZWxsXG4gICAgICBvYmplY3Q6IHBpY2tlZENlbGxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFVwZGF0ZVRyaWdnZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb2xvcjoge1xuICAgICAgICBjb2xvclJhbmdlOiB0aGlzLnByb3BzLmNvbG9yUmFuZ2UsXG4gICAgICAgIGNvbG9yRG9tYWluOiB0aGlzLnByb3BzLmNvbG9yRG9tYWluLFxuICAgICAgICBnZXRDb2xvclZhbHVlOiB0aGlzLnByb3BzLmdldENvbG9yVmFsdWUsXG4gICAgICAgIGxvd2VyUGVyY2VudGlsZTogdGhpcy5wcm9wcy5sb3dlclBlcmNlbnRpbGUsXG4gICAgICAgIHVwcGVyUGVyY2VudGlsZTogdGhpcy5wcm9wcy51cHBlclBlcmNlbnRpbGVcbiAgICAgIH0sXG4gICAgICBnZXRFbGV2YXRpb246IHtcbiAgICAgICAgZWxldmF0aW9uUmFuZ2U6IHRoaXMucHJvcHMuZWxldmF0aW9uUmFuZ2UsXG4gICAgICAgIGVsZXZhdGlvbkRvbWFpbjogdGhpcy5wcm9wcy5lbGV2YXRpb25Eb21haW5cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgY29uc3Qge2NvbG9yUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWVEb21haW4sIHNvcnRlZEJpbnN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmIHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuXG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHZhbHVlRG9tYWluO1xuICAgIGNvbnN0IGNvbG9yID0gcXVhbnRpemVTY2FsZShjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgdmFsdWUpO1xuXG4gICAgLy8gaWYgY2VsbCB2YWx1ZSBpcyBvdXRzaWRlIGRvbWFpbiwgc2V0IGFscGhhIHRvIDBcbiAgICBjb25zdCBhbHBoYSA9IHZhbHVlID49IHZhbHVlRG9tYWluWzBdICYmIHZhbHVlIDw9IHZhbHVlRG9tYWluWzFdID9cbiAgICAgIChOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTUpIDogMDtcblxuICAgIC8vIGFkZCBmaW5hbCBhbHBoYSB0byBjb2xvclxuICAgIGNvbG9yWzNdID0gYWxwaGE7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckVsZXZhdGlvbihjZWxsKSB7XG4gICAgY29uc3Qge2VsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7c29ydGVkQmluc30gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gZWxldmF0aW9uIGlzIGJhc2VkIG9uIGNvdW50cywgaXQgaXMgbm90IGFmZmVjdGVkIGJ5IHBlcmNlbnRpbGVcbiAgICBjb25zdCBkb21haW4gPSBlbGV2YXRpb25Eb21haW4gfHwgWzAsIHNvcnRlZEJpbnMubWF4Q291bnRdO1xuICAgIHJldHVybiBsaW5lYXJTY2FsZShkb21haW4sIGVsZXZhdGlvblJhbmdlLCBjZWxsLnBvaW50cy5sZW5ndGgpO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtpZCwgZWxldmF0aW9uU2NhbGUsIGZwNjQsIGV4dHJ1ZGVkLCBjZWxsU2l6ZSwgY292ZXJhZ2UsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIGJhc2UgbGF5ZXIgcHJvcHNcbiAgICBjb25zdCB7b3BhY2l0eSwgcGlja2FibGUsIHZpc2libGUsIGdldFBvbHlnb25PZmZzZXR9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIHZpZXdwb3J0IHByb3BzXG4gICAgY29uc3Qge3Bvc2l0aW9uT3JpZ2luLCBwcm9qZWN0aW9uTW9kZSwgbW9kZWxNYXRyaXh9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBuZXcgR3JpZENlbGxMYXllcih7XG4gICAgICBpZDogYCR7aWR9LWdyaWQtY2VsbGAsXG4gICAgICBkYXRhOiB0aGlzLnN0YXRlLmxheWVyRGF0YSxcbiAgICAgIGNlbGxTaXplLFxuICAgICAgY292ZXJhZ2UsXG4gICAgICBsaWdodFNldHRpbmdzLFxuICAgICAgZWxldmF0aW9uU2NhbGUsXG4gICAgICBleHRydWRlZCxcbiAgICAgIGZwNjQsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGlja2FibGUsXG4gICAgICB2aXNpYmxlLFxuICAgICAgZ2V0UG9seWdvbk9mZnNldCxcbiAgICAgIHByb2plY3Rpb25Nb2RlLFxuICAgICAgcG9zaXRpb25PcmlnaW4sXG4gICAgICBtb2RlbE1hdHJpeCxcbiAgICAgIGdldENvbG9yOiB0aGlzLl9vbkdldFN1YmxheWVyQ29sb3IuYmluZCh0aGlzKSxcbiAgICAgIGdldEVsZXZhdGlvbjogdGhpcy5fb25HZXRTdWJsYXllckVsZXZhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZ2V0UG9zaXRpb246IGQgPT4gZC5wb3NpdGlvbixcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB0aGlzLmdldFVwZGF0ZVRyaWdnZXJzKClcbiAgICB9KTtcbiAgfVxufVxuXG5HcmlkTGF5ZXIubGF5ZXJOYW1lID0gJ0dyaWRMYXllcic7XG5HcmlkTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19