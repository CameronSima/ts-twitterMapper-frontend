var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup'];
var MOVE_EVENT_TYPES = ['mousemove', 'pointermove'];

/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */

var MoveInput = function () {
  function MoveInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, MoveInput);

    this.element = element;
    this.callback = callback;
    this.pressed = false;

    var events = MOUSE_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(MoveInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'enableIfEventSupported',
    value: function enableIfEventSupported(eventType) {
      if (MOVE_EVENT_TYPES.indexOf(eventType) >= 0) {
        this.options.enable = true;
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      var _this3 = this;

      if (!this.options.enable) {
        return;
      }

      switch (event.type) {
        case 'mousedown':
          if (event.button === 0) {
            // Left button is down
            this.pressed = true;
          }
          break;
        case 'mousemove':
          // Move events use `which` to track the button being pressed
          if (event.which !== 1) {
            // Left button is not down
            this.pressed = false;
          }
          if (!this.pressed) {
            // Drag events are emitted by hammer already
            // we just need to emit the move event on hover
            MOVE_EVENT_TYPES.forEach(function (type) {
              return _this3.callback({
                type: type,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
              });
            });
          }
          break;
        case 'mouseup':
          this.pressed = false;
          break;
        default:
      }
    }
  }]);

  return MoveInput;
}();

export default MoveInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvbW92ZS1pbnB1dC5qcyJdLCJuYW1lcyI6WyJNT1VTRV9FVkVOVFMiLCJNT1ZFX0VWRU5UX1RZUEVTIiwiTW92ZUlucHV0IiwiZWxlbWVudCIsImNhbGxiYWNrIiwib3B0aW9ucyIsInByZXNzZWQiLCJldmVudHMiLCJjb25jYXQiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmFibGUiLCJoYW5kbGVFdmVudCIsImJpbmQiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50VHlwZSIsImluZGV4T2YiLCJ0eXBlIiwiYnV0dG9uIiwid2hpY2giLCJzcmNFdmVudCIsInBvaW50ZXJUeXBlIiwidGFyZ2V0Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBTUEsZUFBZSxDQUFDLFdBQUQsRUFBYyxXQUFkLEVBQTJCLFNBQTNCLENBQXJCO0FBQ0EsSUFBTUMsbUJBQW1CLENBQUMsV0FBRCxFQUFjLGFBQWQsQ0FBekI7O0FBRUE7Ozs7Ozs7OztJQVFxQkMsUztBQUVuQixxQkFBWUMsT0FBWixFQUFxQkMsUUFBckIsRUFBNkM7QUFBQTs7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQzNDLFNBQUtGLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0UsT0FBTCxHQUFlLEtBQWY7O0FBRUEsUUFBTUMsU0FBU1AsYUFBYVEsTUFBYixDQUFvQkgsUUFBUUUsTUFBUixJQUFrQixFQUF0QyxDQUFmO0FBQ0EsU0FBS0YsT0FBTCxHQUFlSSxPQUFPQyxNQUFQLENBQWMsRUFBQ0MsUUFBUSxJQUFULEVBQWQsRUFBOEJOLE9BQTlCLEVBQXVDLEVBQUNFLGNBQUQsRUFBdkMsQ0FBZjs7QUFFQSxTQUFLSyxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJDLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0EsU0FBS1IsT0FBTCxDQUFhRSxNQUFiLENBQW9CTyxPQUFwQixDQUE0QjtBQUFBLGFBQVNYLFFBQVFZLGdCQUFSLENBQXlCQyxLQUF6QixFQUFnQyxNQUFLSixXQUFyQyxDQUFUO0FBQUEsS0FBNUI7QUFDRDs7Ozs4QkFFUztBQUFBOztBQUNSLFdBQUtQLE9BQUwsQ0FBYUUsTUFBYixDQUFvQk8sT0FBcEIsQ0FBNEI7QUFBQSxlQUFTLE9BQUtYLE9BQUwsQ0FBYWMsbUJBQWIsQ0FBaUNELEtBQWpDLEVBQXdDLE9BQUtKLFdBQTdDLENBQVQ7QUFBQSxPQUE1QjtBQUNEOzs7d0JBRUdQLE8sRUFBUztBQUNYSSxhQUFPQyxNQUFQLENBQWMsS0FBS0wsT0FBbkIsRUFBNEJBLE9BQTVCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7MkNBSXVCYSxTLEVBQVc7QUFDaEMsVUFBSWpCLGlCQUFpQmtCLE9BQWpCLENBQXlCRCxTQUF6QixLQUF1QyxDQUEzQyxFQUE4QztBQUM1QyxhQUFLYixPQUFMLENBQWFNLE1BQWIsR0FBc0IsSUFBdEI7QUFDRDtBQUNGOzs7Z0NBRVdLLEssRUFBTztBQUFBOztBQUNqQixVQUFJLENBQUMsS0FBS1gsT0FBTCxDQUFhTSxNQUFsQixFQUEwQjtBQUN4QjtBQUNEOztBQUVELGNBQVFLLE1BQU1JLElBQWQ7QUFDQSxhQUFLLFdBQUw7QUFDRSxjQUFJSixNQUFNSyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCO0FBQ0EsaUJBQUtmLE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRDtBQUNGLGFBQUssV0FBTDtBQUNFO0FBQ0EsY0FBSVUsTUFBTU0sS0FBTixLQUFnQixDQUFwQixFQUF1QjtBQUNyQjtBQUNBLGlCQUFLaEIsT0FBTCxHQUFlLEtBQWY7QUFDRDtBQUNELGNBQUksQ0FBQyxLQUFLQSxPQUFWLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQUwsNkJBQWlCYSxPQUFqQixDQUF5QjtBQUFBLHFCQUFRLE9BQUtWLFFBQUwsQ0FBYztBQUM3Q2dCLDBCQUQ2QztBQUU3Q0csMEJBQVVQLEtBRm1DO0FBRzdDUSw2QkFBYSxPQUhnQztBQUk3Q0Msd0JBQVFULE1BQU1TO0FBSitCLGVBQWQsQ0FBUjtBQUFBLGFBQXpCO0FBTUQ7QUFDRDtBQUNGLGFBQUssU0FBTDtBQUNFLGVBQUtuQixPQUFMLEdBQWUsS0FBZjtBQUNBO0FBQ0Y7QUEzQkE7QUE2QkQ7Ozs7OztlQWxFa0JKLFMiLCJmaWxlIjoibW92ZS1pbnB1dC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1PVVNFX0VWRU5UUyA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJ107XG5jb25zdCBNT1ZFX0VWRU5UX1RZUEVTID0gWydtb3VzZW1vdmUnLCAncG9pbnRlcm1vdmUnXTtcblxuLyoqXG4gKiBIYW1tZXIuanMgc3dhbGxvd3MgJ21vdmUnIGV2ZW50cyAoZm9yIHBvaW50ZXIvdG91Y2gvbW91c2UpXG4gKiB3aGVuIHRoZSBwb2ludGVyIGlzIG5vdCBkb3duLiBUaGlzIGNsYXNzIHNldHMgdXAgYSBoYW5kbGVyXG4gKiBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIGV2ZW50cyB0byB3b3JrIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3VsZCBiZSBleHRlbmRlZCB0byBtb3JlIGludGVsbGlnZW50bHkgaGFuZGxlXG4gKiBtb3ZlIGV2ZW50cyBhY3Jvc3MgaW5wdXQgdHlwZXMsIGUuZy4gc3RvcmluZyBtdWx0aXBsZSBzaW11bHRhbmVvdXNcbiAqIHBvaW50ZXIvdG91Y2ggZXZlbnRzLCBjYWxjdWxhdGluZyBzcGVlZC9kaXJlY3Rpb24sIGV0Yy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92ZUlucHV0IHtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG5cbiAgICBjb25zdCBldmVudHMgPSBNT1VTRV9FVkVOVFMuY29uY2F0KG9wdGlvbnMuZXZlbnRzIHx8IFtdKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtlbmFibGU6IHRydWV9LCBvcHRpb25zLCB7ZXZlbnRzfSk7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucy5ldmVudHMuZm9yRWFjaChldmVudCA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBzZXQob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVJZkV2ZW50U3VwcG9ydGVkKGV2ZW50VHlwZSkge1xuICAgIGlmIChNT1ZFX0VWRU5UX1RZUEVTLmluZGV4T2YoZXZlbnRUeXBlKSA+PSAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIC8vIExlZnQgYnV0dG9uIGlzIGRvd25cbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAvLyBNb3ZlIGV2ZW50cyB1c2UgYHdoaWNoYCB0byB0cmFjayB0aGUgYnV0dG9uIGJlaW5nIHByZXNzZWRcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gMSkge1xuICAgICAgICAvLyBMZWZ0IGJ1dHRvbiBpcyBub3QgZG93blxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIC8vIERyYWcgZXZlbnRzIGFyZSBlbWl0dGVkIGJ5IGhhbW1lciBhbHJlYWR5XG4gICAgICAgIC8vIHdlIGp1c3QgbmVlZCB0byBlbWl0IHRoZSBtb3ZlIGV2ZW50IG9uIGhvdmVyXG4gICAgICAgIE1PVkVfRVZFTlRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxufVxuIl19