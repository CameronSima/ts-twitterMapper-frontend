var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Portions of the code below originally from:
// https://github.com/mapbox/mapbox-gl-js/blob/master/js/ui/handler/scroll_zoom.js

import { window, document } from './globals';

function noop() {}

var ua = typeof window.navigator !== 'undefined' ? window.navigator.userAgent.toLowerCase() : '';
var firefox = ua.indexOf('firefox') !== -1;

// Extract a position from a mouse event
function getMousePosition(el, event) {
  var rect = el.getBoundingClientRect();
  event = event.touches ? event.touches[0] : event;
  return [event.clientX - rect.left - el.clientLeft, event.clientY - rect.top - el.clientTop];
}

// Extract an array of touch positions from a touch event
function getTouchPositions(el, event) {
  var points = [];
  var rect = el.getBoundingClientRect();
  for (var i = 0; i < event.touches.length; i++) {
    points.push([event.touches[i].clientX - rect.left - el.clientLeft, event.touches[i].clientY - rect.top - el.clientTop]);
  }
  return points;
}

// Return the centroid of an array of points
function centroid(positions) {
  var sum = positions.reduce(function (acc, elt) {
    return [acc[0] + elt[0], acc[1] + elt[1]];
  }, [0, 0]);
  return [sum[0] / positions.length, sum[1] / positions.length];
}

var EventManager = function () {
  function EventManager(canvas) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$onMouseMove = _ref.onMouseMove,
        onMouseMove = _ref$onMouseMove === undefined ? noop : _ref$onMouseMove,
        _ref$onMouseClick = _ref.onMouseClick,
        onMouseClick = _ref$onMouseClick === undefined ? noop : _ref$onMouseClick,
        _ref$onMouseDown = _ref.onMouseDown,
        onMouseDown = _ref$onMouseDown === undefined ? noop : _ref$onMouseDown,
        _ref$onMouseUp = _ref.onMouseUp,
        onMouseUp = _ref$onMouseUp === undefined ? noop : _ref$onMouseUp,
        _ref$onMouseRotate = _ref.onMouseRotate,
        onMouseRotate = _ref$onMouseRotate === undefined ? noop : _ref$onMouseRotate,
        _ref$onMouseDrag = _ref.onMouseDrag,
        onMouseDrag = _ref$onMouseDrag === undefined ? noop : _ref$onMouseDrag,
        _ref$onTouchStart = _ref.onTouchStart,
        onTouchStart = _ref$onTouchStart === undefined ? noop : _ref$onTouchStart,
        _ref$onTouchRotate = _ref.onTouchRotate,
        onTouchRotate = _ref$onTouchRotate === undefined ? noop : _ref$onTouchRotate,
        _ref$onTouchDrag = _ref.onTouchDrag,
        onTouchDrag = _ref$onTouchDrag === undefined ? noop : _ref$onTouchDrag,
        _ref$onTouchEnd = _ref.onTouchEnd,
        onTouchEnd = _ref$onTouchEnd === undefined ? noop : _ref$onTouchEnd,
        _ref$onTouchTap = _ref.onTouchTap,
        onTouchTap = _ref$onTouchTap === undefined ? noop : _ref$onTouchTap,
        _ref$onZoom = _ref.onZoom,
        onZoom = _ref$onZoom === undefined ? noop : _ref$onZoom,
        _ref$onZoomEnd = _ref.onZoomEnd,
        onZoomEnd = _ref$onZoomEnd === undefined ? noop : _ref$onZoomEnd,
        _ref$mapTouchToMouse = _ref.mapTouchToMouse,
        mapTouchToMouse = _ref$mapTouchToMouse === undefined ? true : _ref$mapTouchToMouse,
        _ref$pressKeyToRotate = _ref.pressKeyToRotate,
        pressKeyToRotate = _ref$pressKeyToRotate === undefined ? false : _ref$pressKeyToRotate;

    _classCallCheck(this, EventManager);

    // Install default touch handlers if requested (forwards touch to mouse)
    onTouchStart = onTouchStart || mapTouchToMouse && onMouseDown;
    onTouchDrag = onTouchDrag || mapTouchToMouse && onMouseDrag;
    onTouchRotate = onTouchRotate || mapTouchToMouse && onMouseRotate;
    onTouchEnd = onTouchEnd || mapTouchToMouse && onMouseUp;
    onTouchTap = onTouchTap || mapTouchToMouse && onMouseClick;

    this._canvas = canvas;

    // Public member: can be changed by app
    this.pressKeyToRotate = pressKeyToRotate;

    // Private state
    this.state = {
      didDrag: false,
      isFunctionKeyPressed: false,
      startPos: null,
      pos: null,
      mouseWheelPos: null
    };

    this.callbacks = {
      onMouseMove: onMouseMove,
      onMouseClick: onMouseClick,
      onMouseDown: onMouseDown,
      onMouseUp: onMouseUp,
      onTouchStart: onTouchStart,
      onMouseRotate: onMouseRotate,
      onMouseDrag: onMouseDrag,
      onTouchRotate: onTouchRotate,
      onTouchDrag: onTouchDrag,
      onTouchEnd: onTouchEnd,
      onTouchTap: onTouchTap,
      onZoom: onZoom,
      onZoomEnd: onZoomEnd
    };

    this._addEventListeners();
  }

  // Register any outstanding event listeners


  _createClass(EventManager, [{
    key: '_addEventListeners',
    value: function _addEventListeners() {
      this._canvas.addEventListener('mousemove', this._onMouseMove.bind(this));
      this._canvas.addEventListener('mousedown', this._onMouseDown.bind(this));
      this._canvas.addEventListener('mouseup', this._onMouseUp.bind(this));
      this._canvas.addEventListener('touchstart', this._onTouchStart.bind(this));
      this._canvas.addEventListener('contextmenu', this._onMouseDown.bind(this));
      this._canvas.addEventListener('mousewheel', this._onWheel.bind(this));
    }
  }, {
    key: 'setState',
    value: function setState(settings) {
      Object.assign(this.state, settings);
    }
  }, {
    key: '_getMousePos',
    value: function _getMousePos(event) {
      var el = this._canvas;
      return getMousePosition(el, event);
    }
  }, {
    key: '_getTouchPos',
    value: function _getTouchPos(event) {
      var el = this._canvas;
      var positions = getTouchPositions(el, event);
      return centroid(positions);
    }
  }, {
    key: '_isFunctionKeyPressed',
    value: function _isFunctionKeyPressed(event) {
      return Boolean(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(event) {
      var pos = this._getMousePos(event);
      this.setState({
        didDrag: false,
        startPos: pos,
        pos: pos,
        isFunctionKeyPressed: this._isFunctionKeyPressed(event)
      });
      this.callbacks.onMouseDown({ pos: pos });
      document.addEventListener('mousemove', this._onMouseDrag.bind(this), false);
      document.addEventListener('mouseup', this._onMouseUp.bind(this), false);
    }
  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(event) {
      var pos = this._getTouchPos(event);
      this.setState({
        didDrag: false,
        startPos: pos,
        pos: pos,
        isFunctionKeyPressed: this._isFunctionKeyPressed(event)
      });
      this.callbacks.onTouchStart({ pos: pos });
      document.addEventListener('touchmove', this._onTouchDrag.bind(this), false);
      document.addEventListener('touchend', this._onTouchEnd.bind(this), false);
    }
  }, {
    key: '_onMouseDrag',
    value: function _onMouseDrag(event) {
      var pos = this._getMousePos(event);
      this.setState({ pos: pos, didDrag: true });
      var startPos = this.state.startPos;
      var isFunctionKeyPressed = this.state.isFunctionKeyPressed;

      var rotate = this.pressKeyToRotate ? isFunctionKeyPressed : !isFunctionKeyPressed;

      if (rotate) {
        this.callbacks.onMouseRotate({ pos: pos, startPos: startPos });
      } else {
        this.callbacks.onMouseDrag({ pos: pos, startPos: startPos });
      }
    }
  }, {
    key: '_onTouchDrag',
    value: function _onTouchDrag(event) {
      var pos = this._getTouchPos(event);
      this.setState({ pos: pos, didDrag: true });

      var isFunctionKeyPressed = this.state.isFunctionKeyPressed;

      var rotate = this.pressKeyToRotate ? isFunctionKeyPressed : !isFunctionKeyPressed;

      if (rotate) {
        var startPos = this.state.startPos;

        this.callbacks.onTouchRotate({ pos: pos, startPos: startPos });
      } else {
        this.callbacks.onTouchDrag({ pos: pos });
      }
      event.preventDefault();
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(event) {
      document.removeEventListener('mousemove', this._onMouseDrag, false);
      document.removeEventListener('mouseup', this._onMouseUp, false);
      var pos = this._getMousePos(event);
      this.setState({ pos: pos });
      this.callbacks.onMouseUp({ pos: pos });
      if (!this.state.didDrag) {
        this.callbacks.onMouseClick({ pos: pos });
      }
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(event) {
      document.removeEventListener('touchmove', this._onTouchDrag, false);
      document.removeEventListener('touchend', this._onTouchEnd, false);
      var pos = this._getTouchPos(event);
      this.setState({ pos: pos });
      this.callbacks.onTouchEnd({ pos: pos });
      if (!this.state.didDrag) {
        this.callbacks.onTouchTap({ pos: pos });
      }
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      var pos = this._getMousePos(event);
      this.callbacks.onMouseMove({ pos: pos });
    }

    /* eslint-disable complexity, max-statements */

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      event.preventDefault();
      var value = event.deltaY;
      // Firefox doubles the values on retina screens...
      if (firefox && event.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) {
        value /= window.devicePixelRatio;
      }
      if (event.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {
        value *= 40;
      }

      var type = this.state.mouseWheelType;
      var timeout = this.state.mouseWheelTimeout;
      var lastValue = this.state.mouseWheelLastValue;
      var time = this.state.mouseWheelTime;

      var now = (window.performance || Date).now();
      var timeDelta = now - (time || 0);

      var pos = this._getMousePos(event);
      time = now;

      if (value !== 0 && value % 4.000244140625 === 0) {
        // This one is definitely a mouse wheel event.
        type = 'wheel';
        // Normalize this value to match trackpad.
        value = Math.floor(value / 4);
      } else if (value !== 0 && Math.abs(value) < 4) {
        // This one is definitely a trackpad event because it is so small.
        type = 'trackpad';
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        type = null;
        lastValue = value;
        // Start a timeout in case this was a singular event, and delay it by up
        // to 40ms.
        timeout = window.setTimeout(function setTimeout() {
          var _type = 'wheel';
          this._zoom(-this.state.mouseWheelLastValue, this.state.mouseWheelPos);
          this.setState({ mouseWheelType: _type });
        }.bind(this), 40);
      } else if (!this._type) {
        // This is a repeating event, but we don't know the type of event just
        // yet.
        // If the delta per time is small, we assume it's a fast trackpad;
        // otherwise we switch into wheel mode.
        type = Math.abs(timeDelta * value) < 200 ? 'trackpad' : 'wheel';

        // Make sure our delayed event isn't fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (timeout) {
          window.clearTimeout(timeout);
          timeout = null;
          value += lastValue;
        }
      }

      // Slow down zoom if shift key is held for more precise zooming
      if (event.shiftKey && value) {
        value = value / 4;
      }

      // Only fire the callback if we actually know what type of scrolling device
      // the user uses.
      if (type) {
        this._zoom(-value, pos);
      }

      this.setState({
        mouseWheelTime: time,
        mouseWheelPos: pos,
        mouseWheelType: type,
        mouseWheelTimeout: timeout,
        mouseWheelLastValue: lastValue
      });
    }
    /* eslint-enable complexity, max-statements */

  }, {
    key: '_zoom',
    value: function _zoom(delta, pos) {
      // Scale by sigmoid of scroll wheel delta.
      var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }
      this.callbacks.onZoom({ pos: pos, delta: delta, scale: scale });
      window.clearTimeout(this._zoomEndTimeout);
      this._zoomEndTimeout = window.setTimeout(function _setTimeout() {
        this.callbacks.onZoomEnd();
      }.bind(this), 200);
    }
  }]);

  return EventManager;
}();

export default EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cm9sbGVycy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIndpbmRvdyIsImRvY3VtZW50Iiwibm9vcCIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJmaXJlZm94IiwiaW5kZXhPZiIsImdldE1vdXNlUG9zaXRpb24iLCJlbCIsImV2ZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvdWNoZXMiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudExlZnQiLCJjbGllbnRZIiwidG9wIiwiY2xpZW50VG9wIiwiZ2V0VG91Y2hQb3NpdGlvbnMiLCJwb2ludHMiLCJpIiwibGVuZ3RoIiwicHVzaCIsImNlbnRyb2lkIiwicG9zaXRpb25zIiwic3VtIiwicmVkdWNlIiwiYWNjIiwiZWx0IiwiRXZlbnRNYW5hZ2VyIiwiY2FudmFzIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlQ2xpY2siLCJvbk1vdXNlRG93biIsIm9uTW91c2VVcCIsIm9uTW91c2VSb3RhdGUiLCJvbk1vdXNlRHJhZyIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hSb3RhdGUiLCJvblRvdWNoRHJhZyIsIm9uVG91Y2hFbmQiLCJvblRvdWNoVGFwIiwib25ab29tIiwib25ab29tRW5kIiwibWFwVG91Y2hUb01vdXNlIiwicHJlc3NLZXlUb1JvdGF0ZSIsIl9jYW52YXMiLCJzdGF0ZSIsImRpZERyYWciLCJpc0Z1bmN0aW9uS2V5UHJlc3NlZCIsInN0YXJ0UG9zIiwicG9zIiwibW91c2VXaGVlbFBvcyIsImNhbGxiYWNrcyIsIl9hZGRFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Nb3VzZU1vdmUiLCJiaW5kIiwiX29uTW91c2VEb3duIiwiX29uTW91c2VVcCIsIl9vblRvdWNoU3RhcnQiLCJfb25XaGVlbCIsInNldHRpbmdzIiwiT2JqZWN0IiwiYXNzaWduIiwiQm9vbGVhbiIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJfZ2V0TW91c2VQb3MiLCJzZXRTdGF0ZSIsIl9pc0Z1bmN0aW9uS2V5UHJlc3NlZCIsIl9vbk1vdXNlRHJhZyIsIl9nZXRUb3VjaFBvcyIsIl9vblRvdWNoRHJhZyIsIl9vblRvdWNoRW5kIiwicm90YXRlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidmFsdWUiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJXaGVlbEV2ZW50IiwiRE9NX0RFTFRBX1BJWEVMIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkRPTV9ERUxUQV9MSU5FIiwidHlwZSIsIm1vdXNlV2hlZWxUeXBlIiwidGltZW91dCIsIm1vdXNlV2hlZWxUaW1lb3V0IiwibGFzdFZhbHVlIiwibW91c2VXaGVlbExhc3RWYWx1ZSIsInRpbWUiLCJtb3VzZVdoZWVsVGltZSIsIm5vdyIsInBlcmZvcm1hbmNlIiwiRGF0ZSIsInRpbWVEZWx0YSIsIk1hdGgiLCJmbG9vciIsImFicyIsInNldFRpbWVvdXQiLCJfdHlwZSIsIl96b29tIiwiY2xlYXJUaW1lb3V0IiwiZGVsdGEiLCJzY2FsZSIsImV4cCIsIl96b29tRW5kVGltZW91dCIsIl9zZXRUaW1lb3V0Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFRQSxNQUFSLEVBQWdCQyxRQUFoQixRQUErQixXQUEvQjs7QUFFQSxTQUFTQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCLElBQU1DLEtBQUssT0FBT0gsT0FBT0ksU0FBZCxLQUE0QixXQUE1QixHQUNUSixPQUFPSSxTQUFQLENBQWlCQyxTQUFqQixDQUEyQkMsV0FBM0IsRUFEUyxHQUNrQyxFQUQ3QztBQUVBLElBQU1DLFVBQVVKLEdBQUdLLE9BQUgsQ0FBVyxTQUFYLE1BQTBCLENBQUMsQ0FBM0M7O0FBRUE7QUFD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RCxPQUZ3QyxDQUV2Q2MsSUFGdUMsQ0FFbEMsSUFGa0MsQ0FBbEIsRUFFVCxHQUZTLENBQXZCO0FBR0Q7Ozs7OztlQXZRa0I1QixZIiwiZmlsZSI6ImV2ZW50LW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBiZWxvdyBvcmlnaW5hbGx5IGZyb206XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9ibG9iL21hc3Rlci9qcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzXG5cbmltcG9ydCB7d2luZG93LCBkb2N1bWVudH0gZnJvbSAnLi9nbG9iYWxzJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IHVhID0gdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID9cbiAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSA6ICcnO1xuY29uc3QgZmlyZWZveCA9IHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG5cbi8vIEV4dHJhY3QgYSBwb3NpdGlvbiBmcm9tIGEgbW91c2UgZXZlbnRcbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZWwsIGV2ZW50KSB7XG4gIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgZXZlbnQgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuICByZXR1cm4gW1xuICAgIGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcFxuICBdO1xufVxuXG4vLyBFeHRyYWN0IGFuIGFycmF5IG9mIHRvdWNoIHBvc2l0aW9ucyBmcm9tIGEgdG91Y2ggZXZlbnRcbmZ1bmN0aW9uIGdldFRvdWNoUG9zaXRpb25zKGVsLCBldmVudCkge1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBwb2ludHMucHVzaChbXG4gICAgICBldmVudC50b3VjaGVzW2ldLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgZXZlbnQudG91Y2hlc1tpXS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgICBdKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufVxuXG4vLyBSZXR1cm4gdGhlIGNlbnRyb2lkIG9mIGFuIGFycmF5IG9mIHBvaW50c1xuZnVuY3Rpb24gY2VudHJvaWQocG9zaXRpb25zKSB7XG4gIGNvbnN0IHN1bSA9IHBvc2l0aW9ucy5yZWR1Y2UoXG4gICAgKGFjYywgZWx0KSA9PiBbYWNjWzBdICsgZWx0WzBdLCBhY2NbMV0gKyBlbHRbMV1dLFxuICAgIFswLCAwXVxuICApO1xuICByZXR1cm4gW3N1bVswXSAvIHBvc2l0aW9ucy5sZW5ndGgsIHN1bVsxXSAvIHBvc2l0aW9ucy5sZW5ndGhdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudE1hbmFnZXIge1xuXG4gIGNvbnN0cnVjdG9yKGNhbnZhcywge1xuICAgIG9uTW91c2VNb3ZlID0gbm9vcCxcbiAgICBvbk1vdXNlQ2xpY2sgPSBub29wLFxuICAgIG9uTW91c2VEb3duID0gbm9vcCxcbiAgICBvbk1vdXNlVXAgPSBub29wLFxuICAgIG9uTW91c2VSb3RhdGUgPSBub29wLFxuICAgIG9uTW91c2VEcmFnID0gbm9vcCxcbiAgICBvblRvdWNoU3RhcnQgPSBub29wLFxuICAgIG9uVG91Y2hSb3RhdGUgPSBub29wLFxuICAgIG9uVG91Y2hEcmFnID0gbm9vcCxcbiAgICBvblRvdWNoRW5kID0gbm9vcCxcbiAgICBvblRvdWNoVGFwID0gbm9vcCxcbiAgICBvblpvb20gPSBub29wLFxuICAgIG9uWm9vbUVuZCA9IG5vb3AsXG4gICAgbWFwVG91Y2hUb01vdXNlID0gdHJ1ZSxcbiAgICBwcmVzc0tleVRvUm90YXRlID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgLy8gSW5zdGFsbCBkZWZhdWx0IHRvdWNoIGhhbmRsZXJzIGlmIHJlcXVlc3RlZCAoZm9yd2FyZHMgdG91Y2ggdG8gbW91c2UpXG4gICAgb25Ub3VjaFN0YXJ0ID0gb25Ub3VjaFN0YXJ0IHx8IChtYXBUb3VjaFRvTW91c2UgJiYgb25Nb3VzZURvd24pO1xuICAgIG9uVG91Y2hEcmFnID0gb25Ub3VjaERyYWcgfHwgKG1hcFRvdWNoVG9Nb3VzZSAmJiBvbk1vdXNlRHJhZyk7XG4gICAgb25Ub3VjaFJvdGF0ZSA9IG9uVG91Y2hSb3RhdGUgfHwgKG1hcFRvdWNoVG9Nb3VzZSAmJiBvbk1vdXNlUm90YXRlKTtcbiAgICBvblRvdWNoRW5kID0gb25Ub3VjaEVuZCB8fCAobWFwVG91Y2hUb01vdXNlICYmIG9uTW91c2VVcCk7XG4gICAgb25Ub3VjaFRhcCA9IG9uVG91Y2hUYXAgfHwgKG1hcFRvdWNoVG9Nb3VzZSAmJiBvbk1vdXNlQ2xpY2spO1xuXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuXG4gICAgLy8gUHVibGljIG1lbWJlcjogY2FuIGJlIGNoYW5nZWQgYnkgYXBwXG4gICAgdGhpcy5wcmVzc0tleVRvUm90YXRlID0gcHJlc3NLZXlUb1JvdGF0ZTtcblxuICAgIC8vIFByaXZhdGUgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZGlkRHJhZzogZmFsc2UsXG4gICAgICBpc0Z1bmN0aW9uS2V5UHJlc3NlZDogZmFsc2UsXG4gICAgICBzdGFydFBvczogbnVsbCxcbiAgICAgIHBvczogbnVsbCxcbiAgICAgIG1vdXNlV2hlZWxQb3M6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICBvbk1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VDbGljayxcbiAgICAgIG9uTW91c2VEb3duLFxuICAgICAgb25Nb3VzZVVwLFxuICAgICAgb25Ub3VjaFN0YXJ0LFxuICAgICAgb25Nb3VzZVJvdGF0ZSxcbiAgICAgIG9uTW91c2VEcmFnLFxuICAgICAgb25Ub3VjaFJvdGF0ZSxcbiAgICAgIG9uVG91Y2hEcmFnLFxuICAgICAgb25Ub3VjaEVuZCxcbiAgICAgIG9uVG91Y2hUYXAsXG4gICAgICBvblpvb20sXG4gICAgICBvblpvb21FbmRcbiAgICB9O1xuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGFueSBvdXRzdGFuZGluZyBldmVudCBsaXN0ZW5lcnNcbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc2V0U3RhdGUoc2V0dGluZ3MpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHNldHRpbmdzKTtcbiAgfVxuXG4gIF9nZXRNb3VzZVBvcyhldmVudCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5fY2FudmFzO1xuICAgIHJldHVybiBnZXRNb3VzZVBvc2l0aW9uKGVsLCBldmVudCk7XG4gIH1cblxuICBfZ2V0VG91Y2hQb3MoZXZlbnQpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuX2NhbnZhcztcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBnZXRUb3VjaFBvc2l0aW9ucyhlbCwgZXZlbnQpO1xuICAgIHJldHVybiBjZW50cm9pZChwb3NpdGlvbnMpO1xuICB9XG5cbiAgX2lzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHxcbiAgICAgIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xuICB9XG5cbiAgX29uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGlkRHJhZzogZmFsc2UsXG4gICAgICBzdGFydFBvczogcG9zLFxuICAgICAgcG9zLFxuICAgICAgaXNGdW5jdGlvbktleVByZXNzZWQ6IHRoaXMuX2lzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KVxuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VEb3duKHtwb3N9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlRHJhZy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBfb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0VG91Y2hQb3MoZXZlbnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGlkRHJhZzogZmFsc2UsXG4gICAgICBzdGFydFBvczogcG9zLFxuICAgICAgcG9zLFxuICAgICAgaXNGdW5jdGlvbktleVByZXNzZWQ6IHRoaXMuX2lzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KVxuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVG91Y2hTdGFydCh7cG9zfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaERyYWcuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBfb25Nb3VzZURyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRNb3VzZVBvcyhldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7cG9zLCBkaWREcmFnOiB0cnVlfSk7XG4gICAgY29uc3Qge3N0YXJ0UG9zfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCB7aXNGdW5jdGlvbktleVByZXNzZWR9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCByb3RhdGUgPSB0aGlzLnByZXNzS2V5VG9Sb3RhdGUgPyBpc0Z1bmN0aW9uS2V5UHJlc3NlZCA6ICFpc0Z1bmN0aW9uS2V5UHJlc3NlZDtcblxuICAgIGlmIChyb3RhdGUpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VSb3RhdGUoe3Bvcywgc3RhcnRQb3N9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25Nb3VzZURyYWcoe3Bvcywgc3RhcnRQb3N9KTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaERyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRUb3VjaFBvcyhldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7cG9zLCBkaWREcmFnOiB0cnVlfSk7XG5cbiAgICBjb25zdCB7aXNGdW5jdGlvbktleVByZXNzZWR9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCByb3RhdGUgPSB0aGlzLnByZXNzS2V5VG9Sb3RhdGUgPyBpc0Z1bmN0aW9uS2V5UHJlc3NlZCA6ICFpc0Z1bmN0aW9uS2V5UHJlc3NlZDtcblxuICAgIGlmIChyb3RhdGUpIHtcbiAgICAgIGNvbnN0IHtzdGFydFBvc30gPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaFJvdGF0ZSh7cG9zLCBzdGFydFBvc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vblRvdWNoRHJhZyh7cG9zfSk7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBfb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZURyYWcsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe3Bvc30pO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VVcCh7cG9zfSk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmRpZERyYWcpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VDbGljayh7cG9zfSk7XG4gICAgfVxuICB9XG5cbiAgX29uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoRHJhZywgZmFsc2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFRvdWNoUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtwb3N9KTtcbiAgICB0aGlzLmNhbGxiYWNrcy5vblRvdWNoRW5kKHtwb3N9KTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuZGlkRHJhZykge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaFRhcCh7cG9zfSk7XG4gICAgfVxuICB9XG5cbiAgX29uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VNb3ZlKHtwb3N9KTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIF9vbldoZWVsKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgdmFsdWUgPSBldmVudC5kZWx0YVk7XG4gICAgLy8gRmlyZWZveCBkb3VibGVzIHRoZSB2YWx1ZXMgb24gcmV0aW5hIHNjcmVlbnMuLi5cbiAgICBpZiAoZmlyZWZveCAmJiBldmVudC5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgdmFsdWUgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIGlmIChldmVudC5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICB2YWx1ZSAqPSA0MDtcbiAgICB9XG5cbiAgICBsZXQgdHlwZSA9IHRoaXMuc3RhdGUubW91c2VXaGVlbFR5cGU7XG4gICAgbGV0IHRpbWVvdXQgPSB0aGlzLnN0YXRlLm1vdXNlV2hlZWxUaW1lb3V0O1xuICAgIGxldCBsYXN0VmFsdWUgPSB0aGlzLnN0YXRlLm1vdXNlV2hlZWxMYXN0VmFsdWU7XG4gICAgbGV0IHRpbWUgPSB0aGlzLnN0YXRlLm1vdXNlV2hlZWxUaW1lO1xuXG4gICAgY29uc3Qgbm93ID0gKHdpbmRvdy5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKTtcbiAgICBjb25zdCB0aW1lRGVsdGEgPSBub3cgLSAodGltZSB8fCAwKTtcblxuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgICB0aW1lID0gbm93O1xuXG4gICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgNC4wMDAyNDQxNDA2MjUgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSBtb3VzZSB3aGVlbCBldmVudC5cbiAgICAgIHR5cGUgPSAnd2hlZWwnO1xuICAgICAgLy8gTm9ybWFsaXplIHRoaXMgdmFsdWUgdG8gbWF0Y2ggdHJhY2twYWQuXG4gICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyA0KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwICYmIE1hdGguYWJzKHZhbHVlKSA8IDQpIHtcbiAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSB0cmFja3BhZCBldmVudCBiZWNhdXNlIGl0IGlzIHNvIHNtYWxsLlxuICAgICAgdHlwZSA9ICd0cmFja3BhZCc7XG4gICAgfSBlbHNlIGlmICh0aW1lRGVsdGEgPiA0MDApIHtcbiAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgbmV3IHNjcm9sbCBhY3Rpb24uXG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gU3RhcnQgYSB0aW1lb3V0IGluIGNhc2UgdGhpcyB3YXMgYSBzaW5ndWxhciBldmVudCwgYW5kIGRlbGF5IGl0IGJ5IHVwXG4gICAgICAvLyB0byA0MG1zLlxuICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIGNvbnN0IF90eXBlID0gJ3doZWVsJztcbiAgICAgICAgdGhpcy5fem9vbSgtdGhpcy5zdGF0ZS5tb3VzZVdoZWVsTGFzdFZhbHVlLCB0aGlzLnN0YXRlLm1vdXNlV2hlZWxQb3MpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHttb3VzZVdoZWVsVHlwZTogX3R5cGV9KTtcbiAgICAgIH0uYmluZCh0aGlzKSwgNDApO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSByZXBlYXRpbmcgZXZlbnQsIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIG9mIGV2ZW50IGp1c3RcbiAgICAgIC8vIHlldC5cbiAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkO1xuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHN3aXRjaCBpbnRvIHdoZWVsIG1vZGUuXG4gICAgICB0eXBlID0gTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwID8gJ3RyYWNrcGFkJyA6ICd3aGVlbCc7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgZGVsYXllZCBldmVudCBpc24ndCBmaXJlZCBhZ2FpbiwgYmVjYXVzZSB3ZSBhY2N1bXVsYXRlXG4gICAgICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG8gdGhpcyBldmVudC5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YWx1ZSArPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xvdyBkb3duIHpvb20gaWYgc2hpZnQga2V5IGlzIGhlbGQgZm9yIG1vcmUgcHJlY2lzZSB6b29taW5nXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlIC8gNDtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGZpcmUgdGhlIGNhbGxiYWNrIGlmIHdlIGFjdHVhbGx5IGtub3cgd2hhdCB0eXBlIG9mIHNjcm9sbGluZyBkZXZpY2VcbiAgICAvLyB0aGUgdXNlciB1c2VzLlxuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzLl96b29tKC12YWx1ZSwgcG9zKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1vdXNlV2hlZWxUaW1lOiB0aW1lLFxuICAgICAgbW91c2VXaGVlbFBvczogcG9zLFxuICAgICAgbW91c2VXaGVlbFR5cGU6IHR5cGUsXG4gICAgICBtb3VzZVdoZWVsVGltZW91dDogdGltZW91dCxcbiAgICAgIG1vdXNlV2hlZWxMYXN0VmFsdWU6IGxhc3RWYWx1ZVxuICAgIH0pO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfem9vbShkZWx0YSwgcG9zKSB7XG4gICAgLy8gU2NhbGUgYnkgc2lnbW9pZCBvZiBzY3JvbGwgd2hlZWwgZGVsdGEuXG4gICAgbGV0IHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhIC8gMTAwKSkpO1xuICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHtcbiAgICAgIHNjYWxlID0gMSAvIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrcy5vblpvb20oe3BvcywgZGVsdGEsIHNjYWxlfSk7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl96b29tRW5kVGltZW91dCk7XG4gICAgdGhpcy5fem9vbUVuZFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiBfc2V0VGltZW91dCgpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uWm9vbUVuZCgpO1xuICAgIH0uYmluZCh0aGlzKSwgMjAwKTtcbiAgfVxufVxuXG4iXX0=