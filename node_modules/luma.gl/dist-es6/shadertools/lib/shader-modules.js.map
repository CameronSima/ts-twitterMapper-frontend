{"version":3,"sources":["../../../src/shadertools/lib/shader-modules.js"],"names":["assert","shaderModules","registerShaderModules","shaderModuleList","ignoreMultipleRegistrations","shaderModule","registerShaderModule","name","Error","dependencies","getShaderModule","moduleOrName","getShaderDependencies","modules","result","getDependencyGraph","level","Object","keys","sort","a","b","resolveModules","moduleNames","map","module"],"mappings":"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","file":"shader-modules.js","sourcesContent":["import assert from 'assert';\n\nconst shaderModules = {};\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false}) {\n  for (const shaderModule of shaderModuleList) {\n    registerShaderModule(shaderModule, {ignoreMultipleRegistrations});\n  }\n}\n\nfunction registerShaderModule(shaderModule, {ignoreMultipleRegistrations = false}) {\n  assert(shaderModule.name, 'shader module has no name');\n  if (!ignoreMultipleRegistrations && shaderModules[shaderModule.name]) {\n    // TODO - instead verify that definition is not changing...\n    throw new Error(`shader module ${shaderModule.name} already registered`);\n  }\n  shaderModules[shaderModule.name] = shaderModule;\n  shaderModule.dependencies = shaderModule.dependencies || [];\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  // Check if \"inline\" module\n  if (typeof moduleOrName !== 'string') {\n    const shaderModule = moduleOrName;\n    assert(typeof shaderModule.name === 'string');\n    registerShaderModule(shaderModule, {ignoreMultipleRegistrations: true});\n    return shaderModule;\n  }\n\n  // Look up module\n  const shaderModule = shaderModules[moduleOrName];\n  if (!shaderModule) {\n    // console.log(`${moduleOrName} not in registered modules:`, shaderModules);\n    assert(false, `Unknown shader module ${moduleOrName}`);\n  }\n  return shaderModule;\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nexport function getShaderDependencies(modules) {\n  const result = {};\n  getDependencyGraph({\n    modules,\n    level: 0,\n    result\n  });\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(result).sort((a, b) => result[b] - result[a]);\n}\n\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, result}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const moduleOrName of modules) {\n    const shaderModule = getShaderModule(moduleOrName);\n    result[shaderModule.name] = level;\n  }\n\n  // Recurse\n  for (const moduleOrName of modules) {\n    const shaderModule = getShaderModule(moduleOrName);\n\n    if (shaderModule.dependencies) {\n      getDependencyGraph({\n        modules: shaderModule.dependencies,\n        level: level + 1,\n        result\n      });\n    }\n  }\n\n  return result;\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  const moduleNames = modules.map(module => {\n    if (typeof module !== 'string') {\n      registerShaderModules([module], {ignoreMultipleRegistrations: true});\n      return module.name;\n    }\n    return module;\n  });\n\n  return getShaderDependencies(moduleNames);\n}\n"]}