'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = require('../globals');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ua = typeof _globals.window.navigator !== 'undefined' ? _globals.window.navigator.userAgent.toLowerCase() : '';
var firefox = ua.indexOf('firefox') !== -1;

var WHEEL_EVENTS = [
// Chrome, Safari
'wheel',
// IE
'mousewheel',
// legacy Firefox
'DOMMouseScroll'];
var EVENT_TYPE = 'wheel';

// Constants for normalizing input delta
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var TRACKPAD_MAX_DELTA = 4;
var TRACKPAD_MAX_DELTA_PER_TIME = 200;
// Slow down zoom if shift key is held for more precise zooming
var SHIFT_MULTIPLIER = 0.25;

var WheelInput = function () {
  function WheelInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, WheelInput);

    this.element = element;
    this.callback = callback;

    var events = WHEEL_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.time = 0;
    this.wheelPosition = null;
    this.type = null;
    this.timeout = null;
    this.lastValue = 0;

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(WheelInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'enableIfEventSupported',
    value: function enableIfEventSupported(eventType) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = true;
      }
    }

    /* eslint-disable complexity, max-statements */

  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      var value = event.deltaY;
      if (_globals.window.WheelEvent) {
        // Firefox doubles the values on retina screens...
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }
        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }

      var type = this.type,
          timeout = this.timeout,
          lastValue = this.lastValue,
          time = this.time;


      var now = (_globals.window && _globals.window.performance || Date).now();
      var timeDelta = now - (time || 0);

      this.wheelPosition = {
        x: event.clientX,
        y: event.clientY
      };
      time = now;

      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        type = 'wheel';
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      } else if (value !== 0 && Math.abs(value) < TRACKPAD_MAX_DELTA) {
        // This one is definitely a trackpad event because it is so small.
        type = 'trackpad';
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        type = null;
        lastValue = value;
        // Start a timeout in case this was a singular event,
        // and delay it by up to 40ms.
        timeout = _globals.window.setTimeout(function setTimeout() {
          this._onWheel(event, -lastValue, this.wheelPosition);
          type = 'wheel';
        }.bind(this), 40);
      } else if (!type) {
        // This is a repeating event, but we don't know the type of event just yet.
        // If the delta per time is small, we assume it's a fast trackpad;
        // otherwise we switch into wheel mode.
        type = Math.abs(timeDelta * value) < TRACKPAD_MAX_DELTA_PER_TIME ? 'trackpad' : 'wheel';

        // Make sure our delayed event isn't fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (timeout) {
          _globals.window.clearTimeout(timeout);
          timeout = null;
          value += lastValue;
        }
      }

      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }

      // Only fire the callback if we actually know
      // what type of scrolling device the user uses.
      if (type) {
        this._onWheel(event, -value, this.wheelPosition);
      }
    }
  }, {
    key: '_onWheel',
    value: function _onWheel(srcEvent, delta, position) {
      this.callback({
        type: EVENT_TYPE,
        center: position,
        delta: delta,
        srcEvent: srcEvent,
        pointerType: 'mouse',
        target: srcEvent.target
      });
    }
  }]);

  return WheelInput;
}();

exports.default = WheelInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudC1tYW5hZ2VyL3doZWVsLWlucHV0LmpzIl0sIm5hbWVzIjpbInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJmaXJlZm94IiwiaW5kZXhPZiIsIldIRUVMX0VWRU5UUyIsIkVWRU5UX1RZUEUiLCJXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIiLCJXSEVFTF9ERUxUQV9QRVJfTElORSIsIlRSQUNLUEFEX01BWF9ERUxUQSIsIlRSQUNLUEFEX01BWF9ERUxUQV9QRVJfVElNRSIsIlNISUZUX01VTFRJUExJRVIiLCJXaGVlbElucHV0IiwiZWxlbWVudCIsImNhbGxiYWNrIiwib3B0aW9ucyIsImV2ZW50cyIsImNvbmNhdCIsIk9iamVjdCIsImFzc2lnbiIsImVuYWJsZSIsInRpbWUiLCJ3aGVlbFBvc2l0aW9uIiwidHlwZSIsInRpbWVvdXQiLCJsYXN0VmFsdWUiLCJoYW5kbGVFdmVudCIsImJpbmQiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50VHlwZSIsInZhbHVlIiwiZGVsdGFZIiwiV2hlZWxFdmVudCIsImRlbHRhTW9kZSIsIkRPTV9ERUxUQV9QSVhFTCIsImRldmljZVBpeGVsUmF0aW8iLCJET01fREVMVEFfTElORSIsIm5vdyIsInBlcmZvcm1hbmNlIiwiRGF0ZSIsInRpbWVEZWx0YSIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJNYXRoIiwiZmxvb3IiLCJhYnMiLCJzZXRUaW1lb3V0IiwiX29uV2hlZWwiLCJjbGVhclRpbWVvdXQiLCJzaGlmdEtleSIsInNyY0V2ZW50IiwiZGVsdGEiLCJwb3NpdGlvbiIsImNlbnRlciIsInBvaW50ZXJUeXBlIiwidGFyZ2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBRUEsSUFBTUEsS0FBSyxPQUFPLGdCQUFPQyxTQUFkLEtBQTRCLFdBQTVCLEdB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QUNYLDBCQUFPNkIsWUFBUCxDQUFvQjdCLE9BQXBCO0FBQ0FBLG9CQUFVLElBQVY7QUFDQVMsbUJBQVNSLFNBQVQ7QUFDRDtBQUNGOztBQUVELFVBQUlLLE1BQU13QixRQUFOLElBQWtCckIsS0FBdEIsRUFBNkI7QUFDM0JBLGdCQUFRQSxRQUFRdEIsZ0JBQWhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUlZLElBQUosRUFBVTtBQUNSLGFBQUs2QixRQUFMLENBQWN0QixLQUFkLEVBQXFCLENBQUNHLEtBQXRCLEVBQTZCLEtBQUtYLGFBQWxDO0FBQ0Q7QUFDRjs7OzZCQUVRaUMsUSxFQUFVQyxLLEVBQU9DLFEsRUFBVTtBQUNsQyxXQUFLM0MsUUFBTCxDQUFjO0FBQ1pTLGNBQU1qQixVQURNO0FBRVpvRCxnQkFBUUQsUUFGSTtBQUdaRCxvQkFIWTtBQUlaRCwwQkFKWTtBQUtaSSxxQkFBYSxPQUxEO0FBTVpDLGdCQUFRTCxTQUFTSztBQU5MLE9BQWQ7QUFRRDs7Ozs7O2tCQTNIa0JoRCxVIiwiZmlsZSI6IndoZWVsLWlucHV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt3aW5kb3d9IGZyb20gJy4uL2dsb2JhbHMnO1xuXG5jb25zdCB1YSA9IHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbmNvbnN0IGZpcmVmb3ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuXG5jb25zdCBXSEVFTF9FVkVOVFMgPSBbXG4gIC8vIENocm9tZSwgU2FmYXJpXG4gICd3aGVlbCcsXG4gIC8vIElFXG4gICdtb3VzZXdoZWVsJyxcbiAgLy8gbGVnYWN5IEZpcmVmb3hcbiAgJ0RPTU1vdXNlU2Nyb2xsJ1xuXTtcbmNvbnN0IEVWRU5UX1RZUEUgPSAnd2hlZWwnO1xuXG4vLyBDb25zdGFudHMgZm9yIG5vcm1hbGl6aW5nIGlucHV0IGRlbHRhXG5jb25zdCBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbmNvbnN0IFdIRUVMX0RFTFRBX1BFUl9MSU5FID0gNDA7XG5jb25zdCBUUkFDS1BBRF9NQVhfREVMVEEgPSA0O1xuY29uc3QgVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FID0gMjAwO1xuLy8gU2xvdyBkb3duIHpvb20gaWYgc2hpZnQga2V5IGlzIGhlbGQgZm9yIG1vcmUgcHJlY2lzZSB6b29taW5nXG5jb25zdCBTSElGVF9NVUxUSVBMSUVSID0gMC4yNTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hlZWxJbnB1dCB7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgY29uc3QgZXZlbnRzID0gV0hFRUxfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7ZW5hYmxlOiB0cnVlfSwgb3B0aW9ucywge2V2ZW50c30pO1xuXG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLndoZWVsUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IDA7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucy5ldmVudHMuZm9yRWFjaChldmVudCA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBzZXQob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVJZkV2ZW50U3VwcG9ydGVkKGV2ZW50VHlwZSkge1xuICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlID0gZXZlbnQuZGVsdGFZO1xuICAgIGlmICh3aW5kb3cuV2hlZWxFdmVudCkge1xuICAgICAgLy8gRmlyZWZveCBkb3VibGVzIHRoZSB2YWx1ZXMgb24gcmV0aW5hIHNjcmVlbnMuLi5cbiAgICAgIGlmIChmaXJlZm94ICYmIGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgdmFsdWUgKj0gV0hFRUxfREVMVEFfUEVSX0xJTkU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lb3V0LFxuICAgICAgbGFzdFZhbHVlLFxuICAgICAgdGltZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgbm93ID0gKCh3aW5kb3cgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB8fCBEYXRlKS5ub3coKTtcbiAgICBjb25zdCB0aW1lRGVsdGEgPSBub3cgLSAodGltZSB8fCAwKTtcblxuICAgIHRoaXMud2hlZWxQb3NpdGlvbiA9IHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgICB0aW1lID0gbm93O1xuXG4gICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwICYmIE1hdGguYWJzKHZhbHVlKSA8IFRSQUNLUEFEX01BWF9ERUxUQSkge1xuICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXG4gICAgICB0eXBlID0gJ3RyYWNrcGFkJztcbiAgICB9IGVsc2UgaWYgKHRpbWVEZWx0YSA+IDQwMCkge1xuICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBTdGFydCBhIHRpbWVvdXQgaW4gY2FzZSB0aGlzIHdhcyBhIHNpbmd1bGFyIGV2ZW50LFxuICAgICAgLy8gYW5kIGRlbGF5IGl0IGJ5IHVwIHRvIDQwbXMuXG4gICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gc2V0VGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5fb25XaGVlbChldmVudCwgLWxhc3RWYWx1ZSwgdGhpcy53aGVlbFBvc2l0aW9uKTtcbiAgICAgICAgdHlwZSA9ICd3aGVlbCc7XG4gICAgICB9LmJpbmQodGhpcyksIDQwKTtcbiAgICB9IGVsc2UgaWYgKCF0eXBlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0IHlldC5cbiAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkO1xuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHN3aXRjaCBpbnRvIHdoZWVsIG1vZGUuXG4gICAgICB0eXBlID0gTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FID8gJ3RyYWNrcGFkJyA6ICd3aGVlbCc7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgZGVsYXllZCBldmVudCBpc24ndCBmaXJlZCBhZ2FpbiwgYmVjYXVzZSB3ZSBhY2N1bXVsYXRlXG4gICAgICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG8gdGhpcyBldmVudC5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YWx1ZSArPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogU0hJRlRfTVVMVElQTElFUjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGZpcmUgdGhlIGNhbGxiYWNrIGlmIHdlIGFjdHVhbGx5IGtub3dcbiAgICAvLyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzLl9vbldoZWVsKGV2ZW50LCAtdmFsdWUsIHRoaXMud2hlZWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgX29uV2hlZWwoc3JjRXZlbnQsIGRlbHRhLCBwb3NpdGlvbikge1xuICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgIGNlbnRlcjogcG9zaXRpb24sXG4gICAgICBkZWx0YSxcbiAgICAgIHNyY0V2ZW50LFxuICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICB0YXJnZXQ6IHNyY0V2ZW50LnRhcmdldFxuICAgIH0pO1xuICB9XG59XG4iXX0=