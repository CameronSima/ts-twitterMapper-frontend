'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup'];
var MOVE_EVENT_TYPES = ['mousemove', 'pointermove'];

/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */

var MoveInput = function () {
  function MoveInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, MoveInput);

    this.element = element;
    this.callback = callback;
    this.pressed = false;

    var events = MOUSE_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(MoveInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'enableIfEventSupported',
    value: function enableIfEventSupported(eventType) {
      if (MOVE_EVENT_TYPES.indexOf(eventType) >= 0) {
        this.options.enable = true;
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      var _this3 = this;

      if (!this.options.enable) {
        return;
      }

      switch (event.type) {
        case 'mousedown':
          if (event.button === 0) {
            // Left button is down
            this.pressed = true;
          }
          break;
        case 'mousemove':
          // Move events use `which` to track the button being pressed
          if (event.which !== 1) {
            // Left button is not down
            this.pressed = false;
          }
          if (!this.pressed) {
            // Drag events are emitted by hammer already
            // we just need to emit the move event on hover
            MOVE_EVENT_TYPES.forEach(function (type) {
              return _this3.callback({
                type: type,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
              });
            });
          }
          break;
        case 'mouseup':
          this.pressed = false;
          break;
        default:
      }
    }
  }]);

  return MoveInput;
}();

exports.default = MoveInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudC1tYW5hZ2VyL21vdmUtaW5wdXQuanMiXSwibmFtZXMiOlsiTU9VU0VfRVZFTlRTIiwiTU9WRV9FVkVOVF9UWVBFUyIsIk1vdmVJbnB1dCIsImVsZW1lbnQiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJwcmVzc2VkIiwiZXZlbnRzIiwiY29uY2F0IiwiT2JqZWN0IiwiYXNzaWduIiwiZW5hYmxlIiwiaGFuZGxlRXZlbnQiLCJiaW5kIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudFR5cGUiLCJpbmRleE9mIiwidHlwZSIsImJ1dHRvbiIsIndoaWNoIiwic3JjRXZlbnQiLCJwb2ludGVyVHlwZSIsInRhcmdldCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLElBQU1BLGVBQWUsQ0FBQyxXQUFELEVBQWMsV0FBZCxFQUEyQixTQUEzQixDQUFyQjtBQUNBLElBQU1DLG1CQUFtQixDQUFDLFdBQUQsRUFBYyxhQUFkLENBQXpCOztBQUVBOzs7Ozs7Ozs7SUFRcUJDLFM7QUFFbkIscUJBQVlDLE9BQVosRUFBcUJDLFFBQXJCLEVBQTZDO0FBQUE7O0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUMzQyxTQUFLRixPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtFLE9BQUwsR0FBZSxLQUFmOztBQUVBLFFBQU1DLFNBQVNQLGFBQWFRLE1BQWIsQ0FBb0JILFFBQVFFLE1BQVIsSUFBa0IsRUFBdEMsQ0FBZjtBQUNBLFNBQUtGLE9BQUwsR0FBZUksT0FBT0MsTUFBUCxDQUFjLEVBQUNDLFFBQVEsSUFBVCxFQUFkLEVBQThCTixPQUE5QixFQUF1QyxFQUFDRSxjQUFELEVBQXZDLENBQWY7O0FBRUEsU0FBS0ssV0FBTCxHQUFtQixLQUFLQSxXQUFMLENBQWlCQyxJQUFqQixDQUFzQixJQUF0QixDQUFuQjtBQUNBLFNBQUtSLE9BQUwsQ0FBYUUsTUFBYixDQUFvQk8sT0FBcEIsQ0FBNEI7QUFBQSxhQUFTWCxRQUFRWSxnQkFBUixDQUF5QkMsS0FBekIsRUFBZ0MsTUFBS0osV0FBckMsQ0FBVDtBQUFBLEtBQTVCO0FBQ0Q7Ozs7OEJBRVM7QUFBQTs7QUFDUixXQUFLUCxPQUFMLENBQWFFLE1BQWIsQ0FBb0JPLE9BQXBCLENBQTRCO0FBQUEsZUFBUyxPQUFLWCxPQUFMLENBQWFjLG1CQUFiLENBQWlDRCxLQUFqQyxFQUF3QyxPQUFLSixXQUE3QyxDQUFUO0FBQUEsT0FBNUI7QUFDRDs7O3dCQUVHUCxPLEVBQVM7QUFDWEksYUFBT0MsTUFBUCxDQUFjLEtBQUtMLE9BQW5CLEVBQTRCQSxPQUE1QjtBQUNEOztBQUVEOzs7Ozs7OzJDQUl1QmEsUyxFQUFXO0FBQ2hDLFVBQUlqQixpQkFBaUJrQixPQUFqQixDQUF5QkQsU0FBekIsS0FBdUMsQ0FBM0MsRUFBOEM7QUFDNUMsYUFBS2IsT0FBTCxDQUFhTSxNQUFiLEdBQXNCLElBQXRCO0FBQ0Q7QUFDRjs7O2dDQUVXSyxLLEVBQU87QUFBQTs7QUFDakIsVUFBSSxDQUFDLEtBQUtYLE9BQUwsQ0FBYU0sTUFBbEIsRUFBMEI7QUFDeEI7QUFDRDs7QUFFRCxjQUFRSyxNQUFNSSxJQUFkO0FBQ0EsYUFBSyxXQUFMO0FBQ0UsY0FBSUosTUFBTUssTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QjtBQUNBLGlCQUFLZixPQUFMLEdBQWUsSUFBZjtBQUNEO0FBQ0Q7QUFDRixhQUFLLFdBQUw7QUFDRTtBQUNBLGNBQUlVLE1BQU1NLEtBQU4sS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckI7QUFDQSxpQkFBS2hCLE9BQUwsR0FBZSxLQUFmO0FBQ0Q7QUFDRCxjQUFJLENBQUMsS0FBS0EsT0FBVixFQUFtQjtBQUNqQjtBQUNBO0FBQ0FMLDZCQUFpQmEsT0FBakIsQ0FBeUI7QUFBQSxxQkFBUSxPQUFLVixRQUFMLENBQWM7QUFDN0NnQiwwQkFENkM7QUFFN0NHLDBCQUFVUCxLQUZtQztBQUc3Q1EsNkJBQWEsT0FIZ0M7QUFJN0NDLHdCQUFRVCxNQUFNUztBQUorQixlQUFkLENBQVI7QUFBQSxhQUF6QjtBQU1EO0FBQ0Q7QUFDRixhQUFLLFNBQUw7QUFDRSxlQUFLbkIsT0FBTCxHQUFlLEtBQWY7QUFDQTtBQUNGO0FBM0JBO0FBNkJEOzs7Ozs7a0JBbEVrQkosUyIsImZpbGUiOiJtb3ZlLWlucHV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTU9VU0VfRVZFTlRTID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnXTtcbmNvbnN0IE1PVkVfRVZFTlRfVFlQRVMgPSBbJ21vdXNlbW92ZScsICdwb2ludGVybW92ZSddO1xuXG4vKipcbiAqIEhhbW1lci5qcyBzd2FsbG93cyAnbW92ZScgZXZlbnRzIChmb3IgcG9pbnRlci90b3VjaC9tb3VzZSlcbiAqIHdoZW4gdGhlIHBvaW50ZXIgaXMgbm90IGRvd24uIFRoaXMgY2xhc3Mgc2V0cyB1cCBhIGhhbmRsZXJcbiAqIHNwZWNpZmljYWxseSBmb3IgdGhlc2UgZXZlbnRzIHRvIHdvcmsgYXJvdW5kIHRoaXMgbGltaXRhdGlvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGNvdWxkIGJlIGV4dGVuZGVkIHRvIG1vcmUgaW50ZWxsaWdlbnRseSBoYW5kbGVcbiAqIG1vdmUgZXZlbnRzIGFjcm9zcyBpbnB1dCB0eXBlcywgZS5nLiBzdG9yaW5nIG11bHRpcGxlIHNpbXVsdGFuZW91c1xuICogcG9pbnRlci90b3VjaCBldmVudHMsIGNhbGN1bGF0aW5nIHNwZWVkL2RpcmVjdGlvbiwgZXRjLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3ZlSW5wdXQge1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGV2ZW50cyA9IE1PVVNFX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe2VuYWJsZTogdHJ1ZX0sIG9wdGlvbnMsIHtldmVudHN9KTtcblxuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVFdmVudCkpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9wdGlvbnMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIHNldChvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGlucHV0IChiZWdpbiBwcm9jZXNzaW5nIGV2ZW50cylcbiAgICogaWYgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIGlzIGFtb25nIHRob3NlIGhhbmRsZWQgYnkgdGhpcyBpbnB1dC5cbiAgICovXG4gIGVuYWJsZUlmRXZlbnRTdXBwb3J0ZWQoZXZlbnRUeXBlKSB7XG4gICAgaWYgKE1PVkVfRVZFTlRfVFlQRVMuaW5kZXhPZihldmVudFR5cGUpID49IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgIGlmIChldmVudC5idXR0b24gPT09IDApIHtcbiAgICAgICAgLy8gTGVmdCBidXR0b24gaXMgZG93blxuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgIC8vIE1vdmUgZXZlbnRzIHVzZSBgd2hpY2hgIHRvIHRyYWNrIHRoZSBidXR0b24gYmVpbmcgcHJlc3NlZFxuICAgICAgaWYgKGV2ZW50LndoaWNoICE9PSAxKSB7XG4gICAgICAgIC8vIExlZnQgYnV0dG9uIGlzIG5vdCBkb3duXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgLy8gRHJhZyBldmVudHMgYXJlIGVtaXR0ZWQgYnkgaGFtbWVyIGFscmVhZHlcbiAgICAgICAgLy8gd2UganVzdCBuZWVkIHRvIGVtaXQgdGhlIG1vdmUgZXZlbnQgb24gaG92ZXJcbiAgICAgICAgTU9WRV9FVkVOVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4gdGhpcy5jYWxsYmFjayh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG59XG4iXX0=