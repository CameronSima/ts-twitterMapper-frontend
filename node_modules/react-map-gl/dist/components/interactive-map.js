'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobind = require('../utils/autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _staticMap = require('./static-map');

var _staticMap2 = _interopRequireDefault(_staticMap);

var _mapState = require('../utils/map-state');

var _viewportMercatorProject = require('viewport-mercator-project');

var _eventManager = require('../utils/event-manager/event-manager');

var _eventManager2 = _interopRequireDefault(_eventManager);

var _mapControls = require('../utils/map-controls');

var _mapControls2 = _interopRequireDefault(_mapControls);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

var _deprecateWarn = require('../utils/deprecate-warn');

var _deprecateWarn2 = _interopRequireDefault(_deprecateWarn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = Object.assign({}, _staticMap2.default.propTypes, {
  // Additional props on top of StaticMap

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes2.default.number,
  // Min zoom level
  minZoom: _propTypes2.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes2.default.number,
  // Min pitch in degrees
  minPitch: _propTypes2.default.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: _propTypes2.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes2.default.bool,
  // Drag to pan
  dragPan: _propTypes2.default.bool,
  // Drag to rotate
  dragRotate: _propTypes2.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes2.default.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: _propTypes2.default.bool,

  /**
     * Called when the map is hovered over.
     * @callback
     * @param {Object} event - The mouse event.
     * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
     * @param {Array} event.features - The features under the pointer, using Mapbox's
     * queryRenderedFeatures API:
     * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
     * To make a layer interactive, set the `interactive` property in the
     * layer style to `true`. See Mapbox's style spec
     * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
     */
  onHover: _propTypes2.default.func,
  /**
    * Called when the map is clicked.
    * @callback
    * @param {Object} event - The mouse event.
    * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
    * @param {Array} event.features - The features under the pointer, using Mapbox's
    * queryRenderedFeatures API:
    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
    * To make a layer interactive, set the `interactive` property in the
    * layer style to `true`. See Mapbox's style spec
    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
    */
  onClick: _propTypes2.default.func,

  /** Radius to detect features around a clicked point. Defaults to 0. */
  clickRadius: _propTypes2.default.number,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes2.default.func,

  /** Advanced features */
  // Contraints for displaying the map. If not met, then the map is hidden.
  // Experimental! May be changed in minor version updates.
  visibilityConstraints: _propTypes2.default.shape({
    minZoom: _propTypes2.default.number,
    maxZoom: _propTypes2.default.number,
    minPitch: _propTypes2.default.number,
    maxPitch: _propTypes2.default.number
  }),
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  mapControls: _propTypes2.default.shape({
    events: _propTypes2.default.arrayOf(_propTypes2.default.string),
    handleEvent: _propTypes2.default.func
  })
});

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging,
      isHovering = _ref.isHovering;
  return isDragging ? _config2.default.CURSOR.GRABBING : isHovering ? _config2.default.CURSOR.POINTER : _config2.default.CURSOR.GRAB;
};

var defaultProps = Object.assign({}, _staticMap2.default.defaultProps, _mapState.MAPBOX_LIMITS, {
  onViewportChange: null,
  onClick: null,
  onHover: null,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,

  clickRadius: 0,
  getCursor: getDefaultCursor,

  visibilityConstraints: _mapState.MAPBOX_LIMITS,

  mapControls: new _mapControls2.default()
});

var childContextTypes = {
  viewport: _propTypes2.default.instanceOf(_viewportMercatorProject.PerspectiveMercatorViewport),
  isDragging: _propTypes2.default.bool
};

var InteractiveMap = function (_PureComponent) {
  _inherits(InteractiveMap, _PureComponent);

  _createClass(InteractiveMap, null, [{
    key: 'supported',
    value: function supported() {
      return _staticMap2.default.supported();
    }
  }]);

  function InteractiveMap(props) {
    _classCallCheck(this, InteractiveMap);

    var _this = _possibleConstructorReturn(this, (InteractiveMap.__proto__ || Object.getPrototypeOf(InteractiveMap)).call(this, props));

    (0, _autobind2.default)(_this);
    // Check for deprecated props
    (0, _deprecateWarn2.default)(props);

    _this.state = {
      // Whether the cursor is down
      isDragging: false,
      // Whether the cursor is over a clickable feature
      isHovering: false
    };
    return _this;
  }

  _createClass(InteractiveMap, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        viewport: new _viewportMercatorProject.PerspectiveMercatorViewport(this.props),
        isDragging: this.state.isDragging
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var eventCanvas = this.refs.eventCanvas;
      var mapControls = this.props.mapControls;

      // Register event handlers defined by map controls

      var events = {};
      mapControls.events.forEach(function (eventName) {
        events[eventName] = _this2._handleEvent;
      });

      var eventManager = new _eventManager2.default(eventCanvas, { events: events });

      // Register additional event handlers for click and hover
      eventManager.on('mousemove', this._onMouseMove);
      eventManager.on('click', this._onMouseClick);
      this._eventManager = eventManager;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._eventManager) {
        // Must destroy because hammer adds event listeners to window
        this._eventManager.destroy();
      }
    }
  }, {
    key: '_handleEvent',
    value: function _handleEvent(event) {
      var controlOptions = Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange
      });
      return this.props.mapControls.handleEvent(event, controlOptions);
    }
  }, {
    key: 'getMap',
    value: function getMap() {
      return this._map.getMap();
    }
  }, {
    key: 'queryRenderedFeatures',
    value: function queryRenderedFeatures(geometry, options) {
      return this._map.queryRenderedFeatures(geometry, options);
    }

    // Checks a visibilityConstraints object to see if the map should be displayed

  }, {
    key: 'checkVisibilityConstraints',
    value: function checkVisibilityConstraints(props) {
      var capitalize = function capitalize(s) {
        return s[0].toUpperCase() + s.slice(1);
      };

      var visibilityConstraints = props.visibilityConstraints;

      for (var propName in props) {
        var capitalizedPropName = capitalize(propName);
        var minPropName = 'min' + capitalizedPropName;
        var maxPropName = 'max' + capitalizedPropName;

        if (minPropName in visibilityConstraints && props[propName] < visibilityConstraints[minPropName]) {
          return false;
        }
        if (maxPropName in visibilityConstraints && props[propName] > visibilityConstraints[maxPropName]) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: '_getFeatures',
    value: function _getFeatures(_ref2) {
      var pos = _ref2.pos,
          radius = _ref2.radius;

      var features = void 0;
      if (radius) {
        // Radius enables point features, like marker symbols, to be clicked.
        var size = radius;
        var bbox = [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]];
        features = this._map.queryRenderedFeatures(bbox);
      } else {
        features = this._map.queryRenderedFeatures(pos);
      }
      return features;
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref3) {
      var _ref3$isDragging = _ref3.isDragging,
          isDragging = _ref3$isDragging === undefined ? false : _ref3$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }

    // HOVER AND CLICK

  }, {
    key: '_getPos',
    value: function _getPos(event) {
      var _event$srcEvent = event.srcEvent,
          clientX = _event$srcEvent.clientX,
          clientY = _event$srcEvent.clientY,
          rootElement = event.rootElement;

      var rect = rootElement.getBoundingClientRect();
      return [clientX - rect.left - rootElement.clientLeft, clientY - rect.top - rootElement.clientTop];
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      if (!this.state.isDragging) {
        var pos = this._getPos(event);
        var features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        var isHovering = features && features.length > 0;
        if (isHovering !== this.state.isHovering) {
          this.setState({ isHovering: isHovering });
        }

        if (this.props.onHover) {
          var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this.props);
          event.lngLat = viewport.unproject(pos);
          event.features = features;

          this.props.onHover(event);
        }
      }
    }
  }, {
    key: '_onMouseClick',
    value: function _onMouseClick(event) {
      if (this.props.onClick) {
        var pos = this._getPos(event);
        var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this.props);
        event.lngLat = viewport.unproject(pos);
        event.features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        this.props.onClick(event);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: 'eventCanvas',
        style: eventCanvasStyle
      }, (0, _react.createElement)(_staticMap2.default, Object.assign({}, this.props, {
        visible: this.checkVisibilityConstraints(this.props),
        ref: function ref(map) {
          _this3._map = map;
        }
      })));
    }
  }]);

  return InteractiveMap;
}(_react.PureComponent);

exports.default = InteractiveMap;


InteractiveMap.displayName = 'InteractiveMap';
InteractiveMap.propTypes = propTypes;
InteractiveMap.defaultProps = defaultProps;
InteractiveMap.childContextTypes = childContextTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcC5qcyJdLCJuYW1lcyI6WyJwcm9wVHlwZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJtYXhab29tIiwibnVtYmVyIiwibWluWm9vbSIsIm1heFBpdGNoIiwibWluUGl0Y2giLCJvblZpZXdwb3J0Q2hhbmdlIiwiZnVuYyIsInNjcm9sbFpvb20iLCJib29sIiwiZHJhZ1BhbiIsImRyYWdSb3RhdGUiLCJkb3VibGVDbGlja1pvb20iLCJ0b3VjaFpvb21Sb3RhdGUiLCJvbkhvdmVyIiwib25DbGljayIsImNsaWNrUmFkaXVzIiwiZ2V0Q3Vyc29yIiwidmlzaWJpbGl0eUNvbnN0cmFpbnRzIiwic2hhcGUiLCJtYXBDb250cm9scyIsImV2ZW50cyIsImFycmF5T2YiLCJzdHJpbmciLCJoYW5kbGVFdmVudCIsImdldERlZmF1bHRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiaXNIb3ZlcmluZyIsIkNVUlNPUiIsIkdSQUJCSU5HIiwiUE9JTlRFUiIsIkdSQUIiLCJkZWZhdWx0UHJvcHMiLCJjaGlsZENvbnRleHRUeXBlcyIsInZpZXdwb3J0IiwiaW5zdGFuY2VPZiIsIkludGVyYWN0aXZlTWFwIiwic3VwcG9ydGVkIiwicHJvcHMiLCJzdGF0ZSIsImV2ZW50Q2FudmFzIiwicmVmcyIsImZvckVhY2giLCJldmVudE5hbWUiLCJfaGFuZGxlRXZlbnQiLCJldmVudE1hbmFnZXIiLCJvbiIsIl9vbk1vdXNlTW92ZSIsIl9vbk1vdXNlQ2xpY2siLCJfZXZlbnRNYW5hZ2VyIiwiZGVzdHJveSIsImV2ZW50IiwiY29udHJvbE9wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsIl9tYXAiLCJnZXRNYXAiLCJnZW9tZXRyeSIsIm9wdGlvbnMiLCJxdWVyeVJlbmRlcmVkRmVhdHVyZXMiLCJjYXBpdGFsaXplIiwicyIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJwcm9wTmFtZSIsImNhcGl0YWxpemVkUHJvcE5hbWUiLCJtaW5Qcm9wTmFtZSIsIm1heFByb3BOYW1lIiwicG9zIiwicmFkaXVzIiwiZmVhdHVyZXMiLCJzaXplIiwiYmJveCIsInNldFN0YXRlIiwic3JjRXZlbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsInJvb3RFbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJjbGllbnRMZWZ0IiwidG9wIiwiY2xpZW50VG9wIiwiX2dldFBvcyIsIl9nZXRGZWF0dXJlcyIsImxlbmd0aCIsImxuZ0xhdCIsInVucHJvamVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZXZlbnRDYW52YXNTdHlsZSIsInBvc2l0aW9uIiwiY3Vyc29yIiwia2V5IiwicmVmIiwic3R5bGUiLCJ2aXNpYmxlIiwiY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMiLCJtYXAiLCJkaXNwbGF5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsWUFBWUMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0Isb0JBQVVGLFNBQTVCLEVBQXVDO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQUcsV0FBUyxvQkFBVUMsTUFMb0M7QUFNdkQ7QUFDQUMsV0FBUyxvQkFBVUQsTUFQb0M7QUFRdkQ7QUFDQUUsWUFBVSxvQkFBVUYsTUFUbUM7QUFVdkQ7QUFDQUcsWUFBVSxvQkFBVUgsTUFYbUM7O0FBYXZEOzs7OztBQUtBSSxvQkFBa0Isb0JBQVVDLElBbEIyQjs7QUFvQnZEO0FBQ0E7QUFDQUMsY0FBWSxvQkFBVUMsSUF0QmlDO0FBdUJ2RDtBQUNBQyxXQUFTLG9CQUFVRCxJQXhCb0M7QUF5QnZEO0FBQ0FFLGNBQVksb0JBQVVGLElBMUJpQztBQTJCdkQ7QUFDQUcsbUJBQWlCLG9CQUFVSCxJQTVCNEI7QUE2QnZEO0FBQ0FJLG1CQUFpQixvQkFBVUos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LEtBQUsvQixLQUFMLENBQVd0QixXQUF6QixFQUFsQixDQUFqQjs7QUFFQSxhQUFLc0IsS0FBTCxDQUFXdkIsT0FBWCxDQUFtQm9DLEtBQW5CO0FBQ0Q7QUFDRjs7OzZCQUVRO0FBQUE7O0FBQUEsbUJBQzRCLEtBQUtiLEtBRGpDO0FBQUEsVUFDQW1ELEtBREEsVUFDQUEsS0FEQTtBQUFBLFVBQ09DLE1BRFAsVUFDT0EsTUFEUDtBQUFBLFVBQ2V6RSxTQURmLFVBQ2VBLFNBRGY7OztBQUdQLFVBQU0wRSxtQkFBbUI7QUFDdkJGLG9CQUR1QjtBQUV2QkMsc0JBRnVCO0FBR3ZCRSxrQkFBVSxVQUhhO0FBSXZCQyxnQkFBUTVFLFVBQVUsS0FBS3NCLEtBQWY7QUFKZSxPQUF6Qjs7QUFPQSxhQUNFLDBCQUFjLEtBQWQsRUFBcUI7QUFDbkJ1RCxhQUFLLGNBRGM7QUFFbkJDLGFBQUssYUFGYztBQUduQkMsZUFBT0w7QUFIWSxPQUFyQixFQUtFLCtDQUF5QjVGLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtzQyxLQUF2QixFQUE4QjtBQUNyRDJELGlCQUFTLEtBQUtDLDBCQUFMLENBQWdDLEtBQUs1RCxLQUFyQyxDQUQ0QztBQUVyRHlELGFBQUssa0JBQU87QUFDVixpQkFBS3hDLElBQUwsR0FBWTRDLEdBQVo7QUFDRDtBQUpvRCxPQUE5QixDQUF6QixDQUxGLENBREY7QUFjRDs7Ozs7O2tCQTdLa0IvRCxjOzs7QUFnTHJCQSxlQUFlZ0UsV0FBZixHQUE2QixnQkFBN0I7QUFDQWhFLGVBQWV0QyxTQUFmLEdBQTJCQSxTQUEzQjtBQUNBc0MsZUFBZUosWUFBZixHQUE4QkEsWUFBOUI7QUFDQUksZUFBZUgsaUJBQWYsR0FBbUNBLGlCQUFuQyIsImZpbGUiOiJpbnRlcmFjdGl2ZS1tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1B1cmVDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi4vdXRpbHMvYXV0b2JpbmQnO1xuXG5pbXBvcnQgU3RhdGljTWFwIGZyb20gJy4vc3RhdGljLW1hcCc7XG5pbXBvcnQge01BUEJPWF9MSU1JVFN9IGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5pbXBvcnQge1BlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbmltcG9ydCBFdmVudE1hbmFnZXIgZnJvbSAnLi4vdXRpbHMvZXZlbnQtbWFuYWdlci9ldmVudC1tYW5hZ2VyJztcbmltcG9ydCBNYXBDb250cm9scyBmcm9tICcuLi91dGlscy9tYXAtY29udHJvbHMnO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IGRlcHJlY2F0ZVdhcm4gZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlLXdhcm4nO1xuXG5jb25zdCBwcm9wVHlwZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0aWNNYXAucHJvcFR5cGVzLCB7XG4gIC8vIEFkZGl0aW9uYWwgcHJvcHMgb24gdG9wIG9mIFN0YXRpY01hcFxuXG4gIC8qKiBWaWV3cG9ydCBjb25zdHJhaW50cyAqL1xuICAvLyBNYXggem9vbSBsZXZlbFxuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gem9vbSBsZXZlbFxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNYXggcGl0Y2ggaW4gZGVncmVlc1xuICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWluIHBpdGNoIGluIGRlZ3JlZXNcbiAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIGBvblZpZXdwb3J0Q2hhbmdlYCBjYWxsYmFjayBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGVcbiAgICogbWFwLiBUaGUgb2JqZWN0IHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgY29udGFpbnMgdmlld3BvcnQgcHJvcGVydGllc1xuICAgKiBzdWNoIGFzIGBsb25naXR1ZGVgLCBgbGF0aXR1ZGVgLCBgem9vbWAgZXRjLlxuICAgKi9cbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIEVuYWJsZXMgY29udHJvbCBldmVudCBoYW5kbGluZyAqL1xuICAvLyBTY3JvbGwgdG8gem9vbVxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byBwYW5cbiAgZHJhZ1BhbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERyYWcgdG8gcm90YXRlXG4gIGRyYWdSb3RhdGU6IFByb3BUeXBlcy5ib29sLFxuICAvLyBEb3VibGUgY2xpY2sgdG8gem9vbVxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBQaW5jaCB0byB6b29tIC8gcm90YXRlXG4gIHRvdWNoWm9vbVJvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAvKipcbiAgICAqIENhbGxlZCB3aGVuIHRoZSBtYXAgaXMgaG92ZXJlZCBvdmVyLlxuICAgICogQGNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IGV2ZW50LmxuZ0xhdCAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnRlclxuICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQuZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdW5kZXIgdGhlIHBvaW50ZXIsIHVzaW5nIE1hcGJveCdzXG4gICAgKiBxdWVyeVJlbmRlcmVkRmVhdHVyZXMgQVBJOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBtYWtlIGEgbGF5ZXIgaW50ZXJhY3RpdmUsIHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBpbiB0aGVcbiAgICAqIGxheWVyIHN0eWxlIHRvIGB0cnVlYC4gU2VlIE1hcGJveCdzIHN0eWxlIHNwZWNcbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVyLWludGVyYWN0aXZlXG4gICAgKi9cbiAgb25Ib3ZlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gdGhlIG1hcCBpcyBjbGlja2VkLlxuICAgICogQGNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IGV2ZW50LmxuZ0xhdCAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnRlclxuICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQuZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdW5kZXIgdGhlIHBvaW50ZXIsIHVzaW5nIE1hcGJveCdzXG4gICAgKiBxdWVyeVJlbmRlcmVkRmVhdHVyZXMgQVBJOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBtYWtlIGEgbGF5ZXIgaW50ZXJhY3RpdmUsIHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBpbiB0aGVcbiAgICAqIGxheWVyIHN0eWxlIHRvIGB0cnVlYC4gU2VlIE1hcGJveCdzIHN0eWxlIHNwZWNcbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVyLWludGVyYWN0aXZlXG4gICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIFJhZGl1cyB0byBkZXRlY3QgZmVhdHVyZXMgYXJvdW5kIGEgY2xpY2tlZCBwb2ludC4gRGVmYXVsdHMgdG8gMC4gKi9cbiAgY2xpY2tSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqIEFjY2Vzc29yIHRoYXQgcmV0dXJucyBhIGN1cnNvciBzdHlsZSB0byBzaG93IGludGVyYWN0aXZlIHN0YXRlICovXG4gIGdldEN1cnNvcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIEFkdmFuY2VkIGZlYXR1cmVzICovXG4gIC8vIENvbnRyYWludHMgZm9yIGRpc3BsYXlpbmcgdGhlIG1hcC4gSWYgbm90IG1ldCwgdGhlbiB0aGUgbWFwIGlzIGhpZGRlbi5cbiAgLy8gRXhwZXJpbWVudGFsISBNYXkgYmUgY2hhbmdlZCBpbiBtaW5vciB2ZXJzaW9uIHVwZGF0ZXMuXG4gIHZpc2liaWxpdHlDb25zdHJhaW50czogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWF4UGl0Y2g6IFByb3BUeXBlcy5udW1iZXJcbiAgfSksXG4gIC8vIEEgbWFwIGNvbnRyb2wgaW5zdGFuY2UgdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBtYXAgY29udHJvbHNcbiAgLy8gVGhlIG9iamVjdCBtdXN0IGV4cG9zZSBvbmUgcHJvcGVydHk6IGBldmVudHNgIGFzIGFuIGFycmF5IG9mIHN1YnNjcmliZWRcbiAgLy8gZXZlbnQgbmFtZXM7IGFuZCB0d28gbWV0aG9kczogYHNldFN0YXRlKHN0YXRlKWAgYW5kIGBoYW5kbGUoZXZlbnQpYFxuICBtYXBDb250cm9sczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBldmVudHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGhhbmRsZUV2ZW50OiBQcm9wVHlwZXMuZnVuY1xuICB9KVxufSk7XG5cbmNvbnN0IGdldERlZmF1bHRDdXJzb3IgPSAoe2lzRHJhZ2dpbmcsIGlzSG92ZXJpbmd9KSA9PiBpc0RyYWdnaW5nID9cbiAgY29uZmlnLkNVUlNPUi5HUkFCQklORyA6XG4gIChpc0hvdmVyaW5nID8gY29uZmlnLkNVUlNPUi5QT0lOVEVSIDogY29uZmlnLkNVUlNPUi5HUkFCKTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdGljTWFwLmRlZmF1bHRQcm9wcywgTUFQQk9YX0xJTUlUUywge1xuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuICBvbkNsaWNrOiBudWxsLFxuICBvbkhvdmVyOiBudWxsLFxuXG4gIHNjcm9sbFpvb206IHRydWUsXG4gIGRyYWdQYW46IHRydWUsXG4gIGRyYWdSb3RhdGU6IHRydWUsXG4gIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgdG91Y2hab29tUm90YXRlOiB0cnVlLFxuXG4gIGNsaWNrUmFkaXVzOiAwLFxuICBnZXRDdXJzb3I6IGdldERlZmF1bHRDdXJzb3IsXG5cbiAgdmlzaWJpbGl0eUNvbnN0cmFpbnRzOiBNQVBCT1hfTElNSVRTLFxuXG4gIG1hcENvbnRyb2xzOiBuZXcgTWFwQ29udHJvbHMoKVxufSk7XG5cbmNvbnN0IGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICB2aWV3cG9ydDogUHJvcFR5cGVzLmluc3RhbmNlT2YoUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KSxcbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyYWN0aXZlTWFwIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG5cbiAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gU3RhdGljTWFwLnN1cHBvcnRlZCgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gICAgLy8gQ2hlY2sgZm9yIGRlcHJlY2F0ZWQgcHJvcHNcbiAgICBkZXByZWNhdGVXYXJuKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBXaGV0aGVyIHRoZSBjdXJzb3IgaXMgZG93blxuICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAvLyBXaGV0aGVyIHRoZSBjdXJzb3IgaXMgb3ZlciBhIGNsaWNrYWJsZSBmZWF0dXJlXG4gICAgICBpc0hvdmVyaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdwb3J0OiBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KHRoaXMucHJvcHMpLFxuICAgICAgaXNEcmFnZ2luZzogdGhpcy5zdGF0ZS5pc0RyYWdnaW5nXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHtldmVudENhbnZhc30gPSB0aGlzLnJlZnM7XG4gICAgY29uc3Qge21hcENvbnRyb2xzfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBSZWdpc3RlciBldmVudCBoYW5kbGVycyBkZWZpbmVkIGJ5IG1hcCBjb250cm9sc1xuICAgIGNvbnN0IGV2ZW50cyA9IHt9O1xuICAgIG1hcENvbnRyb2xzLmV2ZW50cy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuX2hhbmRsZUV2ZW50O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcihldmVudENhbnZhcywge2V2ZW50c30pO1xuXG4gICAgLy8gUmVnaXN0ZXIgYWRkaXRpb25hbCBldmVudCBoYW5kbGVycyBmb3IgY2xpY2sgYW5kIGhvdmVyXG4gICAgZXZlbnRNYW5hZ2VyLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uKCdjbGljaycsIHRoaXMuX29uTW91c2VDbGljayk7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFuYWdlcikge1xuICAgICAgLy8gTXVzdCBkZXN0cm95IGJlY2F1c2UgaGFtbWVyIGFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBjb250cm9sT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgIG9uU3RhdGVDaGFuZ2U6IHRoaXMuX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3BzLm1hcENvbnRyb2xzLmhhbmRsZUV2ZW50KGV2ZW50LCBjb250cm9sT3B0aW9ucyk7XG4gIH1cblxuICBnZXRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXRNYXAoKTtcbiAgfVxuXG4gIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhnZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIENoZWNrcyBhIHZpc2liaWxpdHlDb25zdHJhaW50cyBvYmplY3QgdG8gc2VlIGlmIHRoZSBtYXAgc2hvdWxkIGJlIGRpc3BsYXllZFxuICBjaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgIGNvbnN0IGNhcGl0YWxpemUgPSBzID0+IHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG5cbiAgICBjb25zdCB7dmlzaWJpbGl0eUNvbnN0cmFpbnRzfSA9IHByb3BzO1xuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkUHJvcE5hbWUgPSBjYXBpdGFsaXplKHByb3BOYW1lKTtcbiAgICAgIGNvbnN0IG1pblByb3BOYW1lID0gYG1pbiR7Y2FwaXRhbGl6ZWRQcm9wTmFtZX1gO1xuICAgICAgY29uc3QgbWF4UHJvcE5hbWUgPSBgbWF4JHtjYXBpdGFsaXplZFByb3BOYW1lfWA7XG5cbiAgICAgIGlmIChtaW5Qcm9wTmFtZSBpbiB2aXNpYmlsaXR5Q29uc3RyYWludHMgJiZcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdIDwgdmlzaWJpbGl0eUNvbnN0cmFpbnRzW21pblByb3BOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWF4UHJvcE5hbWUgaW4gdmlzaWJpbGl0eUNvbnN0cmFpbnRzICYmXG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA+IHZpc2liaWxpdHlDb25zdHJhaW50c1ttYXhQcm9wTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9nZXRGZWF0dXJlcyh7cG9zLCByYWRpdXN9KSB7XG4gICAgbGV0IGZlYXR1cmVzO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIC8vIFJhZGl1cyBlbmFibGVzIHBvaW50IGZlYXR1cmVzLCBsaWtlIG1hcmtlciBzeW1ib2xzLCB0byBiZSBjbGlja2VkLlxuICAgICAgY29uc3Qgc2l6ZSA9IHJhZGl1cztcbiAgICAgIGNvbnN0IGJib3ggPSBbW3Bvc1swXSAtIHNpemUsIHBvc1sxXSArIHNpemVdLCBbcG9zWzBdICsgc2l6ZSwgcG9zWzFdIC0gc2l6ZV1dO1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMocG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSh7aXNEcmFnZ2luZyA9IGZhbHNlfSkge1xuICAgIGlmIChpc0RyYWdnaW5nICE9PSB0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzRHJhZ2dpbmd9KTtcbiAgICB9XG4gIH1cblxuICAvLyBIT1ZFUiBBTkQgQ0xJQ0tcbiAgX2dldFBvcyhldmVudCkge1xuICAgIGNvbnN0IHtzcmNFdmVudDoge2NsaWVudFgsIGNsaWVudFl9LCByb290RWxlbWVudH0gPSBldmVudDtcbiAgICBjb25zdCByZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNsaWVudFggLSByZWN0LmxlZnQgLSByb290RWxlbWVudC5jbGllbnRMZWZ0LFxuICAgICAgY2xpZW50WSAtIHJlY3QudG9wIC0gcm9vdEVsZW1lbnQuY2xpZW50VG9wXG4gICAgXTtcbiAgfVxuXG4gIF9vbk1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRQb3MoZXZlbnQpO1xuICAgICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLl9nZXRGZWF0dXJlcyh7cG9zLCByYWRpdXM6IHRoaXMucHJvcHMuY2xpY2tSYWRpdXN9KTtcblxuICAgICAgY29uc3QgaXNIb3ZlcmluZyA9IGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoaXNIb3ZlcmluZyAhPT0gdGhpcy5zdGF0ZS5pc0hvdmVyaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2lzSG92ZXJpbmd9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMub25Ib3Zlcikge1xuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQodGhpcy5wcm9wcyk7XG4gICAgICAgIGV2ZW50LmxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICAgICAgICBldmVudC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25Ib3ZlcihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uTW91c2VDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFBvcyhldmVudCk7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQodGhpcy5wcm9wcyk7XG4gICAgICBldmVudC5sbmdMYXQgPSB2aWV3cG9ydC51bnByb2plY3QocG9zKTtcbiAgICAgIGV2ZW50LmZlYXR1cmVzID0gdGhpcy5fZ2V0RmVhdHVyZXMoe3BvcywgcmFkaXVzOiB0aGlzLnByb3BzLmNsaWNrUmFkaXVzfSk7XG5cbiAgICAgIHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3J9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGV2ZW50Q2FudmFzU3R5bGUgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5zdGF0ZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAga2V5OiAnbWFwLWNvbnRyb2xzJyxcbiAgICAgICAgcmVmOiAnZXZlbnRDYW52YXMnLFxuICAgICAgICBzdHlsZTogZXZlbnRDYW52YXNTdHlsZVxuICAgICAgfSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChTdGF0aWNNYXAsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgICB2aXNpYmxlOiB0aGlzLmNoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzKHRoaXMucHJvcHMpLFxuICAgICAgICAgIHJlZjogbWFwID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cblxuSW50ZXJhY3RpdmVNYXAuZGlzcGxheU5hbWUgPSAnSW50ZXJhY3RpdmVNYXAnO1xuSW50ZXJhY3RpdmVNYXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuSW50ZXJhY3RpdmVNYXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuSW50ZXJhY3RpdmVNYXAuY2hpbGRDb250ZXh0VHlwZXMgPSBjaGlsZENvbnRleHRUeXBlcztcbiJdfQ==