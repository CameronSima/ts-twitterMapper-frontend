'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _mapState = require('../utils/map-state');

var _mapState2 = _interopRequireDefault(_mapState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EVENT HANDLING PARAMETERS
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var ZOOM_ACCEL = 0.01;

var SUBSCRIBED_EVENTS = ['panstart', 'panmove', 'panend', 'pinchstart', 'pinch', 'pinchend', 'doubletap', 'wheel'];

var MapControls = function () {
  /**
   * @classdesc
   * A class that handles events and updates mercator style viewport parameters
   */
  function MapControls() {
    _classCallCheck(this, MapControls);

    this.events = SUBSCRIBED_EVENTS;
    this._state = {
      isDragging: false
    };
  }

  /**
   * Callback for events
   * @param {hammer.Event} event
   */


  _createClass(MapControls, [{
    key: 'handleEvent',
    value: function handleEvent(event, options) {
      this.mapState = new _mapState2.default(Object.assign({}, options, this._state));
      this.setOptions(options);

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);
        case 'panmove':
          return this._onPan(event);
        case 'panend':
          return this._onPanEnd(event);
        case 'pinchstart':
          return this._onPinchStart(event);
        case 'pinch':
          return this._onPinch(event);
        case 'pinchend':
          return this._onPinchEnd(event);
        case 'doubletap':
          return this._onDoubleTap(event);
        case 'wheel':
          return this._onWheel(event);
        default:
          return false;
      }
    }

    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object

  }, {
    key: 'getCenter',
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: 'isFunctionKeyPressed',
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;

      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: 'setState',
    value: function setState(newState) {
      Object.assign(this._state, newState);
      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }

    /* Callback util */
    // formats map state and invokes callback function

  }, {
    key: 'updateViewport',
    value: function updateViewport(newMapState) {
      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var oldViewport = this.mapState.getViewportProps();
      var newViewport = newMapState.getViewportProps();

      if (this.onViewportChange && Object.keys(newViewport).some(function (key) {
        return oldViewport[key] !== newViewport[key];
      })) {
        // Viewport has changed
        this.onViewportChange(newViewport);
      }

      this.setState(Object.assign({}, newMapState.getInteractiveState(), extraState));
    }

    /**
     * Extract interactivity options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(_ref) {
      var onChangeViewport = _ref.onChangeViewport,
          onViewportChange = _ref.onViewportChange,
          onStateChange = _ref.onStateChange,
          _ref$scrollZoom = _ref.scrollZoom,
          scrollZoom = _ref$scrollZoom === undefined ? true : _ref$scrollZoom,
          _ref$dragPan = _ref.dragPan,
          dragPan = _ref$dragPan === undefined ? true : _ref$dragPan,
          _ref$dragRotate = _ref.dragRotate,
          dragRotate = _ref$dragRotate === undefined ? true : _ref$dragRotate,
          _ref$doubleClickZoom = _ref.doubleClickZoom,
          doubleClickZoom = _ref$doubleClickZoom === undefined ? true : _ref$doubleClickZoom,
          _ref$touchZoomRotate = _ref.touchZoomRotate,
          touchZoomRotate = _ref$touchZoomRotate === undefined ? true : _ref$touchZoomRotate;

      // TODO(deprecate): remove this check when `onChangeViewport` gets deprecated
      this.onViewportChange = onViewportChange || onChangeViewport;
      this.onStateChange = onStateChange;
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoomRotate = touchZoomRotate;
    }

    /* Event handlers */
    // Default handler for the `panstart` event.

  }, {
    key: '_onPanStart',
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      var newMapState = this.mapState.panStart({ pos: pos }).rotateStart({ pos: pos });
      return this.updateViewport(newMapState, { isDragging: true });
    }

    // Default handler for the `panmove` event.

  }, {
    key: '_onPan',
    value: function _onPan(event) {
      return this.isFunctionKeyPressed(event) ? this._onPanRotate(event) : this._onPanMove(event);
    }

    // Default handler for the `panend` event.

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(event) {
      var newMapState = this.mapState.panEnd().rotateEnd();
      return this.updateViewport(newMapState, { isDragging: false });
    }

    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.

  }, {
    key: '_onPanMove',
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newMapState = this.mapState.pan({ pos: pos });
      return this.updateViewport(newMapState);
    }

    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.

  }, {
    key: '_onPanRotate',
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _getCenter = this.getCenter(event),
          _getCenter2 = _slicedToArray(_getCenter, 2),
          centerY = _getCenter2[1];

      var startY = centerY - deltaY;

      var _mapState$getViewport = this.mapState.getViewportProps(),
          width = _mapState$getViewport.width,
          height = _mapState$getViewport.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to -1 as we drag upwards
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));

      var newMapState = this.mapState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `wheel` event.

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      event.srcEvent.preventDefault();

      var pos = this.getCenter(event);
      var delta = event.delta;

      // Map wheel delta to relative scale

      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newMapState = this.mapState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `pinchstart` event.

  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newMapState = this.mapState.zoomStart({ pos: pos });
      return this.updateViewport(newMapState, { isDragging: true });
    }

    // Default handler for the `pinch` event.

  }, {
    key: '_onPinch',
    value: function _onPinch(event) {
      if (!this.touchZoomRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var scale = event.scale;

      var newMapState = this.mapState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `pinchend` event.

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(event) {
      var newMapState = this.mapState.zoomEnd();
      return this.updateViewport(newMapState, { isDragging: false });
    }

    // Default handler for the `doubletap` event.

  }, {
    key: '_onDoubleTap',
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);

      var newMapState = this.mapState.zoom({ pos: pos, scale: isZoomOut ? 0.5 : 2 });
      return this.updateViewport(newMapState);
    }
  }]);

  return MapControls;
}();

exports.default = MapControls;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9tYXAtY29udHJvbHMuanMiXSwibmFtZXMiOlsiUElUQ0hfTU9VU0VfVEhSRVNIT0xEIiwiUElUQ0hfQUNDRUwiLCJaT09NX0FDQ0VMIiwiU1VCU0NSSUJFRF9FVkVOVFMiLCJNYXBDb250cm9scyIsImV2ZW50cyIsIl9zdGF0ZSIsImlzRHJhZ2dpbmciLCJldmVudCIsIm9wdGlvbnMiLCJtYXBTdGF0ZSIsIk9iamVjdCIsImFzc2lnbiIsInNldE9wdGlvbnMiLCJ0eXBlIiwiX29uUGFuU3RhcnQiLCJfb25QYW4iLCJfb25QYW5FbmQiLCJfb25QaW5jaFN0YXJ0IiwiX29uUGluY2giLCJfb25QaW5jaEVuZCIsIl9vbkRvdWJsZVRhcCIsIl9vbldoZWVsIiwib2Zmc2V0Q2VudGVyIiwieCIsInkiLCJzcmNFdmVudCIsIkJvb2xlYW4iLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwibmV3U3RhdGUiLCJvblN0YXRlQ2hhbmdlIiwibmV3TWFwU3RhdGUiLCJleHRyYVN0YXRlIiwib2xkVmlld3BvcnQiLCJnZXRWaWV3cG9ydFByb3BzIiwibmV3Vmlld3BvcnQiLCJvblZpZXdwb3J0Q2hhbmdlIiwia2V5cyIsInNvbWUiLCJrZXkiLCJzZXRTdGF0ZSIsImdldEludGVyYWN0aXZlU3RhdGUiLCJvbkNoYW5nZVZpZXdwb3J0Iiwic2Nyb2xsWm9vbSIsImRyYWdQYW4iLCJkcmFnUm90YXRlIiwiZG91YmxlQ2xpY2tab29tIiwidG91Y2hab29tUm90YXRlIiwicG9zIiwiZ2V0Q2VudGVyIiwicGFuU3RhcnQiLCJyb3RhdGVTdGFydCIsInVwZGF0ZVZpZXdwb3J0IiwiaXNGdW5jdGlvbktleVByZXNzZWQiLCJfb25QYW5Sb3RhdGUiLCJfb25QYW5Nb3ZlIiwicGFuRW5kIiwicm90YXRlRW5kIiwicGFuIiwiZGVsdGFYIiwiZGVsdGFZIiwiY2VudGVyWSIsInN0YXJ0WSIsIndpZHRoIiwiaGVpZ2h0IiwiZGVsdGFTY2FsZVgiLCJkZWx0YVNjYWxlWSIsIk1hdGgiLCJhYnMiLCJtaW4iLCJtYXgiLCJyb3RhdGUiLCJwcmV2ZW50RGVmYXVsdCIsImRlbHRhIiwic2NhbGUiLCJleHAiLCJ6b29tIiwiem9vbVN0YXJ0Iiwiem9vbUVuZCIsImlzWm9vbU91dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQUVBO0FBQ0EsSUFBTUEsd0JBQXdCLENBQTlCO0FBQ0EsSUFBTUMsY0FBYyxHQUFwQjtBQUNBLElBQU1DLGFBQWEsSUFBbkI7O0FBRUEsSUFBTUMsb0JBQW9CLENBQ3hCLFVBRHdCLEVBRXhCLFNBRndCLEVBR3hCLFFBSHdCLEVBSXhCLFlBSndCLEVBS3hCLE9BTHdCLEVBTXhCLFVBTndCLEVBT3hCLFdBUHdCLEVBUXhCLE9BUndCLENBQTFCOztJQVdxQkMsVztBQUNuQjs7OztBQUlBLHlCQUFjO0FBQUE7O0FBQ1osU0FBS0MsTUFBTCxHQUFjRixpQkFBZDtBQUNBLFNBQUtHLE1BQUwsR0FBYztBQUNaQyxrQkFBWTtBQURBLEtBQWQ7QUFHRDs7QUFFRDs7Ozs7Ozs7Z0NBSVlDLEssRUFBT0MsTyxFQUFTO0FBQzFCLFdBQUtDLFFBQUwsR0FBZ0IsdUJBQWFDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCSCxPQUFsQixFQUEyQixLQUFLSCxNQUFoQyxDQUFiLENBQWhCO0FBQ0EsV0FBS08sVUFBTCxDQUFnQkosT0FBaEI7O0FBRUEsY0FBUUQsTUFBTU0sSUFBZDtBQUNBLGFBQUssVUFBTDtBQUNFLGlCQUFPLEtBQUtDLFdBQUwsQ0FBaUJQLEtBQWpCLENBQVA7QUFDRixhQUFLLFNBQUw7QUFDRSxpQkFBTyxLQUFLUSxNQUFMLENBQVlSLEtBQVosQ0FBUDtBQUNGLGFBQUssUUFBTDtBQUNFLGlCQUFPLEtBQUtTLFNBQUwsQ0FBZVQsS0FBZixDQUFQ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QUFLMUIsY0FBTCxDQUFvQnJCLFdBQXBCLEVBQWlDLEVBQUMzQixZQUFZLEtBQWIsRUFBakMsQ0FBUDtBQUNEOztBQUVEOzs7O2lDQUNhQyxLLEVBQU87QUFDbEIsVUFBSSxDQUFDLEtBQUt5QyxlQUFWLEVBQTJCO0FBQ3pCLGVBQU8sS0FBUDtBQUNEO0FBQ0QsVUFBTUUsTUFBTSxLQUFLQyxTQUFMLENBQWU1QyxLQUFmLENBQVo7QUFDQSxVQUFNMEUsWUFBWSxLQUFLMUIsb0JBQUwsQ0FBMEJoRCxLQUExQixDQUFsQjs7QUFFQSxVQUFNMEIsY0FBYyxLQUFLeEIsUUFBTCxDQUFjcUUsSUFBZCxDQUFtQixFQUFDNUIsUUFBRCxFQUFNMEIsT0FBT0ssWUFBWSxHQUFaLEdBQWtCLENBQS9CLEVBQW5CLENBQXBCO0FBQ0EsYUFBTyxLQUFLM0IsY0FBTCxDQUFvQnJCLFdBQXBCLENBQVA7QUFDRDs7Ozs7O2tCQXpOa0I5QixXIiwiZmlsZSI6Im1hcC1jb250cm9scy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBNYXBTdGF0ZSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuXG4vLyBFVkVOVCBIQU5ETElORyBQQVJBTUVURVJTXG5jb25zdCBQSVRDSF9NT1VTRV9USFJFU0hPTEQgPSA1O1xuY29uc3QgUElUQ0hfQUNDRUwgPSAxLjI7XG5jb25zdCBaT09NX0FDQ0VMID0gMC4wMTtcblxuY29uc3QgU1VCU0NSSUJFRF9FVkVOVFMgPSBbXG4gICdwYW5zdGFydCcsXG4gICdwYW5tb3ZlJyxcbiAgJ3BhbmVuZCcsXG4gICdwaW5jaHN0YXJ0JyxcbiAgJ3BpbmNoJyxcbiAgJ3BpbmNoZW5kJyxcbiAgJ2RvdWJsZXRhcCcsXG4gICd3aGVlbCdcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgZXZlbnRzIGFuZCB1cGRhdGVzIG1lcmNhdG9yIHN0eWxlIHZpZXdwb3J0IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnRzID0gU1VCU0NSSUJFRF9FVkVOVFM7XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGV2ZW50c1xuICAgKiBAcGFyYW0ge2hhbW1lci5FdmVudH0gZXZlbnRcbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5tYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB0aGlzLl9zdGF0ZSkpO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgJ3BhbnN0YXJ0JzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBhblN0YXJ0KGV2ZW50KTtcbiAgICBjYXNlICdwYW5tb3ZlJzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBhbihldmVudCk7XG4gICAgY2FzZSAncGFuZW5kJzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBhbkVuZChldmVudCk7XG4gICAgY2FzZSAncGluY2hzdGFydCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaW5jaFN0YXJ0KGV2ZW50KTtcbiAgICBjYXNlICdwaW5jaCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaW5jaChldmVudCk7XG4gICAgY2FzZSAncGluY2hlbmQnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hFbmQoZXZlbnQpO1xuICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25Eb3VibGVUYXAoZXZlbnQpO1xuICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgIHJldHVybiB0aGlzLl9vbldoZWVsKGV2ZW50KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qIEV2ZW50IHV0aWxzICovXG4gIC8vIEV2ZW50IG9iamVjdDogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9hcGkvI2V2ZW50LW9iamVjdFxuICBnZXRDZW50ZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7b2Zmc2V0Q2VudGVyOiB7eCwgeX19ID0gZXZlbnQ7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIGlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB7XG4gICAgY29uc3Qge3NyY0V2ZW50fSA9IGV2ZW50O1xuICAgIHJldHVybiBCb29sZWFuKHNyY0V2ZW50Lm1ldGFLZXkgfHwgc3JjRXZlbnQuYWx0S2V5IHx8XG4gICAgICBzcmNFdmVudC5jdHJsS2V5IHx8IHNyY0V2ZW50LnNoaWZ0S2V5KTtcbiAgfVxuXG4gIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0ZSwgbmV3U3RhdGUpO1xuICAgIGlmICh0aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2FsbGJhY2sgdXRpbCAqL1xuICAvLyBmb3JtYXRzIG1hcCBzdGF0ZSBhbmQgaW52b2tlcyBjYWxsYmFjayBmdW5jdGlvblxuICB1cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgZXh0cmFTdGF0ZSA9IHt9KSB7XG4gICAgY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLm1hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcbiAgICBjb25zdCBuZXdWaWV3cG9ydCA9IG5ld01hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcblxuICAgIGlmICh0aGlzLm9uVmlld3BvcnRDaGFuZ2UgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5ld1ZpZXdwb3J0KS5zb21lKGtleSA9PiBvbGRWaWV3cG9ydFtrZXldICE9PSBuZXdWaWV3cG9ydFtrZXldKSkge1xuICAgICAgLy8gVmlld3BvcnQgaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMub25WaWV3cG9ydENoYW5nZShuZXdWaWV3cG9ydCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBuZXdNYXBTdGF0ZS5nZXRJbnRlcmFjdGl2ZVN0YXRlKCksIGV4dHJhU3RhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGludGVyYWN0aXZpdHkgb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyh7XG4gICAgLy8gVE9ETyhkZXByZWNhdGUpOiByZW1vdmUgdGhpcyB3aGVuIGBvbkNoYW5nZVZpZXdwb3J0YCBnZXRzIGRlcHJlY2F0ZWRcbiAgICBvbkNoYW5nZVZpZXdwb3J0LFxuICAgIG9uVmlld3BvcnRDaGFuZ2UsXG4gICAgb25TdGF0ZUNoYW5nZSxcbiAgICBzY3JvbGxab29tID0gdHJ1ZSxcbiAgICBkcmFnUGFuID0gdHJ1ZSxcbiAgICBkcmFnUm90YXRlID0gdHJ1ZSxcbiAgICBkb3VibGVDbGlja1pvb20gPSB0cnVlLFxuICAgIHRvdWNoWm9vbVJvdGF0ZSA9IHRydWVcbiAgfSkge1xuICAgIC8vIFRPRE8oZGVwcmVjYXRlKTogcmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgb25DaGFuZ2VWaWV3cG9ydGAgZ2V0cyBkZXByZWNhdGVkXG4gICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlID0gb25WaWV3cG9ydENoYW5nZSB8fCBvbkNoYW5nZVZpZXdwb3J0O1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgdGhpcy5zY3JvbGxab29tID0gc2Nyb2xsWm9vbTtcbiAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgIHRoaXMuZHJhZ1JvdGF0ZSA9IGRyYWdSb3RhdGU7XG4gICAgdGhpcy5kb3VibGVDbGlja1pvb20gPSBkb3VibGVDbGlja1pvb207XG4gICAgdGhpcy50b3VjaFpvb21Sb3RhdGUgPSB0b3VjaFpvb21Sb3RhdGU7XG4gIH1cblxuICAvKiBFdmVudCBoYW5kbGVycyAqL1xuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGFuc3RhcnRgIGV2ZW50LlxuICBfb25QYW5TdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuU3RhcnQoe3Bvc30pLnJvdGF0ZVN0YXJ0KHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5tb3ZlYCBldmVudC5cbiAgX29uUGFuKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpID8gdGhpcy5fb25QYW5Sb3RhdGUoZXZlbnQpIDogdGhpcy5fb25QYW5Nb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5lbmRgIGV2ZW50LlxuICBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuRW5kKCkucm90YXRlRW5kKCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciBwYW5uaW5nIHRvIG1vdmUuXG4gIC8vIENhbGxlZCBieSBgX29uUGFuYCB3aGVuIHBhbm5pbmcgd2l0aG91dCBmdW5jdGlvbiBrZXkgcHJlc3NlZC5cbiAgX29uUGFuTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUGFuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHBhbm5pbmcgdG8gcm90YXRlLlxuICAvLyBDYWxsZWQgYnkgYF9vblBhbmAgd2hlbiBwYW5uaW5nIHdpdGggZnVuY3Rpb24ga2V5IHByZXNzZWQuXG4gIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge2RlbHRhWCwgZGVsdGFZfSA9IGV2ZW50O1xuICAgIGNvbnN0IFssIGNlbnRlclldID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGNlbnRlclkgLSBkZWx0YVk7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5tYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG5cbiAgICBjb25zdCBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgIGxldCBkZWx0YVNjYWxlWSA9IDA7XG5cbiAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIHN0YXJ0WSkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gLTEgYXMgd2UgZHJhZyB1cHdhcmRzXG4gICAgICAgIGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gKHN0YXJ0WSAtIGhlaWdodCkgKiBQSVRDSF9BQ0NFTDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRlbHRhWSA8IDApIHtcbiAgICAgIGlmIChzdGFydFkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgZGVsdGFTY2FsZVkgPSAxIC0gY2VudGVyWSAvIHN0YXJ0WTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsdGFTY2FsZVkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgtMSwgZGVsdGFTY2FsZVkpKTtcblxuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGB3aGVlbGAgZXZlbnQuXG4gIF9vbldoZWVsKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbFpvb20pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXZlbnQuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCB7ZGVsdGF9ID0gZXZlbnQ7XG5cbiAgICAvLyBNYXAgd2hlZWwgZGVsdGEgdG8gcmVsYXRpdmUgc2NhbGVcbiAgICBsZXQgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZGVsdGEgKiBaT09NX0FDQ0VMKSkpO1xuICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHtcbiAgICAgIHNjYWxlID0gMSAvIHNjYWxlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tKHtwb3MsIHNjYWxlfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBpbmNoc3RhcnRgIGV2ZW50LlxuICBfb25QaW5jaFN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tU3RhcnQoe3Bvc30pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCB7aXNEcmFnZ2luZzogdHJ1ZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBpbmNoYCBldmVudC5cbiAgX29uUGluY2goZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMudG91Y2hab29tUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCB7c2NhbGV9ID0gZXZlbnQ7XG4gICAgY29uc3QgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb20oe3Bvcywgc2NhbGV9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGluY2hlbmRgIGV2ZW50LlxuICBfb25QaW5jaEVuZChldmVudCkge1xuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tRW5kKCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYGRvdWJsZXRhcGAgZXZlbnQuXG4gIF9vbkRvdWJsZVRhcChldmVudCkge1xuICAgIGlmICghdGhpcy5kb3VibGVDbGlja1pvb20pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IGlzWm9vbU91dCA9IHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpO1xuXG4gICAgY29uc3QgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb20oe3Bvcywgc2NhbGU6IGlzWm9vbU91dCA/IDAuNSA6IDJ9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSk7XG4gIH1cbn1cbiJdfQ==