'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobind = require('../utils/autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _viewportMercatorProject = require('viewport-mercator-project');

var _mapState = require('../utils/map-state');

var _mapState2 = _interopRequireDefault(_mapState);

var _deprecateWarn = require('../utils/deprecate-warn');

var _deprecateWarn2 = _interopRequireDefault(_deprecateWarn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
  /**
    * `onViewportChange` callback is fired when the user interacted with the
    * map. The object passed to the callback contains `latitude`,
    * `longitude` and `zoom` and additional state information.
    */
  onViewportChange: _propTypes2.default.func.isRequired
};

var defaultProps = {
  onViewportChange: function onViewportChange() {}
};

var contextTypes = {
  viewport: _propTypes2.default.instanceOf(_viewportMercatorProject.PerspectiveMercatorViewport)
};

/*
 * PureComponent doesn't update when context changes, so
 * implementing our own shouldComponentUpdate here.
 */

var NavigationControl = function (_Component) {
  _inherits(NavigationControl, _Component);

  function NavigationControl(props) {
    _classCallCheck(this, NavigationControl);

    var _this = _possibleConstructorReturn(this, (NavigationControl.__proto__ || Object.getPrototypeOf(NavigationControl)).call(this, props));

    (0, _autobind2.default)(_this);
    // Check for deprecated props
    (0, _deprecateWarn2.default)(props);
    return _this;
  }

  _createClass(NavigationControl, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
      return this.context.viewport.bearing !== nextContext.viewport.bearing;
    }
  }, {
    key: '_updateViewport',
    value: function _updateViewport(opts) {
      var viewport = this.context.viewport;

      var mapState = new _mapState2.default(Object.assign({}, viewport, opts));
      // TODO(deprecate): remove this check when `onChangeViewport` gets deprecated
      var onViewportChange = this.props.onChangeViewport || this.props.onViewportChange;
      onViewportChange(mapState.getViewportProps());
    }
  }, {
    key: '_onZoomIn',
    value: function _onZoomIn() {
      this._updateViewport({ zoom: this.context.viewport.zoom + 1 });
    }
  }, {
    key: '_onZoomOut',
    value: function _onZoomOut() {
      this._updateViewport({ zoom: this.context.viewport.zoom - 1 });
    }
  }, {
    key: '_onResetNorth',
    value: function _onResetNorth() {
      this._updateViewport({ bearing: 0 });
    }
  }, {
    key: '_renderCompass',
    value: function _renderCompass() {
      var bearing = this.context.viewport.bearing;

      return (0, _react.createElement)('span', {
        className: 'mapboxgl-ctrl-compass-arrow',
        style: { transform: 'rotate(' + bearing + 'deg)' }
      });
    }
  }, {
    key: '_renderButton',
    value: function _renderButton(type, label, callback, children) {
      return (0, _react.createElement)('button', {
        key: type,
        className: 'mapboxgl-ctrl-icon mapboxgl-ctrl-' + type,
        type: 'button',
        title: label,
        onClick: callback,
        children: children
      });
    }
  }, {
    key: 'render',
    value: function render() {
      return (0, _react.createElement)('div', {
        className: 'mapboxgl-ctrl mapboxgl-ctrl-group'
      }, [this._renderButton('zoom-in', 'Zoom In', this._onZoomIn), this._renderButton('zoom-out', 'Zoom Out', this._onZoomOut), this._renderButton('compass', 'Reset North', this._onResetNorth, this._renderCompass())]);
    }
  }]);

  return NavigationControl;
}(_react.Component);

exports.default = NavigationControl;


NavigationControl.displayName = 'NavigationControl';
NavigationControl.propTypes = propTypes;
NavigationControl.defaultProps = defaultProps;
NavigationControl.contextTypes = contextTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL25hdmlnYXRpb24tY29udHJvbC5qcyJdLCJuYW1lcyI6WyJwcm9wVHlwZXMiLCJvblZpZXdwb3J0Q2hhbmdlIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJkZWZhdWx0UHJvcHMiLCJjb250ZXh0VHlwZXMiLCJ2aWV3cG9ydCIsImluc3RhbmNlT2YiLCJOYXZpZ2F0aW9uQ29udHJvbCIsInByb3BzIiwibmV4dFByb3BzIiwibmV4dFN0YXRlIiwibmV4dENvbnRleHQiLCJjb250ZXh0IiwiYmVhcmluZyIsIm9wdHMiLCJtYXBTdGF0ZSIsIk9iamVjdCIsImFzc2lnbiIsIm9uQ2hhbmdlVmlld3BvcnQiLCJnZXRWaWV3cG9ydFByb3BzIiwiX3VwZGF0ZVZpZXdwb3J0Iiwiem9vbSIsImNsYXNzTmFtZSIsInN0eWxlIiwidHJhbnNmb3JtIiwidHlwZSIsImxhYmVsIiwiY2FsbGJhY2siLCJjaGlsZHJlbiIsImtleSIsInRpdGxlIiwib25DbGljayIsIl9yZW5kZXJCdXR0b24iLCJfb25ab29tSW4iLCJfb25ab29tT3V0IiwiX29uUmVzZXROb3J0aCIsIl9yZW5kZXJDb21wYXNzIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFlBQVk7QUFDaEI7Ozs7O0FBS0FDLG9CQUFrQixvQkFBVUMsSUFBVixDQUFlQztBQU5qQixDQUFsQjs7QUFTQSxJQUFNQyxlQUFlO0FBQ25CSCxvQkFBa0IsNEJBQU0sQ0FBRTtBQURQLENBQXJCOztBQUlBLElBQU1JLGVBQWU7QUFDbkJDLFlBQVUsb0JBQVVDLFVBQVY7QUFEUyxDQUFyQjs7QUFJQTs7Ozs7SUFJcUJDLGlCOzs7QUFFbkIsNkJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxzSUFDWEEsS0FEVzs7QUFFakI7QUFDQTtBQUNBLGlDQUFjQSxLQUFkO0FBSmlCO0FBS2xCOzs7OzBDQUVxQkMsUyxFQUFXQyxTLEVBQVdDLFcsRUFBYTtBQUN2RCxhQUFPLEtBQUtDLE9BQUwsQ0FBYVAsUUFBYixDQUFzQlEsT0FBdEIsS0FBa0NGLFlBQVlOLFFBQVosQ0FBcUJRLE9BQTlEO0FBQ0Q7OztvQ0FFZUMsSSxFQUFNO0FBQUEsVUFDYlQsUUFEYSxHQUNELEtBQUtPLE9BREosQ0FDYlAsUUFEYTs7QUFFcEIsVUFBTVUsV0FBVyx1QkFBYUMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JaLFFBQWxCLEVBQTRCUyxJQUE1QixDQUFiLENBQWpCO0FBQ0E7QUFDQSxVQUFNZCxtQkFBbUIsS0FBS1EsS0FBTCxDQUFXVSxnQkFBWCxJQUErQixLQUFLVixLQUFMLENBQVdSLGdCQUFuRTtBQUNBQSx1QkFBaUJlLFNBQVNJLGdCQUFULEVBQWpCO0FBQ0Q7OztnQ0FFVztBQUNWLFdBQUtDLGVBQUwsQ0FBcUIsRUFBQ0MsTUFBTSxLQUFLVCxPQUFMLENBQWFQLFFBQWIsQ0FBc0JnQixJQUF0QixHQUE2QixDQUFwQyxFQUFyQjtBQUNEOzs7aUNBRVk7QUFDWCxXQUFLRCxlQUFMLENBQXFCLEVBQUNDLE1BQU0sS0FBS1QsT0FBTCxDQUFhUCxRQUFiLENBQXNCZ0IsSUFBdEIsR0FBNkIsQ0FBcEMsRUFBckI7QUFDRDs7O29DQUVlO0FBQ2QsV0FBS0QsZUFBTCxDQUFxQixFQUFDUCxTQUFTLENBQVYsRUFBckI7QUFDRDs7O3FDQUVnQjtBQUFBLFVBQ1JBLE9BRFEsR0FDRyxLQUFLRCxPQUFMLENBQWFQLFFBRGhCLENBQ1JRLE9BRFE7O0FBRWYsYUFBTywwQkFBYyxNQUFkLEVBQXNCO0FBQzNCUyxtQkFBVyw2QkFEZ0I7QUFFM0JDLGVBQU8sRUFBQ0MsdUJBQXFCWCxPQUFyQixTQUFEO0FBRm9CLE9BQXRCLENBQVA7QUFJRDs7O2tDQUVhWSxJLEVBQU1DLEssRUFBT0MsUSxFQUFVQyxRLEVBQVU7QUFDN0MsYUFBTywwQkFBYyxRQUFkLEVBQXdCO0FBQzdCQyxhQUFLSixJQUR3QjtBQUU3QkgseURBQStDRyxJQUZsQjtBQUc3QkEsY0FBTSxRQUh1QjtBQUk3QkssZUFBT0osS0FKc0I7QUFLN0JLLGlCQUFTSixRQUxvQjtBQU03QkM7QUFONkIsT0FBeEIsQ0FBUDtBQVFEOzs7NkJBRVE7QUFDUCxhQUFPLDBCQUFjLEtBQWQsRUFBcUI7QUFDMUJOLG1CQUFXO0FBRGUsT0FBckIsRUFFSixDQUNELEtBQUtVLGFBQUwsQ0FBbUIsU0FBbkIsRUFBOEIsU0FBOUIsRUFBeUMsS0FBS0MsU0FBOUMsQ0FEQyxFQUVELEtBQUtELGFBQUwsQ0FBbUIsVUFBbkIsRUFBK0IsVUFBL0IsRUFBMkMsS0FBS0UsVUFBaEQsQ0FGQyxFQUdELEtBQUtGLGFBQUwsQ0FBbUIsU0FBbkIsRUFBOEIsYUFBOUIsRUFBNkMsS0FBS0csYUFBbEQsRUFBaUUsS0FBS0MsY0FBTCxFQUFqRSxDQUhDLENBRkksQ0FBUDtBQU9EOzs7Ozs7a0JBNURrQjdCLGlCOzs7QUErRHJCQSxrQkFBa0I4QixXQUFsQixHQUFnQyxtQkFBaEM7QUFDQTlCLGtCQUFrQlIsU0FBbEIsR0FBOEJBLFNBQTlCO0FBQ0FRLGtCQUFrQkosWUFBbEIsR0FBaUNBLFlBQWpDO0FBQ0FJLGtCQUFrQkgsWUFBbEIsR0FBaUNBLFlBQWpDIiwiZmlsZSI6Im5hdmlnYXRpb24tY29udHJvbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4uL3V0aWxzL2F1dG9iaW5kJztcblxuaW1wb3J0IHtQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnR9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5cbmltcG9ydCBkZXByZWNhdGVXYXJuIGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZS13YXJuJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICAvKipcbiAgICAqIGBvblZpZXdwb3J0Q2hhbmdlYCBjYWxsYmFjayBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGVcbiAgICAqIG1hcC4gVGhlIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGNvbnRhaW5zIGBsYXRpdHVkZWAsXG4gICAgKiBgbG9uZ2l0dWRlYCBhbmQgYHpvb21gIGFuZCBhZGRpdGlvbmFsIHN0YXRlIGluZm9ybWF0aW9uLlxuICAgICovXG4gIG9uVmlld3BvcnRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgb25WaWV3cG9ydENoYW5nZTogKCkgPT4ge31cbn07XG5cbmNvbnN0IGNvbnRleHRUeXBlcyA9IHtcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydClcbn07XG5cbi8qXG4gKiBQdXJlQ29tcG9uZW50IGRvZXNuJ3QgdXBkYXRlIHdoZW4gY29udGV4dCBjaGFuZ2VzLCBzb1xuICogaW1wbGVtZW50aW5nIG91ciBvd24gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGhlcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25Db250cm9sIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgICAvLyBDaGVjayBmb3IgZGVwcmVjYXRlZCBwcm9wc1xuICAgIGRlcHJlY2F0ZVdhcm4ocHJvcHMpO1xuICB9XG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQudmlld3BvcnQuYmVhcmluZyAhPT0gbmV4dENvbnRleHQudmlld3BvcnQuYmVhcmluZztcbiAgfVxuXG4gIF91cGRhdGVWaWV3cG9ydChvcHRzKSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB2aWV3cG9ydCwgb3B0cykpO1xuICAgIC8vIFRPRE8oZGVwcmVjYXRlKTogcmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgb25DaGFuZ2VWaWV3cG9ydGAgZ2V0cyBkZXByZWNhdGVkXG4gICAgY29uc3Qgb25WaWV3cG9ydENoYW5nZSA9IHRoaXMucHJvcHMub25DaGFuZ2VWaWV3cG9ydCB8fCB0aGlzLnByb3BzLm9uVmlld3BvcnRDaGFuZ2U7XG4gICAgb25WaWV3cG9ydENoYW5nZShtYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCkpO1xuICB9XG5cbiAgX29uWm9vbUluKCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpZXdwb3J0KHt6b29tOiB0aGlzLmNvbnRleHQudmlld3BvcnQuem9vbSArIDF9KTtcbiAgfVxuXG4gIF9vblpvb21PdXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe3pvb206IHRoaXMuY29udGV4dC52aWV3cG9ydC56b29tIC0gMX0pO1xuICB9XG5cbiAgX29uUmVzZXROb3J0aCgpIHtcbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7YmVhcmluZzogMH0pO1xuICB9XG5cbiAgX3JlbmRlckNvbXBhc3MoKSB7XG4gICAgY29uc3Qge2JlYXJpbmd9ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAnbWFwYm94Z2wtY3RybC1jb21wYXNzLWFycm93JyxcbiAgICAgIHN0eWxlOiB7dHJhbnNmb3JtOiBgcm90YXRlKCR7YmVhcmluZ31kZWcpYH1cbiAgICB9KTtcbiAgfVxuXG4gIF9yZW5kZXJCdXR0b24odHlwZSwgbGFiZWwsIGNhbGxiYWNrLCBjaGlsZHJlbikge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdidXR0b24nLCB7XG4gICAgICBrZXk6IHR5cGUsXG4gICAgICBjbGFzc05hbWU6IGBtYXBib3hnbC1jdHJsLWljb24gbWFwYm94Z2wtY3RybC0ke3R5cGV9YCxcbiAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgdGl0bGU6IGxhYmVsLFxuICAgICAgb25DbGljazogY2FsbGJhY2ssXG4gICAgICBjaGlsZHJlblxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXAnXG4gICAgfSwgW1xuICAgICAgdGhpcy5fcmVuZGVyQnV0dG9uKCd6b29tLWluJywgJ1pvb20gSW4nLCB0aGlzLl9vblpvb21JbiksXG4gICAgICB0aGlzLl9yZW5kZXJCdXR0b24oJ3pvb20tb3V0JywgJ1pvb20gT3V0JywgdGhpcy5fb25ab29tT3V0KSxcbiAgICAgIHRoaXMuX3JlbmRlckJ1dHRvbignY29tcGFzcycsICdSZXNldCBOb3J0aCcsIHRoaXMuX29uUmVzZXROb3J0aCwgdGhpcy5fcmVuZGVyQ29tcGFzcygpKVxuICAgIF0pO1xuICB9XG59XG5cbk5hdmlnYXRpb25Db250cm9sLmRpc3BsYXlOYW1lID0gJ05hdmlnYXRpb25Db250cm9sJztcbk5hdmlnYXRpb25Db250cm9sLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbk5hdmlnYXRpb25Db250cm9sLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbk5hdmlnYXRpb25Db250cm9sLmNvbnRleHRUeXBlcyA9IGNvbnRleHRUeXBlcztcbiJdfQ==