'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = require('../../lib/utils/globals');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ua = typeof _globals.window.navigator !== 'undefined' ? _globals.window.navigator.userAgent.toLowerCase() : '';
var firefox = ua.indexOf('firefox') !== -1;

var WHEEL_EVENTS = [
// Chrome, Safari
'wheel',
// IE
'mousewheel',
// legacy Firefox
'DOMMouseScroll'];
var EVENT_TYPE = 'wheel';

// Constants for normalizing input delta
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var TRACKPAD_MAX_DELTA = 4;
var TRACKPAD_MAX_DELTA_PER_TIME = 200;
// Slow down zoom if shift key is held for more precise zooming
var SHIFT_MULTIPLIER = 0.25;

var WheelInput = function () {
  function WheelInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, WheelInput);

    this.element = element;
    this.callback = callback;

    var events = WHEEL_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.time = 0;
    this.wheelPosition = null;
    this.type = null;
    this.timeout = null;
    this.lastValue = 0;

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(WheelInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'enableIfEventSupported',
    value: function enableIfEventSupported(eventType) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = true;
      }
    }

    /* eslint-disable complexity, max-statements */

  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      var value = event.deltaY;
      if (_globals.window.WheelEvent) {
        // Firefox doubles the values on retina screens...
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }
        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }

      var type = this.type,
          timeout = this.timeout,
          lastValue = this.lastValue,
          time = this.time;


      var now = (_globals.window && _globals.window.performance || Date).now();
      var timeDelta = now - (time || 0);

      this.wheelPosition = {
        x: event.clientX,
        y: event.clientY
      };
      time = now;

      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        type = 'wheel';
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      } else if (value !== 0 && Math.abs(value) < TRACKPAD_MAX_DELTA) {
        // This one is definitely a trackpad event because it is so small.
        type = 'trackpad';
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        type = null;
        lastValue = value;
        // Start a timeout in case this was a singular event,
        // and delay it by up to 40ms.
        timeout = _globals.window.setTimeout(function setTimeout() {
          this._onWheel(event, -lastValue, this.wheelPosition);
          type = 'wheel';
        }.bind(this), 40);
      } else if (!type) {
        // This is a repeating event, but we don't know the type of event just yet.
        // If the delta per time is small, we assume it's a fast trackpad;
        // otherwise we switch into wheel mode.
        type = Math.abs(timeDelta * value) < TRACKPAD_MAX_DELTA_PER_TIME ? 'trackpad' : 'wheel';

        // Make sure our delayed event isn't fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (timeout) {
          _globals.window.clearTimeout(timeout);
          timeout = null;
          value += lastValue;
        }
      }

      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }

      // Only fire the callback if we actually know
      // what type of scrolling device the user uses.
      if (type) {
        this._onWheel(event, -value, this.wheelPosition);
      }
    }
  }, {
    key: '_onWheel',
    value: function _onWheel(srcEvent, delta, position) {
      this.callback({
        type: EVENT_TYPE,
        center: position,
        delta: delta,
        srcEvent: srcEvent,
        pointerType: 'mouse',
        target: srcEvent.target
      });
    }
  }]);

  return WheelInput;
}();

exports.default = WheelInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvd2hlZWwtaW5wdXQuanMiXSwibmFtZXMiOlsidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsImZpcmVmb3giLCJpbmRleE9mIiwiV0hFRUxfRVZFTlRTIiwiRVZFTlRfVFlQRSIsIldIRUVMX0RFTFRBX01BR0lDX1NDQUxFUiIsIldIRUVMX0RFTFRBX1BFUl9MSU5FIiwiVFJBQ0tQQURfTUFYX0RFTFRBIiwiVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FIiwiU0hJRlRfTVVMVElQTElFUiIsIldoZWVsSW5wdXQiLCJlbGVtZW50IiwiY2FsbGJhY2siLCJvcHRpb25zIiwiZXZlbnRzIiwiY29uY2F0IiwiT2JqZWN0IiwiYXNzaWduIiwiZW5hYmxlIiwidGltZSIsIndoZWVsUG9zaXRpb24iLCJ0eXBlIiwidGltZW91dCIsImxhc3RWYWx1ZSIsImhhbmRsZUV2ZW50IiwiYmluZCIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnRUeXBlIiwidmFsdWUiLCJkZWx0YVkiLCJXaGVlbEV2ZW50IiwiZGVsdGFNb2RlIiwiRE9NX0RFTFRBX1BJWEVMIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkRPTV9ERUxUQV9MSU5FIiwibm93IiwicGVyZm9ybWFuY2UiLCJEYXRlIiwidGltZURlbHRhIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsIk1hdGgiLCJmbG9vciIsImFicyIsInNldFRpbWVvdXQiLCJfb25XaGVlbCIsImNsZWFyVGltZW91dCIsInNoaWZ0S2V5Iiwic3JjRXZlbnQiLCJkZWx0YSIsInBvc2l0aW9uIiwiY2VudGVyIiwicG9pbnRlclR5cGUiLCJ0YXJnZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQSxJQUFNQSxLQUFLLE9BQU8sZ0JBQU9DLFNBQWQsS0FBNEIsV0FBNUIsR0FDVCxnQkFB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QU82QixZQUFQLENBQW9CN0IsT0FBcEI7QUFDQUEsb0JBQVUsSUFBVjtBQUNBUyxtQkFBU1IsU0FBVDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSUssTUFBTXdCLFFBQU4sSUFBa0JyQixLQUF0QixFQUE2QjtBQUMzQkEsZ0JBQVFBLFFBQVF0QixnQkFBaEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFBSVksSUFBSixFQUFVO0FBQ1IsYUFBSzZCLFFBQUwsQ0FBY3RCLEtBQWQsRUFBcUIsQ0FBQ0csS0FBdEIsRUFBNkIsS0FBS1gsYUFBbEM7QUFDRDtBQUNGOzs7NkJBRVFpQyxRLEVBQVVDLEssRUFBT0MsUSxFQUFVO0FBQ2xDLFdBQUszQyxRQUFMLENBQWM7QUFDWlMsY0FBTWpCLFVBRE07QUFFWm9ELGdCQUFRRCxRQUZJO0FBR1pELG9CQUhZO0FBSVpELDBCQUpZO0FBS1pJLHFCQUFhLE9BTEQ7QUFNWkMsZ0JBQVFMLFNBQVNLO0FBTkwsT0FBZDtBQVFEOzs7Ozs7a0JBM0hrQmhELFUiLCJmaWxlIjoid2hlZWwtaW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3dpbmRvd30gZnJvbSAnLi4vLi4vbGliL3V0aWxzL2dsb2JhbHMnO1xuXG5jb25zdCB1YSA9IHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbmNvbnN0IGZpcmVmb3ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuXG5jb25zdCBXSEVFTF9FVkVOVFMgPSBbXG4gIC8vIENocm9tZSwgU2FmYXJpXG4gICd3aGVlbCcsXG4gIC8vIElFXG4gICdtb3VzZXdoZWVsJyxcbiAgLy8gbGVnYWN5IEZpcmVmb3hcbiAgJ0RPTU1vdXNlU2Nyb2xsJ1xuXTtcbmNvbnN0IEVWRU5UX1RZUEUgPSAnd2hlZWwnO1xuXG4vLyBDb25zdGFudHMgZm9yIG5vcm1hbGl6aW5nIGlucHV0IGRlbHRhXG5jb25zdCBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbmNvbnN0IFdIRUVMX0RFTFRBX1BFUl9MSU5FID0gNDA7XG5jb25zdCBUUkFDS1BBRF9NQVhfREVMVEEgPSA0O1xuY29uc3QgVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FID0gMjAwO1xuLy8gU2xvdyBkb3duIHpvb20gaWYgc2hpZnQga2V5IGlzIGhlbGQgZm9yIG1vcmUgcHJlY2lzZSB6b29taW5nXG5jb25zdCBTSElGVF9NVUxUSVBMSUVSID0gMC4yNTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hlZWxJbnB1dCB7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgY29uc3QgZXZlbnRzID0gV0hFRUxfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7ZW5hYmxlOiB0cnVlfSwgb3B0aW9ucywge2V2ZW50c30pO1xuXG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLndoZWVsUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IDA7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucy5ldmVudHMuZm9yRWFjaChldmVudCA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBzZXQob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVJZkV2ZW50U3VwcG9ydGVkKGV2ZW50VHlwZSkge1xuICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlID0gZXZlbnQuZGVsdGFZO1xuICAgIGlmICh3aW5kb3cuV2hlZWxFdmVudCkge1xuICAgICAgLy8gRmlyZWZveCBkb3VibGVzIHRoZSB2YWx1ZXMgb24gcmV0aW5hIHNjcmVlbnMuLi5cbiAgICAgIGlmIChmaXJlZm94ICYmIGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgdmFsdWUgKj0gV0hFRUxfREVMVEFfUEVSX0xJTkU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lb3V0LFxuICAgICAgbGFzdFZhbHVlLFxuICAgICAgdGltZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgbm93ID0gKCh3aW5kb3cgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB8fCBEYXRlKS5ub3coKTtcbiAgICBjb25zdCB0aW1lRGVsdGEgPSBub3cgLSAodGltZSB8fCAwKTtcblxuICAgIHRoaXMud2hlZWxQb3NpdGlvbiA9IHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgICB0aW1lID0gbm93O1xuXG4gICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwICYmIE1hdGguYWJzKHZhbHVlKSA8IFRSQUNLUEFEX01BWF9ERUxUQSkge1xuICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXG4gICAgICB0eXBlID0gJ3RyYWNrcGFkJztcbiAgICB9IGVsc2UgaWYgKHRpbWVEZWx0YSA+IDQwMCkge1xuICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBTdGFydCBhIHRpbWVvdXQgaW4gY2FzZSB0aGlzIHdhcyBhIHNpbmd1bGFyIGV2ZW50LFxuICAgICAgLy8gYW5kIGRlbGF5IGl0IGJ5IHVwIHRvIDQwbXMuXG4gICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gc2V0VGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5fb25XaGVlbChldmVudCwgLWxhc3RWYWx1ZSwgdGhpcy53aGVlbFBvc2l0aW9uKTtcbiAgICAgICAgdHlwZSA9ICd3aGVlbCc7XG4gICAgICB9LmJpbmQodGhpcyksIDQwKTtcbiAgICB9IGVsc2UgaWYgKCF0eXBlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0IHlldC5cbiAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkO1xuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHN3aXRjaCBpbnRvIHdoZWVsIG1vZGUuXG4gICAgICB0eXBlID0gTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FID8gJ3RyYWNrcGFkJyA6ICd3aGVlbCc7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgZGVsYXllZCBldmVudCBpc24ndCBmaXJlZCBhZ2FpbiwgYmVjYXVzZSB3ZSBhY2N1bXVsYXRlXG4gICAgICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG8gdGhpcyBldmVudC5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YWx1ZSArPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogU0hJRlRfTVVMVElQTElFUjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGZpcmUgdGhlIGNhbGxiYWNrIGlmIHdlIGFjdHVhbGx5IGtub3dcbiAgICAvLyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzLl9vbldoZWVsKGV2ZW50LCAtdmFsdWUsIHRoaXMud2hlZWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgX29uV2hlZWwoc3JjRXZlbnQsIGRlbHRhLCBwb3NpdGlvbikge1xuICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgIGNlbnRlcjogcG9zaXRpb24sXG4gICAgICBkZWx0YSxcbiAgICAgIHNyY0V2ZW50LFxuICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICB0YXJnZXQ6IHNyY0V2ZW50LnRhcmdldFxuICAgIH0pO1xuICB9XG59XG4iXX0=