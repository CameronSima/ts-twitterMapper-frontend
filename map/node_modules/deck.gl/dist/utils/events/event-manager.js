'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _wheelInput = require('./wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _globals = require('../../controllers/globals');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Hammer.js directly references `document` and `window`,
// which means that importing it in environments without
// those objects throws errors. Therefore, instead of
// directly `import`ing 'hammerjs' and './constants'
// (which imports Hammer.js) we conditionally require it
// depending on support for those globals, and provide mocks
// for environments without `document`/`window`.
function ManagerMock(m) {
  var instance = {};
  var chainedNoop = function chainedNoop() {
    return instance;
  };
  instance.on = chainedNoop;
  instance.off = chainedNoop;
  instance.destroy = chainedNoop;
  instance.emit = chainedNoop;
  return instance;
}

var Manager = _globals.isBrowser ? require('hammerjs').Manager : ManagerMock;

var _ref = _globals.isBrowser ? require('./constants') : {
  BASIC_EVENT_ALIASES: {},
  EVENT_RECOGNIZER_MAP: {},
  GESTURE_EVENT_ALIASES: {}
},
    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,
    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,
    RECOGNIZERS = _ref.RECOGNIZERS,
    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;

/**
 * Single API for subscribing to events about both
 * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
 * and gestural input (e.g. 'click', 'tap', 'panstart').
 * Delegates event registration and handling to Hammer.js.
 * @param {DOM Element} element         DOM element on which event handlers will be registered.
 * @param {Object} options              Options for instantiation
 * @param {Object} options.events       Map of {event name: handler} to register on init.
 * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register,
 *                                      as an Array in Hammer.Recognizer format.
 *                                      (http://hammerjs.github.io/api/#hammermanager)
 */


var EventManager = function () {
  function EventManager(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EventManager);

    this.element = element;
    this._onBasicInput = this._onBasicInput.bind(this);
    this.manager = new Manager(element, { recognizers: options.recognizers || RECOGNIZERS }).on('hammer.input', this._onBasicInput);

    this.eventHandlers = [];

    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, { enable: false });
    this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  /**
   * Tear down internal event management implementations.
   */


  _createClass(EventManager, [{
    key: 'destroy',
    value: function destroy() {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.manager.destroy();
    }

    /**
     * Register an event handler function to be called on `event`.
     * @param {string|Object} event   An event name (String) or map of event names to handlers.
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'on',
    value: function on(event, handler) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler);
      } else {
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName]);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      // Special handling for gestural events.
      var recognizerEvent = EVENT_RECOGNIZER_MAP[event];
      if (recognizerEvent) {
        // Enable recognizer for this event.
        var recognizer = this.manager.get(recognizerEvent);
        recognizer.set({ enable: true });
      }

      this.wheelInput.enableIfEventSupported(event);
      this.moveInput.enableIfEventSupported(event);

      var wrappedHandler = this._wrapEventHandler(event, handler);
      // Alias to a recognized gesture as necessary.
      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;

      // Save wrapped handler
      this.eventHandlers.push({ event: event, eventAlias: eventAlias, handler: handler, wrappedHandler: wrappedHandler });

      this.manager.on(eventAlias, wrappedHandler);
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      // Find saved handler if any.
      for (var i = this.eventHandlers.length; i--;) {
        var entry = this.eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          this.manager.off(entry.eventAlias, entry.wrappedHandler);
          // Delete saved handler
          this.eventHandlers.splice(i, 1);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler) {
      var _this = this;

      return function (event) {
        var element = _this.element;
        var srcEvent = event.srcEvent;


        var center = event.center || {
          x: srcEvent.clientX,
          y: srcEvent.clientY
        };

        // Calculate center relative to the root element
        // TODO/xiaoji - avoid using getBoundingClientRect for perf?
        var rect = element.getBoundingClientRect();
        var offsetCenter = {
          x: center.x - rect.left - element.clientLeft,
          y: center.y - rect.top - element.clientTop
        };

        handler(Object.assign({}, event, {
          type: type,
          center: center,
          offsetCenter: offsetCenter,
          rootElement: element
        }));
      };
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        var emitEvent = Object.assign({}, event, { type: alias });
        this.manager.emit(alias, emitEvent);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);

  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvZXZlbnQtbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJNYW5hZ2VyTW9jayIsIm0iLCJpbnN0YW5jZSIsImNoYWluZWROb29wIiwib24iLCJvZmYiLCJkZXN0cm95IiwiZW1pdCIsIk1hbmFnZXIiLCJyZXF1aXJlIiwiQkFTSUNfRVZFTlRfQUxJQVNFUyIsIkVWRU5UX1JFQ09HTklaRVJfTUFQIiwiR0VTVFVSRV9FVkVOVF9BTElBU0VTIiwiUkVDT0dOSVpFUlMiLCJFdmVudE1hbmFnZXIiLCJlbGVtZW50Iiwib3B0aW9ucyIsIl9vbkJhc2ljSW5wdXQiLCJiaW5kIiwibWFuYWdlciIsInJlY29nbml6ZXJzIiwiZXZlbnRIYW5kbGVycyIsIl9vbk90aGVyRXZlbnQiLCJ3aGVlbElucHV0IiwiZW5hYmxlIiwibW92ZUlucHV0IiwiZXZlbnRzIiwiZXZlbnQiLCJoYW5kbGVyIiwiX2FkZEV2ZW50SGFuZGxlciIsImV2ZW50TmFtZSIsIl9yZW1vdmVFdmVudEhhbmRsZXIiLCJyZWNvZ25pemVyRXZlbnQiLCJyZWNvZ25pemVyIiwiZ2V0Iiwic2V0IiwiZW5hYmxlSWZFdmVudFN1cHBvcnRlZCIsIndyYXBwZWRIYW5kbGVyIiwiX3dyYXBFdmVudEhhbmRsZXIiLCJldmVudEFsaWFzIiwicHVzaCIsImkiLCJsZW5ndGgiLCJlbnRyeSIsInNwbGljZSIsInR5cGUiLCJzcmNFdmVudCIsImNlbnRlciIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2Zmc2V0Q2VudGVyIiwibGVmdCIsImNsaWVudExlZnQiLCJ0b3AiLCJjbGllbnRUb3AiLCJPYmplY3QiLCJhc3NpZ24iLCJyb290RWxlbWVudCIsImFsaWFzIiwiZW1pdEV2ZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUF6QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7a0NBSWNwQyxLLEVBQU87QUFDbkIsV0FBS1IsT0FBTCxDQUFhWixJQUFiLENBQWtCb0IsTUFBTWtCLElBQXhCLEVBQThCbEIsS0FBOUI7QUFDRDs7Ozs7O2tCQS9Ka0JiLFkiLCJmaWxlIjoiZXZlbnQtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vd2hlZWwtaW5wdXQnO1xuaW1wb3J0IE1vdmVJbnB1dCBmcm9tICcuL21vdmUtaW5wdXQnO1xuaW1wb3J0IHtpc0Jyb3dzZXJ9IGZyb20gJy4uLy4uL2NvbnRyb2xsZXJzL2dsb2JhbHMnO1xuXG4vLyBIYW1tZXIuanMgZGlyZWN0bHkgcmVmZXJlbmNlcyBgZG9jdW1lbnRgIGFuZCBgd2luZG93YCxcbi8vIHdoaWNoIG1lYW5zIHRoYXQgaW1wb3J0aW5nIGl0IGluIGVudmlyb25tZW50cyB3aXRob3V0XG4vLyB0aG9zZSBvYmplY3RzIHRocm93cyBlcnJvcnMuIFRoZXJlZm9yZSwgaW5zdGVhZCBvZlxuLy8gZGlyZWN0bHkgYGltcG9ydGBpbmcgJ2hhbW1lcmpzJyBhbmQgJy4vY29uc3RhbnRzJ1xuLy8gKHdoaWNoIGltcG9ydHMgSGFtbWVyLmpzKSB3ZSBjb25kaXRpb25hbGx5IHJlcXVpcmUgaXRcbi8vIGRlcGVuZGluZyBvbiBzdXBwb3J0IGZvciB0aG9zZSBnbG9iYWxzLCBhbmQgcHJvdmlkZSBtb2Nrc1xuLy8gZm9yIGVudmlyb25tZW50cyB3aXRob3V0IGBkb2N1bWVudGAvYHdpbmRvd2AuXG5mdW5jdGlvbiBNYW5hZ2VyTW9jayhtKSB7XG4gIGNvbnN0IGluc3RhbmNlID0ge307XG4gIGNvbnN0IGNoYWluZWROb29wID0gKCkgPT4gaW5zdGFuY2U7XG4gIGluc3RhbmNlLm9uID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLm9mZiA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5kZXN0cm95ID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLmVtaXQgPSBjaGFpbmVkTm9vcDtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5jb25zdCBNYW5hZ2VyID0gaXNCcm93c2VyID8gcmVxdWlyZSgnaGFtbWVyanMnKS5NYW5hZ2VyIDogTWFuYWdlck1vY2s7XG5jb25zdCB7XG4gIEJBU0lDX0VWRU5UX0FMSUFTRVMsXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQLFxuICBSRUNPR05JWkVSUyxcbiAgR0VTVFVSRV9FVkVOVF9BTElBU0VTXG59ID0gaXNCcm93c2VyID8gcmVxdWlyZSgnLi9jb25zdGFudHMnKSA6IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUzoge30sXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQOiB7fSxcbiAgR0VTVFVSRV9FVkVOVF9BTElBU0VTOiB7fVxufTtcblxuLyoqXG4gKiBTaW5nbGUgQVBJIGZvciBzdWJzY3JpYmluZyB0byBldmVudHMgYWJvdXQgYm90aFxuICogYmFzaWMgaW5wdXQgZXZlbnRzIChlLmcuICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd3aGVlbCcpXG4gKiBhbmQgZ2VzdHVyYWwgaW5wdXQgKGUuZy4gJ2NsaWNrJywgJ3RhcCcsICdwYW5zdGFydCcpLlxuICogRGVsZWdhdGVzIGV2ZW50IHJlZ2lzdHJhdGlvbiBhbmQgaGFuZGxpbmcgdG8gSGFtbWVyLmpzLlxuICogQHBhcmFtIHtET00gRWxlbWVudH0gZWxlbWVudCAgICAgICAgIERPTSBlbGVtZW50IG9uIHdoaWNoIGV2ZW50IGhhbmRsZXJzIHdpbGwgYmUgcmVnaXN0ZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICBPcHRpb25zIGZvciBpbnN0YW50aWF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5ldmVudHMgICAgICAgTWFwIG9mIHtldmVudCBuYW1lOiBoYW5kbGVyfSB0byByZWdpc3RlciBvbiBpbml0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucmVjb2duaXplcnMgIEdlc3R1cmUgcmVjb2duaXplcnMgZnJvbSBIYW1tZXIuanMgdG8gcmVnaXN0ZXIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgYW4gQXJyYXkgaW4gSGFtbWVyLlJlY29nbml6ZXIgZm9ybWF0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8jaGFtbWVybWFuYWdlcilcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSB0aGlzLl9vbkJhc2ljSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlcihlbGVtZW50LCB7cmVjb2duaXplcnM6IG9wdGlvbnMucmVjb2duaXplcnMgfHwgUkVDT0dOSVpFUlN9KVxuICAgICAgLm9uKCdoYW1tZXIuaW5wdXQnLCB0aGlzLl9vbkJhc2ljSW5wdXQpO1xuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyBIYW5kbGUgZXZlbnRzIG5vdCBoYW5kbGVkIGJ5IEhhbW1lci5qczpcbiAgICAvLyAtIG1vdXNlIHdoZWVsXG4gICAgLy8gLSBwb2ludGVyL3RvdWNoL21vdXNlIG1vdmVcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLndoZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtlbmFibGU6IGZhbHNlfSk7XG4gICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBwYXNzZWQgZXZlbnRzLlxuICAgIGNvbnN0IHtldmVudHN9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICB0aGlzLm9uKGV2ZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlYXIgZG93biBpbnRlcm5hbCBldmVudCBtYW5hZ2VtZW50IGltcGxlbWVudGF0aW9ucy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy53aGVlbElucHV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5tYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV2ZW50ICAgQW4gZXZlbnQgbmFtZSAoU3RyaW5nKSBvciBtYXAgb2YgZXZlbnQgbmFtZXMgdG8gaGFuZGxlcnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAgICBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gICAqL1xuICBvbihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcHJldmlvdXNseS1yZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXZlbnQgICBBbiBldmVudCBuYW1lIChTdHJpbmcpIG9yIG1hcCBvZiBldmVudCBuYW1lcyB0byBoYW5kbGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9mZigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCByZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBnZXN0dXJhbCBldmVudHMuXG4gICAgY29uc3QgcmVjb2duaXplckV2ZW50ID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRdO1xuICAgIGlmIChyZWNvZ25pemVyRXZlbnQpIHtcbiAgICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAgY29uc3QgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQocmVjb2duaXplckV2ZW50KTtcbiAgICAgIHJlY29nbml6ZXIuc2V0KHtlbmFibGU6IHRydWV9KTtcbiAgICB9XG5cbiAgICB0aGlzLndoZWVsSW5wdXQuZW5hYmxlSWZFdmVudFN1cHBvcnRlZChldmVudCk7XG4gICAgdGhpcy5tb3ZlSW5wdXQuZW5hYmxlSWZFdmVudFN1cHBvcnRlZChldmVudCk7XG5cbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMuX3dyYXBFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcblxuICAgIC8vIFNhdmUgd3JhcHBlZCBoYW5kbGVyXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzLnB1c2goe2V2ZW50LCBldmVudEFsaWFzLCBoYW5kbGVyLCB3cmFwcGVkSGFuZGxlcn0pO1xuXG4gICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIHdyYXBwZWRIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCBkZXJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIC8vIEZpbmQgc2F2ZWQgaGFuZGxlciBpZiBhbnkuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZXZlbnRIYW5kbGVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5ldmVudEhhbmRsZXJzW2ldO1xuICAgICAgaWYgKGVudHJ5LmV2ZW50ID09PSBldmVudCAmJiBlbnRyeS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIC8vIERlcmVnaXN0ZXIgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLm9mZihlbnRyeS5ldmVudEFsaWFzLCBlbnRyeS53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgIC8vIERlbGV0ZSBzYXZlZCBoYW5kbGVyXG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXZlbnQgaGFuZGxlciB0aGF0IGFsaWFzZXMgZXZlbnRzIGFuZCBhZGQgcHJvcHMgYmVmb3JlIHBhc3NpbmdcbiAgICogdG8gdGhlIHJlYWwgaGFuZGxlci5cbiAgICovXG4gIF93cmFwRXZlbnRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge2VsZW1lbnR9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcblxuICAgICAgY29uc3QgY2VudGVyID0gZXZlbnQuY2VudGVyIHx8IHtcbiAgICAgICAgeDogc3JjRXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogc3JjRXZlbnQuY2xpZW50WVxuICAgICAgfTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGNlbnRlciByZWxhdGl2ZSB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAvLyBUT0RPL3hpYW9qaSAtIGF2b2lkIHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmb3IgcGVyZj9cbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgb2Zmc2V0Q2VudGVyID0ge1xuICAgICAgICB4OiBjZW50ZXIueCAtIHJlY3QubGVmdCAtIGVsZW1lbnQuY2xpZW50TGVmdCxcbiAgICAgICAgeTogY2VudGVyLnkgLSByZWN0LnRvcCAtIGVsZW1lbnQuY2xpZW50VG9wXG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVyKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgb2Zmc2V0Q2VudGVyLFxuICAgICAgICByb290RWxlbWVudDogZWxlbWVudFxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgY29uc3QgZW1pdEV2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHt0eXBlOiBhbGlhc30pO1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYWxpYXMsIGVtaXRFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBldmVudHMgbm90IHN1cHBvcnRlZCBieSBIYW1tZXIuanMsXG4gICAqIGFuZCBwaXBlIGJhY2sgb3V0IHRocm91Z2ggc2FtZSAoSGFtbWVyKSBjaGFubmVsIHVzZWQgYnkgb3RoZXIgZXZlbnRzLlxuICAgKi9cbiAgX29uT3RoZXJFdmVudChldmVudCkge1xuICAgIHRoaXMubWFuYWdlci5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgfVxuXG59XG4iXX0=