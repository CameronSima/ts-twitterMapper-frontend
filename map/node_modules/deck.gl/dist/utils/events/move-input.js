'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup'];
var MOVE_EVENT_TYPES = ['mousemove', 'pointermove'];

/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */

var MoveInput = function () {
  function MoveInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, MoveInput);

    this.element = element;
    this.callback = callback;
    this.pressed = false;

    var events = MOUSE_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(MoveInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'enableIfEventSupported',
    value: function enableIfEventSupported(eventType) {
      if (MOVE_EVENT_TYPES.indexOf(eventType) >= 0) {
        this.options.enable = true;
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      var _this3 = this;

      if (!this.options.enable) {
        return;
      }

      switch (event.type) {
        case 'mousedown':
          if (event.button === 0) {
            // Left button is down
            this.pressed = true;
          }
          break;
        case 'mousemove':
          // Move events use `which` to track the button being pressed
          if (event.which !== 1) {
            // Left button is not down
            this.pressed = false;
          }
          if (!this.pressed) {
            // Drag events are emitted by hammer already
            // we just need to emit the move event on hover
            MOVE_EVENT_TYPES.forEach(function (type) {
              return _this3.callback({
                type: type,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
              });
            });
          }
          break;
        case 'mouseup':
          this.pressed = false;
          break;
        default:
      }
    }
  }]);

  return MoveInput;
}();

exports.default = MoveInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvbW92ZS1pbnB1dC5qcyJdLCJuYW1lcyI6WyJNT1VTRV9FVkVOVFMiLCJNT1ZFX0VWRU5UX1RZUEVTIiwiTW92ZUlucHV0IiwiZWxlbWVudCIsImNhbGxiYWNrIiwib3B0aW9ucyIsInByZXNzZWQiLCJldmVudHMiLCJjb25jYXQiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmFibGUiLCJoYW5kbGVFdmVudCIsImJpbmQiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50VHlwZSIsImluZGV4T2YiLCJ0eXBlIiwiYnV0dG9uIiwid2hpY2giLCJzcmNFdmVudCIsInBvaW50ZXJUeXBlIiwidGFyZ2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsSUFBTUEsZUFBZSxDQUFDLFdBQUQsRUFBYyxXQUFkLEVBQTJCLFNBQTNCLENBQXJCO0FBQ0EsSUFBTUMsbUJBQW1CLENBQUMsV0FBRCxFQUFjLGFBQWQsQ0FBekI7O0FBRUE7Ozs7Ozs7OztJQVFxQkMsUztBQUVuQixxQkFBWUMsT0FBWixFQUFxQkMsUUFBckIsRUFBNkM7QUFBQTs7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQzNDLFNBQUtGLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0UsT0FBTCxHQUFlLEtBQWY7O0FBRUEsUUFBTUMsU0FBU1AsYUFBYVEsTUFBYixDQUFvQkgsUUFBUUUsTUFBUixJQUFrQixFQUF0QyxDQUFmO0FBQ0EsU0FBS0YsT0FBTCxHQUFlSSxPQUFPQyxNQUFQLENBQWMsRUFBQ0MsUUFBUSxJQUFULEVBQWQsRUFBOEJOLE9BQTlCLEVBQXVDLEVBQUNFLGNBQUQsRUFBdkMsQ0FBZjs7QUFFQSxTQUFLSyxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJDLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0EsU0FBS1IsT0FBTCxDQUFhRSxNQUFiLENBQW9CTyxPQUFwQixDQUE0QjtBQUFBLGFBQVNYLFFBQVFZLGdCQUFSLENBQXlCQyxLQUF6QixFQUFnQyxNQUFLSixXQUFyQyxDQUFUO0FBQUEsS0FBNUI7QUFDRDs7Ozs4QkFFUztBQUFBOztBQUNSLFdBQUtQLE9BQUwsQ0FBYUUsTUFBYixDQUFvQk8sT0FBcEIsQ0FBNEI7QUFBQSxlQUFTLE9BQUtYLE9BQUwsQ0FBYWMsbUJBQWIsQ0FBaUNELEtBQWpDLEVBQXdDLE9BQUtKLFdBQTdDLENBQVQ7QUFBQSxPQUE1QjtBQUNEOzs7d0JBRUdQLE8sRUFBUztBQUNYSSxhQUFPQyxNQUFQLENBQWMsS0FBS0wsT0FBbkIsRUFBNEJBLE9BQTVCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7MkNBSXVCYSxTLEVBQVc7QUFDaEMsVUFBSWpCLGlCQUFpQmtCLE9BQWpCLENBQXlCRCxTQUF6QixLQUF1QyxDQUEzQyxFQUE4QztBQUM1QyxhQUFLYixPQUFMLENBQWFNLE1BQWIsR0FBc0IsSUFBdEI7QUFDRDtBQUNGOzs7Z0NBRVdLLEssRUFBTztBQUFBOztBQUNqQixVQUFJLENBQUMsS0FBS1gsT0FBTCxDQUFhTSxNQUFsQixFQUEwQjtBQUN4QjtBQUNEOztBQUVELGNBQVFLLE1BQU1JLElBQWQ7QUFDQSxhQUFLLFdBQUw7QUFDRSxjQUFJSixNQUFNSyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCO0FBQ0EsaUJBQUtmLE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRDtBQUNGLGFBQUssV0FBTDtBQUNFO0FBQ0EsY0FBSVUsTUFBTU0sS0FBTixLQUFnQixDQUFwQixFQUF1QjtBQUNyQjtBQUNBLGlCQUFLaEIsT0FBTCxHQUFlLEtBQWY7QUFDRDtBQUNELGNBQUksQ0FBQyxLQUFLQSxPQUFWLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQUwsNkJBQWlCYSxPQUFqQixDQUF5QjtBQUFBLHFCQUFRLE9BQUtWLFFBQUwsQ0FBYztBQUM3Q2dCLDBCQUQ2QztBQUU3Q0csMEJBQVVQLEtBRm1DO0FBRzdDUSw2QkFBYSxPQUhnQztBQUk3Q0Msd0JBQVFULE1BQU1TO0FBSitCLGVBQWQsQ0FBUjtBQUFBLGFBQXpCO0FBTUQ7QUFDRDtBQUNGLGFBQUssU0FBTDtBQUNFLGVBQUtuQixPQUFMLEdBQWUsS0FBZjtBQUNBO0FBQ0Y7QUEzQkE7QUE2QkQ7Ozs7OztrQkFsRWtCSixTIiwiZmlsZSI6Im1vdmUtaW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCddO1xuY29uc3QgTU9WRV9FVkVOVF9UWVBFUyA9IFsnbW91c2Vtb3ZlJywgJ3BvaW50ZXJtb3ZlJ107XG5cbi8qKlxuICogSGFtbWVyLmpzIHN3YWxsb3dzICdtb3ZlJyBldmVudHMgKGZvciBwb2ludGVyL3RvdWNoL21vdXNlKVxuICogd2hlbiB0aGUgcG9pbnRlciBpcyBub3QgZG93bi4gVGhpcyBjbGFzcyBzZXRzIHVwIGEgaGFuZGxlclxuICogc3BlY2lmaWNhbGx5IGZvciB0aGVzZSBldmVudHMgdG8gd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuICogTm90ZSB0aGF0IHRoaXMgY291bGQgYmUgZXh0ZW5kZWQgdG8gbW9yZSBpbnRlbGxpZ2VudGx5IGhhbmRsZVxuICogbW92ZSBldmVudHMgYWNyb3NzIGlucHV0IHR5cGVzLCBlLmcuIHN0b3JpbmcgbXVsdGlwbGUgc2ltdWx0YW5lb3VzXG4gKiBwb2ludGVyL3RvdWNoIGV2ZW50cywgY2FsY3VsYXRpbmcgc3BlZWQvZGlyZWN0aW9uLCBldGMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmVJbnB1dCB7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgZXZlbnRzID0gTU9VU0VfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7ZW5hYmxlOiB0cnVlfSwgb3B0aW9ucywge2V2ZW50c30pO1xuXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9wdGlvbnMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMub3B0aW9ucy5ldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVFdmVudCkpO1xuICB9XG5cbiAgc2V0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIHRoaXMgaW5wdXQgKGJlZ2luIHByb2Nlc3NpbmcgZXZlbnRzKVxuICAgKiBpZiB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgaXMgYW1vbmcgdGhvc2UgaGFuZGxlZCBieSB0aGlzIGlucHV0LlxuICAgKi9cbiAgZW5hYmxlSWZFdmVudFN1cHBvcnRlZChldmVudFR5cGUpIHtcbiAgICBpZiAoTU9WRV9FVkVOVF9UWVBFUy5pbmRleE9mKGV2ZW50VHlwZSkgPj0gMCkge1xuICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAvLyBMZWZ0IGJ1dHRvbiBpcyBkb3duXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgLy8gTW92ZSBldmVudHMgdXNlIGB3aGljaGAgdG8gdHJhY2sgdGhlIGJ1dHRvbiBiZWluZyBwcmVzc2VkXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDEpIHtcbiAgICAgICAgLy8gTGVmdCBidXR0b24gaXMgbm90IGRvd25cbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAvLyBEcmFnIGV2ZW50cyBhcmUgZW1pdHRlZCBieSBoYW1tZXIgYWxyZWFkeVxuICAgICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW1pdCB0aGUgbW92ZSBldmVudCBvbiBob3ZlclxuICAgICAgICBNT1ZFX0VWRU5UX1RZUEVTLmZvckVhY2godHlwZSA9PiB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cbn1cbiJdfQ==