'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _viewportMercatorProject = require('viewport-mercator-project');

var _eventManager = require('./event-manager');

var _eventManager2 = _interopRequireDefault(_eventManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


// MapControls uses non-react event manager to register events


// import browser from 'bowser';
var PREFIX = '-webkit-';
// browser.webkit || browser.blink ? '-webkit-' :
// browser.gecko ? '-moz-' :
// '';
var CURSOR = {
  GRABBING: PREFIX + 'grabbing',
  GRAB: PREFIX + 'grab',
  POINTER: 'pointer'
};

function mod(value, divisor) {
  var modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
// MAPBOX LIMITS
var MAX_PITCH = 60;
var MAX_ZOOM = 40;

// EVENT HANDLING PARAMETERS
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;

/* eslint-disable no-inline-comments */
var propTypes = {
  width: _react.PropTypes.number.isRequired, // The width of the map
  height: _react.PropTypes.number.isRequired, // The height of the map
  latitude: _react.PropTypes.number.isRequired, // The latitude of the center of the map.
  longitude: _react.PropTypes.number.isRequired, // The longitude of the center of the map.
  zoom: _react.PropTypes.number.isRequired, // The tile zoom level of the map.
  bearing: _react.PropTypes.number, // Specify the bearing of the viewport
  pitch: _react.PropTypes.number, // Specify the pitch of the viewport
  altitude: _react.PropTypes.number, // Altitude of viewport camera. Unit: map heights, default 1.5

  constraints: _react.PropTypes.object,

  dragToRotate: _react.PropTypes.bool, // Enables perspective control event handling

  onViewportChange: _react.PropTypes.func, // `onViewportChange` is fired on user interaction

  isDragging: _react.PropTypes.bool, // Is the component currently being dragged.
  startDragLngLat: _react.PropTypes.arrayOf(_react.PropTypes.number), // Position when current drag started
  startBearing: _react.PropTypes.number, // Bearing when current perspective drag started
  startPitch: _react.PropTypes.number, // Pitch when current perspective drag operation started

  pressKeyToRotate: _react.PropTypes.bool, // If key must be pressed for mouse to rotate vs pan

  /* Hooks to get mapbox help with calculations. TODO - replace with Viewport */
  unproject: _react.PropTypes.func,
  getLngLatAtPoint: _react.PropTypes.func
};

var defaultProps = {
  bearing: 0,
  pitch: 0,
  altitude: 1.5,
  clickRadius: 15,
  onViewportChange: null,

  maxZoom: MAX_ZOOM,
  minZoom: 0,
  maxPitch: MAX_PITCH,
  minPitch: 0,

  unproject: null,
  getLngLatAtPoint: null,

  pressKeyToRotate: true
};

var MapControls = function (_PureComponent) {
  _inherits(MapControls, _PureComponent);

  /**
   * @classdesc
   * A component that monitors events and updates mercator style viewport parameters
   * It can be used with or without a mapbox map
   * (e.g. it could pan over a static map image)
   */
  function MapControls(props) {
    _classCallCheck(this, MapControls);

    var _this = _possibleConstructorReturn(this, (MapControls.__proto__ || Object.getPrototypeOf(MapControls)).call(this, props));

    _this.state = {
      isDragging: false,
      isHovering: false,
      startDragLngLat: null,
      startBearing: null,
      startPitch: null
    };
    return _this;
  }

  _createClass(MapControls, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // Register event handlers on the canvas using the EventManager helper class
      //
      // Note that mouse move and click are handled directly by static-map
      // Corresponding to hover and click on map
      // onMouseMove={this._onMouseMove}
      // onMouseClick={this._onMouseClick}

      this._eventManager = new _eventManager2.default(this.refs.canvas, {
        onMouseDown: this._onMouseDown.bind(this),
        onMouseDrag: this._onMouseDrag.bind(this),
        onMouseRotate: this._onMouseRotate.bind(this),
        onMouseUp: this._onMouseUp.bind(this),
        onZoom: this._onZoom.bind(this),
        onZoomEnd: this._onZoomEnd.bind(this),
        mapTouchToMouse: true,
        pressKeyToRotate: this.props.pressKeyToRotate
      });
    }

    // New props are comin' round the corner!

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      var startDragLngLat = newProps.startDragLngLat;

      this.setState({
        startDragLngLat: startDragLngLat && [].concat(_toConsumableArray(startDragLngLat))
      });
    }

    // Calculate a cursor style to show that we are in "dragging state"

  }, {
    key: '_getCursor',
    value: function _getCursor() {
      var isInteractive = this.props.onViewportChange || this.props.onClickFeature || this.props.onHoverFeatures;

      if (!isInteractive) {
        return 'inherit';
      }
      if (this.props.isDragging) {
        return CURSOR.GRABBING;
      }
      if (this.state.isHovering) {
        return CURSOR.POINTER;
      }
      return CURSOR.GRAB;
    }
  }, {
    key: '_updateViewport',
    value: function _updateViewport(opts) {
      var viewport = Object.assign({
        latitude: this.props.latitude,
        longitude: this.props.longitude,
        zoom: this.props.zoom,
        bearing: this.props.bearing,
        pitch: this.props.pitch,
        altitude: this.props.altitude,
        isDragging: this.props.isDragging,
        startDragLngLat: this.props.startDragLngLat,
        startBearing: this.props.startBearing,
        startPitch: this.props.startPitch
      }, opts);

      viewport = this._applyConstraints(viewport);

      return this.props.onViewportChange(viewport);
    }

    // Apply any constraints (mathematical or defined by props) to viewport params

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(viewport) {
      // Normalize degrees
      viewport.longitude = mod(viewport.longitude + 180, 360) - 180;
      viewport.bearing = mod(viewport.bearing + 180, 360) - 180;

      // Ensure zoom is within specified range
      var _props = this.props,
          maxZoom = _props.maxZoom,
          minZoom = _props.minZoom;

      viewport.zoom = viewport.zoom > maxZoom ? maxZoom : viewport.zoom;
      viewport.zoom = viewport.zoom < minZoom ? minZoom : viewport.zoom;

      // Ensure pitch is within specified range
      var _props2 = this.props,
          maxPitch = _props2.maxPitch,
          minPitch = _props2.minPitch;


      viewport.pitch = viewport.pitch > maxPitch ? maxPitch : viewport.pitch;
      viewport.pitch = viewport.pitch < minPitch ? minPitch : viewport.pitch;

      return viewport;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(Object.assign({}, this.props));
      var lngLat = this.props.unproject ? this.props.unproject(pos) : viewport.unproject(pos, { topLeft: false });
      return lngLat;
    }

    // Calculate a new lnglat based on pixel dragging position
    // TODO - We should have a mapbox-independent implementation of panning
    // Panning calculation is currently done using an undocumented mapbox function

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref) {
      var startDragLngLat = _ref.startDragLngLat,
          pos = _ref.pos,
          startPos = _ref.startPos;

      var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(Object.assign({}, this.props, {
        longitude: startDragLngLat[0],
        latitude: startDragLngLat[1]
      }));

      var lngLat = this.props.getLngLatAtPoint ? this.props.getLngLatAtPoint({ lngLat: startDragLngLat, pos: pos }) : viewport.getLocationAtPoint({ lngLat: startDragLngLat, pos: pos });

      return lngLat;
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref2) {
      var relativeScale = _ref2.relativeScale;

      return this.props.zoom + Math.log2(relativeScale);
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos,
          startBearing = _ref3.startBearing,
          startPitch = _ref3.startPitch;
      var maxPitch = this.props.maxPitch;
      // TODO minPitch

      var xDelta = pos[0] - startPos[0];
      var yDelta = pos[1] - startPos[1];

      var bearing = startBearing + 180 * xDelta / this.props.width;

      var pitch = startPitch;
      if (yDelta > 0) {
        // Dragging downwards, gradually decrease pitch
        if (Math.abs(this.props.height - startPos[1]) > PITCH_MOUSE_THRESHOLD) {
          var scale = yDelta / (this.props.height - startPos[1]);
          pitch = (1 - scale) * PITCH_ACCEL * startPitch;
        }
      } else if (yDelta < 0) {
        // Dragging upwards, gradually increase pitch
        if (startPos[1] > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          var yScale = 1 - pos[1] / startPos[1];
          // Gradually add until we hit max pitch
          pitch = startPitch + yScale * (maxPitch - startPitch);
        }
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }

    // EVENT HANDLERS

  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(_ref4) {
      var pos = _ref4.pos;

      this._updateViewport({
        isDragging: true,
        startDragLngLat: this._unproject(pos),
        startBearing: this.props.bearing,
        startPitch: this.props.pitch
      });
    }
  }, {
    key: '_onMouseDrag',
    value: function _onMouseDrag(_ref5) {
      var pos = _ref5.pos;

      if (!this.props.onViewportChange) {
        return;
      }

      var startDragLngLat = this.state.startDragLngLat;

      // take the start lnglat and put it where the mouse is down.

      if (!startDragLngLat) {
        console.log( // eslint-disable-line
        startDragLngLat, '`startDragLngLat` prop is required ' + 'for mouse drag behavior to calculate where to position the map.');
        return;
      }
      // assert(startDragLngLat, '`startDragLngLat` prop is required ' +
      //   'for mouse drag behavior to calculate where to position the map.');

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startDragLngLat: startDragLngLat, pos: pos }),
          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      this._updateViewport({
        longitude: longitude,
        latitude: latitude,
        isDragging: true
      });
    }
  }, {
    key: '_onMouseRotate',
    value: function _onMouseRotate(_ref6) {
      var pos = _ref6.pos,
          startPos = _ref6.startPos;

      if (!this.props.onViewportChange || !this.props.dragToRotate) {
        return;
      }

      var _props3 = this.props,
          startBearing = _props3.startBearing,
          startPitch = _props3.startPitch;

      if (typeof startBearing !== 'number') {
        console.error( // eslint-disable-line
        '`startBearing` prop is required for mouse rotate behavior');
        return;
      }
      if (typeof startPitch !== 'number') {
        console.error( // eslint-disable-line
        '`startPitch` prop is required for mouse rotate behavior');
        return;
      }

      // assert(typeof startBearing === 'number',
      //   '`startBearing` prop is required for mouse rotate behavior');
      // assert(typeof startPitch === 'number',
      //   '`startPitch` prop is required for mouse rotate behavior');

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        pos: pos,
        startPos: startPos,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      this._updateViewport({
        bearing: bearing,
        pitch: pitch,
        isDragging: true
      });
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(opt) {
      this._updateViewport({
        isDragging: false,
        startDragLngLat: null,
        startBearing: null,
        startPitch: null
      });
    }
  }, {
    key: '_onZoom',
    value: function _onZoom(_ref7) {
      var pos = _ref7.pos,
          scale = _ref7.scale;

      // Make sure we zoom around the current mouse position rather than map center
      var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this.props);
      var aroundLngLat = viewport.unproject(pos);

      var zoom = this._calculateNewZoom({ relativeScale: scale });

      var zoomedViewport = new _viewportMercatorProject.PerspectiveMercatorViewport(Object.assign({}, this.props, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: aroundLngLat, pos: pos }),
          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      this._updateViewport({
        zoom: this._calculateNewZoom({ relativeScale: scale }),
        longitude: longitude,
        latitude: latitude,
        isDragging: true
      });
    }
  }, {
    key: '_onZoomEnd',
    value: function _onZoomEnd() {
      this._updateViewport({ isDragging: false });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props4 = this.props,
          className = _props4.className,
          width = _props4.width,
          height = _props4.height,
          style = _props4.style;


      var mapEventLayerStyle = Object.assign({}, style, {
        width: width,
        height: height,
        position: 'relative',
        cursor: this._getCursor()
      });

      return (0, _react.createElement)('div', {
        ref: 'canvas',
        style: mapEventLayerStyle,
        className: className
      }, this.props.children);
    }
  }]);

  return MapControls;
}(_react.PureComponent);

exports.default = MapControls;


MapControls.displayName = 'MapControls';
MapControls.propTypes = propTypes;
MapControls.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cm9sbGVycy9tYXAtY29udHJvbHMuanMiXSwibmFtZXMiOlsiUFJFRklYIiwiQ1VSU09SIiwiR1JBQkJJTkciLCJHUkFCIiwiUE9JTlRFUiIsIm1vZCIsInZhbHVlIiwiZGl2aXNvciIsIm1vZHVsdXMiLCJNQVhfUElUQ0giLCJNQVhfWk9PTSIsIlBJVENIX01PVVNFX1RIUkVTSE9MRCIsIlBJVENIX0FDQ0VMIiwicHJvcFR5cGVzIiwid2lkdGgiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwiaGVpZ2h0IiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwiYmVhcmluZyIsInBpdGNoIiwiYWx0aXR1ZGUiLCJjb25zdHJhaW50cyIsIm9iamVjdCIsImRyYWdUb1JvdGF0ZSIsImJvb2wiLCJvblZpZXdwb3J0Q2hhbmdlIiwiZnVuYyIsImlzRHJhZ2dpbmciLCJzdGFydERyYWdMbmdMYXQiLCJhcnJheU9mIiwic3RhcnRCZWFyaW5nIiwic3RhcnRQaXRjaCIsInByZXNzS2V5VG9Sb3RhdGUiLCJ1bnByb2plY3QiLCJnZXRMbmdMYXRBdFBvaW50IiwiZGVmYXVsdFByb3BzIiwiY2xpY2tSYWRpdXMiLCJtYXhab29tIiwibWluWm9vbSIsIm1heFBpdGNoIiwibWluUGl0Y2giLCJNYXBDb250cm9scyIsInByb3BzIiwic3RhdGUiLCJpc0hvdmVyaW5nIiwiX2V2ZW50TWFuYWdlciIsInJlZnMiLCJjYW52YXMiLCJvbk1vdXNlRG93biIsIl9vbk1vdXNlRG93biIsImJpbmQiLCJvbk1vdXNlRHJhZyIsIl9vbk1vdXNlRHJhZyIsIm9uTW91c2VSb3RhdGUiLCJfb25Nb3VzZVJvdGF0ZSIsIm9uTW91c2VVcCIsIl9vbk1vdXNlVXAiLCJvblpvb20iLCJfb25ab29tIiwib25ab29tRW5kIiwiX29uWm9vbUVuZCIsIm1hcFRvdWNoVG9Nb3VzZSIsIm5ld1Byb3BzIiwic2V0U3RhdGUiLCJpc0ludGVyYWN0aXZlIiwib25DbGlja0ZlYXR1cmUiLCJvbkhvdmVyRmVhdHVyZXMiLCJvcHRzIiwidmlld3BvcnQiLCJPYmplY3QiLCJhc3NpZ24iLCJfYXBwbHlDb25zdHJhaW50cyIsInBvcyIsImxuZ0xhdCIsInRvcExlZnQiLCJzdGFydFBvcyIsImdldExvY2F0aW9uQXRQb2ludCIsInJlbGF0aXZlU2NhbGUiLCJNYXRoIiwibG9nMiIsInhEZWx0YSIsInlEZWx0YSIsImFicyIsInNjYWxlIiwieVNjYWxlIiwiX3VwZGF0ZVZpZXdwb3J0IiwiX3VucHJvamVjdCIsImNvbnNvbGUiLCJsb2ciLCJfY2FsY3VsYXRlTmV3TG5nTGF0IiwiZXJyb3IiLCJfY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nIiwib3B0IiwiYXJvdW5kTG5nTGF0IiwiX2NhbGN1bGF0ZU5ld1pvb20iLCJ6b29tZWRWaWV3cG9ydCIsImNsYXNzTmFtZSIsInN0eWxlIiwibWFwRXZlbnRMYXllclN0eWxlIiwicG9zaXRpb24iLCJjdXJzb3IiLCJfZ2V0Q3Vyc29yIiwicmVmIiwiY2hpbGRyZW4iLCJkaXNwbGF5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQW1CQTs7QUFDQTs7QUFHQTs7Ozs7Ozs7Ozs7OytlQXZCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7OztBQUdBO0FBQ0EsSUFBTUEsU0FBUyxVQUFmO0FBQ0U7QUFDQTtBQUNBO0FBQ0YsSUFBTUMsU0FBUztBQUNiQyxZQUFhRixNQUFiLGFBRGE7QUFFYkcsUUFBU0gsTUFBVCxTQUZhO0FBR2JJLFdBQVM7QUFISSxDQUFmOztBQU1BLFNBQVNDLEdBQVQsQ0FBYUMsS0FBYixFQUFvQkMsT0FBcEIsRUFBNkI7QUFDM0IsTUFBTUMsVUFBVUYsUUFBUUMsT0FBeEI7QUFDQSxTQUFPQyxVQUFVLENBQVYsR0FBY0QsVUFBVUMsT0FBeEIsR0FBa0NBLE9BQXpDO0FBQ0Q7QUFDRDtBQUNBLElBQU1DLFlBQVksRUFB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Q0FBdUIsRUFBQ2pCLGVBQWVNLEtBQWhCLEVBQXZCLENBRGE7QUFFbkJuRSw0QkFGbUI7QUFHbkJELDBCQUhtQjtBQUluQlksb0JBQVk7QUFKTyxPQUFyQjtBQU1EOzs7aUNBRVk7QUFDWCxXQUFLMEQsZUFBTCxDQUFxQixFQUFDMUQsWUFBWSxLQUFiLEVBQXJCO0FBQ0Q7Ozs2QkFFUTtBQUFBLG9CQUNtQyxLQUFLZSxLQUR4QztBQUFBLFVBQ0FzRCxTQURBLFdBQ0FBLFNBREE7QUFBQSxVQUNXckYsS0FEWCxXQUNXQSxLQURYO0FBQUEsVUFDa0JHLE1BRGxCLFdBQ2tCQSxNQURsQjtBQUFBLFVBQzBCbUYsS0FEMUIsV0FDMEJBLEtBRDFCOzs7QUFHUCxVQUFNQyxxQkFBcUI3QixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQjJCLEtBQWxCLEVBQXlCO0FBQ2xEdEYsb0JBRGtEO0FBRWxERyxzQkFGa0Q7QUFHbERxRixrQkFBVSxVQUh3QztBQUlsREMsZ0JBQVEsS0FBS0MsVUFBTDtBQUowQyxPQUF6QixDQUEzQjs7QUFPQSxhQUFPLDBCQUFjLEtBQWQsRUFBcUI7QUFDMUJDLGFBQUssUUFEcUI7QUFFMUJMLGVBQU9DLGtCQUZtQjtBQUcxQkY7QUFIMEIsT0FBckIsRUFJSixLQUFLdEQsS0FBTCxDQUFXNkQsUUFKUCxDQUFQO0FBS0Q7Ozs7OztrQkE3UmtCOUQsVzs7O0FBZ1NyQkEsWUFBWStELFdBQVosR0FBMEIsYUFBMUI7QUFDQS9ELFlBQVkvQixTQUFaLEdBQXdCQSxTQUF4QjtBQUNBK0IsWUFBWU4sWUFBWixHQUEyQkEsWUFBM0IiLCJmaWxlIjoibWFwLWNvbnRyb2xzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCB7UHJvcFR5cGVzLCBQdXJlQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1BlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbi8vIE1hcENvbnRyb2xzIHVzZXMgbm9uLXJlYWN0IGV2ZW50IG1hbmFnZXIgdG8gcmVnaXN0ZXIgZXZlbnRzXG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4vZXZlbnQtbWFuYWdlcic7XG5cbi8vIGltcG9ydCBicm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5jb25zdCBQUkVGSVggPSAnLXdlYmtpdC0nO1xuICAvLyBicm93c2VyLndlYmtpdCB8fCBicm93c2VyLmJsaW5rID8gJy13ZWJraXQtJyA6XG4gIC8vIGJyb3dzZXIuZ2Vja28gPyAnLW1vei0nIDpcbiAgLy8gJyc7XG5jb25zdCBDVVJTT1IgPSB7XG4gIEdSQUJCSU5HOiBgJHtQUkVGSVh9Z3JhYmJpbmdgLFxuICBHUkFCOiBgJHtQUkVGSVh9Z3JhYmAsXG4gIFBPSU5URVI6ICdwb2ludGVyJ1xufTtcblxuZnVuY3Rpb24gbW9kKHZhbHVlLCBkaXZpc29yKSB7XG4gIGNvbnN0IG1vZHVsdXMgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gIHJldHVybiBtb2R1bHVzIDwgMCA/IGRpdmlzb3IgKyBtb2R1bHVzIDogbW9kdWx1cztcbn1cbi8vIE1BUEJPWCBMSU1JVFNcbmNvbnN0IE1BWF9QSVRDSCA9IDYwO1xuY29uc3QgTUFYX1pPT00gPSA0MDtcblxuLy8gRVZFTlQgSEFORExJTkcgUEFSQU1FVEVSU1xuY29uc3QgUElUQ0hfTU9VU0VfVEhSRVNIT0xEID0gNTtcbmNvbnN0IFBJVENIX0FDQ0VMID0gMS4yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbmxpbmUtY29tbWVudHMgKi9cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCwgLy8gVGhlIHdpZHRoIG9mIHRoZSBtYXBcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8vIFRoZSBoZWlnaHQgb2YgdGhlIG1hcFxuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAvLyBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCwgIC8vIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8vIFRoZSB0aWxlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cbiAgYmVhcmluZzogUHJvcFR5cGVzLm51bWJlciwgLy8gU3BlY2lmeSB0aGUgYmVhcmluZyBvZiB0aGUgdmlld3BvcnRcbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsIC8vIFNwZWNpZnkgdGhlIHBpdGNoIG9mIHRoZSB2aWV3cG9ydFxuICBhbHRpdHVkZTogUHJvcFR5cGVzLm51bWJlciwgLy8gQWx0aXR1ZGUgb2Ygdmlld3BvcnQgY2FtZXJhLiBVbml0OiBtYXAgaGVpZ2h0cywgZGVmYXVsdCAxLjVcblxuICBjb25zdHJhaW50czogUHJvcFR5cGVzLm9iamVjdCxcblxuICBkcmFnVG9Sb3RhdGU6IFByb3BUeXBlcy5ib29sLCAgLy8gRW5hYmxlcyBwZXJzcGVjdGl2ZSBjb250cm9sIGV2ZW50IGhhbmRsaW5nXG5cbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsIC8vIGBvblZpZXdwb3J0Q2hhbmdlYCBpcyBmaXJlZCBvbiB1c2VyIGludGVyYWN0aW9uXG5cbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wsIC8vIElzIHRoZSBjb21wb25lbnQgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQuXG4gIHN0YXJ0RHJhZ0xuZ0xhdDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksIC8vIFBvc2l0aW9uIHdoZW4gY3VycmVudCBkcmFnIHN0YXJ0ZWRcbiAgc3RhcnRCZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBCZWFyaW5nIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSBkcmFnIHN0YXJ0ZWRcbiAgc3RhcnRQaXRjaDogUHJvcFR5cGVzLm51bWJlciwgLy8gUGl0Y2ggd2hlbiBjdXJyZW50IHBlcnNwZWN0aXZlIGRyYWcgb3BlcmF0aW9uIHN0YXJ0ZWRcblxuICBwcmVzc0tleVRvUm90YXRlOiBQcm9wVHlwZXMuYm9vbCwgLy8gSWYga2V5IG11c3QgYmUgcHJlc3NlZCBmb3IgbW91c2UgdG8gcm90YXRlIHZzIHBhblxuXG4gIC8qIEhvb2tzIHRvIGdldCBtYXBib3ggaGVscCB3aXRoIGNhbGN1bGF0aW9ucy4gVE9ETyAtIHJlcGxhY2Ugd2l0aCBWaWV3cG9ydCAqL1xuICB1bnByb2plY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBnZXRMbmdMYXRBdFBvaW50OiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBiZWFyaW5nOiAwLFxuICBwaXRjaDogMCxcbiAgYWx0aXR1ZGU6IDEuNSxcbiAgY2xpY2tSYWRpdXM6IDE1LFxuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuXG4gIG1heFpvb206IE1BWF9aT09NLFxuICBtaW5ab29tOiAwLFxuICBtYXhQaXRjaDogTUFYX1BJVENILFxuICBtaW5QaXRjaDogMCxcblxuICB1bnByb2plY3Q6IG51bGwsXG4gIGdldExuZ0xhdEF0UG9pbnQ6IG51bGwsXG5cbiAgcHJlc3NLZXlUb1JvdGF0ZTogdHJ1ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwQ29udHJvbHMgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQSBjb21wb25lbnQgdGhhdCBtb25pdG9ycyBldmVudHMgYW5kIHVwZGF0ZXMgbWVyY2F0b3Igc3R5bGUgdmlld3BvcnQgcGFyYW1ldGVyc1xuICAgKiBJdCBjYW4gYmUgdXNlZCB3aXRoIG9yIHdpdGhvdXQgYSBtYXBib3ggbWFwXG4gICAqIChlLmcuIGl0IGNvdWxkIHBhbiBvdmVyIGEgc3RhdGljIG1hcCBpbWFnZSlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlLFxuICAgICAgc3RhcnREcmFnTG5nTGF0OiBudWxsLFxuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBSZWdpc3RlciBldmVudCBoYW5kbGVycyBvbiB0aGUgY2FudmFzIHVzaW5nIHRoZSBFdmVudE1hbmFnZXIgaGVscGVyIGNsYXNzXG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgbW91c2UgbW92ZSBhbmQgY2xpY2sgYXJlIGhhbmRsZWQgZGlyZWN0bHkgYnkgc3RhdGljLW1hcFxuICAgIC8vIENvcnJlc3BvbmRpbmcgdG8gaG92ZXIgYW5kIGNsaWNrIG9uIG1hcFxuICAgIC8vIG9uTW91c2VNb3ZlPXt0aGlzLl9vbk1vdXNlTW92ZX1cbiAgICAvLyBvbk1vdXNlQ2xpY2s9e3RoaXMuX29uTW91c2VDbGlja31cblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIodGhpcy5yZWZzLmNhbnZhcywge1xuICAgICAgb25Nb3VzZURvd246IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyksXG4gICAgICBvbk1vdXNlRHJhZzogdGhpcy5fb25Nb3VzZURyYWcuYmluZCh0aGlzKSxcbiAgICAgIG9uTW91c2VSb3RhdGU6IHRoaXMuX29uTW91c2VSb3RhdGUuYmluZCh0aGlzKSxcbiAgICAgIG9uTW91c2VVcDogdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyksXG4gICAgICBvblpvb206IHRoaXMuX29uWm9vbS5iaW5kKHRoaXMpLFxuICAgICAgb25ab29tRW5kOiB0aGlzLl9vblpvb21FbmQuYmluZCh0aGlzKSxcbiAgICAgIG1hcFRvdWNoVG9Nb3VzZTogdHJ1ZSxcbiAgICAgIHByZXNzS2V5VG9Sb3RhdGU6IHRoaXMucHJvcHMucHJlc3NLZXlUb1JvdGF0ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTmV3IHByb3BzIGFyZSBjb21pbicgcm91bmQgdGhlIGNvcm5lciFcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcykge1xuICAgIGNvbnN0IHtzdGFydERyYWdMbmdMYXR9ID0gbmV3UHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGFydERyYWdMbmdMYXQ6IHN0YXJ0RHJhZ0xuZ0xhdCAmJiBbLi4uc3RhcnREcmFnTG5nTGF0XVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgdGhhdCB3ZSBhcmUgaW4gXCJkcmFnZ2luZyBzdGF0ZVwiXG4gIF9nZXRDdXJzb3IoKSB7XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZSA9XG4gICAgICB0aGlzLnByb3BzLm9uVmlld3BvcnRDaGFuZ2UgfHxcbiAgICAgIHRoaXMucHJvcHMub25DbGlja0ZlYXR1cmUgfHxcbiAgICAgIHRoaXMucHJvcHMub25Ib3ZlckZlYXR1cmVzO1xuXG4gICAgaWYgKCFpc0ludGVyYWN0aXZlKSB7XG4gICAgICByZXR1cm4gJ2luaGVyaXQnO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5pc0RyYWdnaW5nKSB7XG4gICAgICByZXR1cm4gQ1VSU09SLkdSQUJCSU5HO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS5pc0hvdmVyaW5nKSB7XG4gICAgICByZXR1cm4gQ1VSU09SLlBPSU5URVI7XG4gICAgfVxuICAgIHJldHVybiBDVVJTT1IuR1JBQjtcbiAgfVxuXG4gIF91cGRhdGVWaWV3cG9ydChvcHRzKSB7XG4gICAgbGV0IHZpZXdwb3J0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsYXRpdHVkZTogdGhpcy5wcm9wcy5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogdGhpcy5wcm9wcy5sb25naXR1ZGUsXG4gICAgICB6b29tOiB0aGlzLnByb3BzLnpvb20sXG4gICAgICBiZWFyaW5nOiB0aGlzLnByb3BzLmJlYXJpbmcsXG4gICAgICBwaXRjaDogdGhpcy5wcm9wcy5waXRjaCxcbiAgICAgIGFsdGl0dWRlOiB0aGlzLnByb3BzLmFsdGl0dWRlLFxuICAgICAgaXNEcmFnZ2luZzogdGhpcy5wcm9wcy5pc0RyYWdnaW5nLFxuICAgICAgc3RhcnREcmFnTG5nTGF0OiB0aGlzLnByb3BzLnN0YXJ0RHJhZ0xuZ0xhdCxcbiAgICAgIHN0YXJ0QmVhcmluZzogdGhpcy5wcm9wcy5zdGFydEJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoOiB0aGlzLnByb3BzLnN0YXJ0UGl0Y2hcbiAgICB9LCBvcHRzKTtcblxuICAgIHZpZXdwb3J0ID0gdGhpcy5fYXBwbHlDb25zdHJhaW50cyh2aWV3cG9ydCk7XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vblZpZXdwb3J0Q2hhbmdlKHZpZXdwb3J0KTtcbiAgfVxuXG4gIC8vIEFwcGx5IGFueSBjb25zdHJhaW50cyAobWF0aGVtYXRpY2FsIG9yIGRlZmluZWQgYnkgcHJvcHMpIHRvIHZpZXdwb3J0IHBhcmFtc1xuICBfYXBwbHlDb25zdHJhaW50cyh2aWV3cG9ydCkge1xuICAgIC8vIE5vcm1hbGl6ZSBkZWdyZWVzXG4gICAgdmlld3BvcnQubG9uZ2l0dWRlID0gbW9kKHZpZXdwb3J0LmxvbmdpdHVkZSArIDE4MCwgMzYwKSAtIDE4MDtcbiAgICB2aWV3cG9ydC5iZWFyaW5nID0gbW9kKHZpZXdwb3J0LmJlYXJpbmcgKyAxODAsIDM2MCkgLSAxODA7XG5cbiAgICAvLyBFbnN1cmUgem9vbSBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFpvb20sIG1pblpvb219ID0gdGhpcy5wcm9wcztcbiAgICB2aWV3cG9ydC56b29tID0gdmlld3BvcnQuem9vbSA+IG1heFpvb20gPyBtYXhab29tIDogdmlld3BvcnQuem9vbTtcbiAgICB2aWV3cG9ydC56b29tID0gdmlld3BvcnQuem9vbSA8IG1pblpvb20gPyBtaW5ab29tIDogdmlld3BvcnQuem9vbTtcblxuICAgIC8vIEVuc3VyZSBwaXRjaCBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFBpdGNoLCBtaW5QaXRjaH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdmlld3BvcnQucGl0Y2ggPSB2aWV3cG9ydC5waXRjaCA+IG1heFBpdGNoID8gbWF4UGl0Y2ggOiB2aWV3cG9ydC5waXRjaDtcbiAgICB2aWV3cG9ydC5waXRjaCA9IHZpZXdwb3J0LnBpdGNoIDwgbWluUGl0Y2ggPyBtaW5QaXRjaCA6IHZpZXdwb3J0LnBpdGNoO1xuXG4gICAgcmV0dXJuIHZpZXdwb3J0O1xuICB9XG5cbiAgX3VucHJvamVjdChwb3MpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcykpO1xuICAgIGNvbnN0IGxuZ0xhdCA9IHRoaXMucHJvcHMudW5wcm9qZWN0ID9cbiAgICAgIHRoaXMucHJvcHMudW5wcm9qZWN0KHBvcykgOlxuICAgICAgdmlld3BvcnQudW5wcm9qZWN0KHBvcywge3RvcExlZnQ6IGZhbHNlfSk7XG4gICAgcmV0dXJuIGxuZ0xhdDtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhIG5ldyBsbmdsYXQgYmFzZWQgb24gcGl4ZWwgZHJhZ2dpbmcgcG9zaXRpb25cbiAgLy8gVE9ETyAtIFdlIHNob3VsZCBoYXZlIGEgbWFwYm94LWluZGVwZW5kZW50IGltcGxlbWVudGF0aW9uIG9mIHBhbm5pbmdcbiAgLy8gUGFubmluZyBjYWxjdWxhdGlvbiBpcyBjdXJyZW50bHkgZG9uZSB1c2luZyBhbiB1bmRvY3VtZW50ZWQgbWFwYm94IGZ1bmN0aW9uXG4gIF9jYWxjdWxhdGVOZXdMbmdMYXQoe3N0YXJ0RHJhZ0xuZ0xhdCwgcG9zLCBzdGFydFBvc30pIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgbG9uZ2l0dWRlOiBzdGFydERyYWdMbmdMYXRbMF0sXG4gICAgICBsYXRpdHVkZTogc3RhcnREcmFnTG5nTGF0WzFdXG4gICAgfSkpO1xuXG4gICAgY29uc3QgbG5nTGF0ID0gdGhpcy5wcm9wcy5nZXRMbmdMYXRBdFBvaW50ID9cbiAgICAgIHRoaXMucHJvcHMuZ2V0TG5nTGF0QXRQb2ludCh7bG5nTGF0OiBzdGFydERyYWdMbmdMYXQsIHBvc30pIDpcbiAgICAgIHZpZXdwb3J0LmdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0OiBzdGFydERyYWdMbmdMYXQsIHBvc30pO1xuXG4gICAgcmV0dXJuIGxuZ0xhdDtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgbmV3IHpvb21cbiAgX2NhbGN1bGF0ZU5ld1pvb20oe3JlbGF0aXZlU2NhbGV9KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuem9vbSArIE1hdGgubG9nMihyZWxhdGl2ZVNjYWxlKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgYSBuZXcgcGl0Y2ggYW5kIGJlYXJpbmcgZnJvbSBhIHBvc2l0aW9uIChjb21pbmcgZnJvbSBhbiBldmVudClcbiAgX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyh7cG9zLCBzdGFydFBvcywgc3RhcnRCZWFyaW5nLCBzdGFydFBpdGNofSkge1xuICAgIGNvbnN0IHttYXhQaXRjaH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIFRPRE8gbWluUGl0Y2hcblxuICAgIGNvbnN0IHhEZWx0YSA9IHBvc1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgIGNvbnN0IHlEZWx0YSA9IHBvc1sxXSAtIHN0YXJ0UG9zWzFdO1xuXG4gICAgY29uc3QgYmVhcmluZyA9IHN0YXJ0QmVhcmluZyArIDE4MCAqIHhEZWx0YSAvIHRoaXMucHJvcHMud2lkdGg7XG5cbiAgICBsZXQgcGl0Y2ggPSBzdGFydFBpdGNoO1xuICAgIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAvLyBEcmFnZ2luZyBkb3dud2FyZHMsIGdyYWR1YWxseSBkZWNyZWFzZSBwaXRjaFxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMucHJvcHMuaGVpZ2h0IC0gc3RhcnRQb3NbMV0pID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0geURlbHRhIC8gKHRoaXMucHJvcHMuaGVpZ2h0IC0gc3RhcnRQb3NbMV0pO1xuICAgICAgICBwaXRjaCA9ICgxIC0gc2NhbGUpICogUElUQ0hfQUNDRUwgKiBzdGFydFBpdGNoO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeURlbHRhIDwgMCkge1xuICAgICAgLy8gRHJhZ2dpbmcgdXB3YXJkcywgZ3JhZHVhbGx5IGluY3JlYXNlIHBpdGNoXG4gICAgICBpZiAoc3RhcnRQb3NbMV0gPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgY29uc3QgeVNjYWxlID0gMSAtIHBvc1sxXSAvIHN0YXJ0UG9zWzFdO1xuICAgICAgICAvLyBHcmFkdWFsbHkgYWRkIHVudGlsIHdlIGhpdCBtYXggcGl0Y2hcbiAgICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoICsgeVNjYWxlICogKG1heFBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZ1xuICAgIH07XG4gIH1cblxuICAvLyBFVkVOVCBIQU5ETEVSU1xuXG4gIF9vbk1vdXNlRG93bih7cG9zfSkge1xuICAgIHRoaXMuX3VwZGF0ZVZpZXdwb3J0KHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBzdGFydERyYWdMbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpLFxuICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLnByb3BzLmJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoOiB0aGlzLnByb3BzLnBpdGNoXG4gICAgfSk7XG4gIH1cblxuICBfb25Nb3VzZURyYWcoe3Bvc30pIHtcbiAgICBpZiAoIXRoaXMucHJvcHMub25WaWV3cG9ydENoYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtzdGFydERyYWdMbmdMYXR9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIHRha2UgdGhlIHN0YXJ0IGxuZ2xhdCBhbmQgcHV0IGl0IHdoZXJlIHRoZSBtb3VzZSBpcyBkb3duLlxuICAgIGlmICghc3RhcnREcmFnTG5nTGF0KSB7XG4gICAgICBjb25zb2xlLmxvZyggLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBzdGFydERyYWdMbmdMYXQsICdgc3RhcnREcmFnTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgK1xuICAgICAgICAnZm9yIG1vdXNlIGRyYWcgYmVoYXZpb3IgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBtYXAuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzc2VydChzdGFydERyYWdMbmdMYXQsICdgc3RhcnREcmFnTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgK1xuICAgIC8vICAgJ2ZvciBtb3VzZSBkcmFnIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLicpO1xuXG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gdGhpcy5fY2FsY3VsYXRlTmV3TG5nTGF0KHtzdGFydERyYWdMbmdMYXQsIHBvc30pO1xuXG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe1xuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfb25Nb3VzZVJvdGF0ZSh7cG9zLCBzdGFydFBvc30pIHtcbiAgICBpZiAoIXRoaXMucHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCAhdGhpcy5wcm9wcy5kcmFnVG9Sb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7c3RhcnRCZWFyaW5nLCBzdGFydFBpdGNofSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHR5cGVvZiBzdGFydEJlYXJpbmcgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICdgc3RhcnRCZWFyaW5nYCBwcm9wIGlzIHJlcXVpcmVkIGZvciBtb3VzZSByb3RhdGUgYmVoYXZpb3InKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdGFydFBpdGNoICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS5lcnJvciggLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAnYHN0YXJ0UGl0Y2hgIHByb3AgaXMgcmVxdWlyZWQgZm9yIG1vdXNlIHJvdGF0ZSBiZWhhdmlvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFzc2VydCh0eXBlb2Ygc3RhcnRCZWFyaW5nID09PSAnbnVtYmVyJyxcbiAgICAvLyAgICdgc3RhcnRCZWFyaW5nYCBwcm9wIGlzIHJlcXVpcmVkIGZvciBtb3VzZSByb3RhdGUgYmVoYXZpb3InKTtcbiAgICAvLyBhc3NlcnQodHlwZW9mIHN0YXJ0UGl0Y2ggPT09ICdudW1iZXInLFxuICAgIC8vICAgJ2BzdGFydFBpdGNoYCBwcm9wIGlzIHJlcXVpcmVkIGZvciBtb3VzZSByb3RhdGUgYmVoYXZpb3InKTtcblxuICAgIGNvbnN0IHtwaXRjaCwgYmVhcmluZ30gPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe1xuICAgICAgcG9zLFxuICAgICAgc3RhcnRQb3MsXG4gICAgICBzdGFydEJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoXG4gICAgfSk7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICBiZWFyaW5nLFxuICAgICAgcGl0Y2gsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfb25Nb3VzZVVwKG9wdCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpZXdwb3J0KHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgc3RhcnREcmFnTG5nTGF0OiBudWxsLFxuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgX29uWm9vbSh7cG9zLCBzY2FsZX0pIHtcbiAgICAvLyBNYWtlIHN1cmUgd2Ugem9vbSBhcm91bmQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gcmF0aGVyIHRoYW4gbWFwIGNlbnRlclxuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLnByb3BzKTtcbiAgICBjb25zdCBhcm91bmRMbmdMYXQgPSB2aWV3cG9ydC51bnByb2plY3QocG9zKTtcblxuICAgIGNvbnN0IHpvb20gPSB0aGlzLl9jYWxjdWxhdGVOZXdab29tKHtyZWxhdGl2ZVNjYWxlOiBzY2FsZX0pO1xuXG4gICAgY29uc3Qgem9vbWVkVmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHt6b29tfSkpO1xuICAgIGNvbnN0IFtsb25naXR1ZGUsIGxhdGl0dWRlXSA9IHpvb21lZFZpZXdwb3J0LmdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0OiBhcm91bmRMbmdMYXQsIHBvc30pO1xuXG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe1xuICAgICAgem9vbTogdGhpcy5fY2FsY3VsYXRlTmV3Wm9vbSh7cmVsYXRpdmVTY2FsZTogc2NhbGV9KSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX29uWm9vbUVuZCgpIHtcbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7aXNEcmFnZ2luZzogZmFsc2V9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7Y2xhc3NOYW1lLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgbWFwRXZlbnRMYXllclN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBjdXJzb3I6IHRoaXMuX2dldEN1cnNvcigpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgcmVmOiAnY2FudmFzJyxcbiAgICAgIHN0eWxlOiBtYXBFdmVudExheWVyU3R5bGUsXG4gICAgICBjbGFzc05hbWVcbiAgICB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufVxuXG5NYXBDb250cm9scy5kaXNwbGF5TmFtZSA9ICdNYXBDb250cm9scyc7XG5NYXBDb250cm9scy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5NYXBDb250cm9scy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=