'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Portions of the code below originally from:
// https://github.com/mapbox/mapbox-gl-js/blob/master/js/ui/handler/scroll_zoom.js

var _globals = require('./globals');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function noop() {}

var ua = typeof _globals.window.navigator !== 'undefined' ? _globals.window.navigator.userAgent.toLowerCase() : '';
var firefox = ua.indexOf('firefox') !== -1;

// Extract a position from a mouse event
function getMousePosition(el, event) {
  var rect = el.getBoundingClientRect();
  event = event.touches ? event.touches[0] : event;
  return [event.clientX - rect.left - el.clientLeft, event.clientY - rect.top - el.clientTop];
}

// Extract an array of touch positions from a touch event
function getTouchPositions(el, event) {
  var points = [];
  var rect = el.getBoundingClientRect();
  for (var i = 0; i < event.touches.length; i++) {
    points.push([event.touches[i].clientX - rect.left - el.clientLeft, event.touches[i].clientY - rect.top - el.clientTop]);
  }
  return points;
}

// Return the centroid of an array of points
function centroid(positions) {
  var sum = positions.reduce(function (acc, elt) {
    return [acc[0] + elt[0], acc[1] + elt[1]];
  }, [0, 0]);
  return [sum[0] / positions.length, sum[1] / positions.length];
}

var EventManager = function () {
  function EventManager(canvas) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$onMouseMove = _ref.onMouseMove,
        onMouseMove = _ref$onMouseMove === undefined ? noop : _ref$onMouseMove,
        _ref$onMouseClick = _ref.onMouseClick,
        onMouseClick = _ref$onMouseClick === undefined ? noop : _ref$onMouseClick,
        _ref$onMouseDown = _ref.onMouseDown,
        onMouseDown = _ref$onMouseDown === undefined ? noop : _ref$onMouseDown,
        _ref$onMouseUp = _ref.onMouseUp,
        onMouseUp = _ref$onMouseUp === undefined ? noop : _ref$onMouseUp,
        _ref$onMouseRotate = _ref.onMouseRotate,
        onMouseRotate = _ref$onMouseRotate === undefined ? noop : _ref$onMouseRotate,
        _ref$onMouseDrag = _ref.onMouseDrag,
        onMouseDrag = _ref$onMouseDrag === undefined ? noop : _ref$onMouseDrag,
        _ref$onTouchStart = _ref.onTouchStart,
        onTouchStart = _ref$onTouchStart === undefined ? noop : _ref$onTouchStart,
        _ref$onTouchRotate = _ref.onTouchRotate,
        onTouchRotate = _ref$onTouchRotate === undefined ? noop : _ref$onTouchRotate,
        _ref$onTouchDrag = _ref.onTouchDrag,
        onTouchDrag = _ref$onTouchDrag === undefined ? noop : _ref$onTouchDrag,
        _ref$onTouchEnd = _ref.onTouchEnd,
        onTouchEnd = _ref$onTouchEnd === undefined ? noop : _ref$onTouchEnd,
        _ref$onTouchTap = _ref.onTouchTap,
        onTouchTap = _ref$onTouchTap === undefined ? noop : _ref$onTouchTap,
        _ref$onZoom = _ref.onZoom,
        onZoom = _ref$onZoom === undefined ? noop : _ref$onZoom,
        _ref$onZoomEnd = _ref.onZoomEnd,
        onZoomEnd = _ref$onZoomEnd === undefined ? noop : _ref$onZoomEnd,
        _ref$mapTouchToMouse = _ref.mapTouchToMouse,
        mapTouchToMouse = _ref$mapTouchToMouse === undefined ? true : _ref$mapTouchToMouse,
        _ref$pressKeyToRotate = _ref.pressKeyToRotate,
        pressKeyToRotate = _ref$pressKeyToRotate === undefined ? false : _ref$pressKeyToRotate;

    _classCallCheck(this, EventManager);

    // Install default touch handlers if requested (forwards touch to mouse)
    onTouchStart = onTouchStart || mapTouchToMouse && onMouseDown;
    onTouchDrag = onTouchDrag || mapTouchToMouse && onMouseDrag;
    onTouchRotate = onTouchRotate || mapTouchToMouse && onMouseRotate;
    onTouchEnd = onTouchEnd || mapTouchToMouse && onMouseUp;
    onTouchTap = onTouchTap || mapTouchToMouse && onMouseClick;

    this._canvas = canvas;

    // Public member: can be changed by app
    this.pressKeyToRotate = pressKeyToRotate;

    // Private state
    this.state = {
      didDrag: false,
      isFunctionKeyPressed: false,
      startPos: null,
      pos: null,
      mouseWheelPos: null
    };

    this.callbacks = {
      onMouseMove: onMouseMove,
      onMouseClick: onMouseClick,
      onMouseDown: onMouseDown,
      onMouseUp: onMouseUp,
      onTouchStart: onTouchStart,
      onMouseRotate: onMouseRotate,
      onMouseDrag: onMouseDrag,
      onTouchRotate: onTouchRotate,
      onTouchDrag: onTouchDrag,
      onTouchEnd: onTouchEnd,
      onTouchTap: onTouchTap,
      onZoom: onZoom,
      onZoomEnd: onZoomEnd
    };

    this._addEventListeners();
  }

  // Register any outstanding event listeners


  _createClass(EventManager, [{
    key: '_addEventListeners',
    value: function _addEventListeners() {
      this._canvas.addEventListener('mousemove', this._onMouseMove.bind(this));
      this._canvas.addEventListener('mousedown', this._onMouseDown.bind(this));
      this._canvas.addEventListener('mouseup', this._onMouseUp.bind(this));
      this._canvas.addEventListener('touchstart', this._onTouchStart.bind(this));
      this._canvas.addEventListener('contextmenu', this._onMouseDown.bind(this));
      this._canvas.addEventListener('mousewheel', this._onWheel.bind(this));
    }
  }, {
    key: 'setState',
    value: function setState(settings) {
      Object.assign(this.state, settings);
    }
  }, {
    key: '_getMousePos',
    value: function _getMousePos(event) {
      var el = this._canvas;
      return getMousePosition(el, event);
    }
  }, {
    key: '_getTouchPos',
    value: function _getTouchPos(event) {
      var el = this._canvas;
      var positions = getTouchPositions(el, event);
      return centroid(positions);
    }
  }, {
    key: '_isFunctionKeyPressed',
    value: function _isFunctionKeyPressed(event) {
      return Boolean(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(event) {
      var pos = this._getMousePos(event);
      this.setState({
        didDrag: false,
        startPos: pos,
        pos: pos,
        isFunctionKeyPressed: this._isFunctionKeyPressed(event)
      });
      this.callbacks.onMouseDown({ pos: pos });
      _globals.document.addEventListener('mousemove', this._onMouseDrag.bind(this), false);
      _globals.document.addEventListener('mouseup', this._onMouseUp.bind(this), false);
    }
  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(event) {
      var pos = this._getTouchPos(event);
      this.setState({
        didDrag: false,
        startPos: pos,
        pos: pos,
        isFunctionKeyPressed: this._isFunctionKeyPressed(event)
      });
      this.callbacks.onTouchStart({ pos: pos });
      _globals.document.addEventListener('touchmove', this._onTouchDrag.bind(this), false);
      _globals.document.addEventListener('touchend', this._onTouchEnd.bind(this), false);
    }
  }, {
    key: '_onMouseDrag',
    value: function _onMouseDrag(event) {
      var pos = this._getMousePos(event);
      this.setState({ pos: pos, didDrag: true });
      var startPos = this.state.startPos;
      var isFunctionKeyPressed = this.state.isFunctionKeyPressed;

      var rotate = this.pressKeyToRotate ? isFunctionKeyPressed : !isFunctionKeyPressed;

      if (rotate) {
        this.callbacks.onMouseRotate({ pos: pos, startPos: startPos });
      } else {
        this.callbacks.onMouseDrag({ pos: pos, startPos: startPos });
      }
    }
  }, {
    key: '_onTouchDrag',
    value: function _onTouchDrag(event) {
      var pos = this._getTouchPos(event);
      this.setState({ pos: pos, didDrag: true });

      var isFunctionKeyPressed = this.state.isFunctionKeyPressed;

      var rotate = this.pressKeyToRotate ? isFunctionKeyPressed : !isFunctionKeyPressed;

      if (rotate) {
        var startPos = this.state.startPos;

        this.callbacks.onTouchRotate({ pos: pos, startPos: startPos });
      } else {
        this.callbacks.onTouchDrag({ pos: pos });
      }
      event.preventDefault();
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(event) {
      _globals.document.removeEventListener('mousemove', this._onMouseDrag, false);
      _globals.document.removeEventListener('mouseup', this._onMouseUp, false);
      var pos = this._getMousePos(event);
      this.setState({ pos: pos });
      this.callbacks.onMouseUp({ pos: pos });
      if (!this.state.didDrag) {
        this.callbacks.onMouseClick({ pos: pos });
      }
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(event) {
      _globals.document.removeEventListener('touchmove', this._onTouchDrag, false);
      _globals.document.removeEventListener('touchend', this._onTouchEnd, false);
      var pos = this._getTouchPos(event);
      this.setState({ pos: pos });
      this.callbacks.onTouchEnd({ pos: pos });
      if (!this.state.didDrag) {
        this.callbacks.onTouchTap({ pos: pos });
      }
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      var pos = this._getMousePos(event);
      this.callbacks.onMouseMove({ pos: pos });
    }

    /* eslint-disable complexity, max-statements */

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      event.preventDefault();
      var value = event.deltaY;
      // Firefox doubles the values on retina screens...
      if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
        value /= _globals.window.devicePixelRatio;
      }
      if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
        value *= 40;
      }

      var type = this.state.mouseWheelType;
      var timeout = this.state.mouseWheelTimeout;
      var lastValue = this.state.mouseWheelLastValue;
      var time = this.state.mouseWheelTime;

      var now = (_globals.window.performance || Date).now();
      var timeDelta = now - (time || 0);

      var pos = this._getMousePos(event);
      time = now;

      if (value !== 0 && value % 4.000244140625 === 0) {
        // This one is definitely a mouse wheel event.
        type = 'wheel';
        // Normalize this value to match trackpad.
        value = Math.floor(value / 4);
      } else if (value !== 0 && Math.abs(value) < 4) {
        // This one is definitely a trackpad event because it is so small.
        type = 'trackpad';
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        type = null;
        lastValue = value;
        // Start a timeout in case this was a singular event, and delay it by up
        // to 40ms.
        timeout = _globals.window.setTimeout(function setTimeout() {
          var _type = 'wheel';
          this._zoom(-this.state.mouseWheelLastValue, this.state.mouseWheelPos);
          this.setState({ mouseWheelType: _type });
        }.bind(this), 40);
      } else if (!this._type) {
        // This is a repeating event, but we don't know the type of event just
        // yet.
        // If the delta per time is small, we assume it's a fast trackpad;
        // otherwise we switch into wheel mode.
        type = Math.abs(timeDelta * value) < 200 ? 'trackpad' : 'wheel';

        // Make sure our delayed event isn't fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (timeout) {
          _globals.window.clearTimeout(timeout);
          timeout = null;
          value += lastValue;
        }
      }

      // Slow down zoom if shift key is held for more precise zooming
      if (event.shiftKey && value) {
        value = value / 4;
      }

      // Only fire the callback if we actually know what type of scrolling device
      // the user uses.
      if (type) {
        this._zoom(-value, pos);
      }

      this.setState({
        mouseWheelTime: time,
        mouseWheelPos: pos,
        mouseWheelType: type,
        mouseWheelTimeout: timeout,
        mouseWheelLastValue: lastValue
      });
    }
    /* eslint-enable complexity, max-statements */

  }, {
    key: '_zoom',
    value: function _zoom(delta, pos) {
      // Scale by sigmoid of scroll wheel delta.
      var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }
      this.callbacks.onZoom({ pos: pos, delta: delta, scale: scale });
      _globals.window.clearTimeout(this._zoomEndTimeout);
      this._zoomEndTimeout = _globals.window.setTimeout(function _setTimeout() {
        this.callbacks.onZoomEnd();
      }.bind(this), 200);
    }
  }]);

  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cm9sbGVycy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIm5vb3AiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiZmlyZWZveCIsImluZGV4T2YiLCJnZXRNb3VzZVBvc2l0aW9uIiwiZWwiLCJldmVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRMZWZ0IiwiY2xpZW50WSIsInRvcCIsImNsaWVudFRvcCIsImdldFRvdWNoUG9zaXRpb25zIiwicG9pbnRzIiwiaSIsImxlbmd0aCIsInB1c2giLCJjZW50cm9pZCIsInBvc2l0aW9ucyIsInN1bSIsInJlZHVjZSIsImFjYyIsImVsdCIsIkV2ZW50TWFuYWdlciIsImNhbnZhcyIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUNsaWNrIiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJvbk1vdXNlUm90YXRlIiwib25Nb3VzZURyYWciLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoUm90YXRlIiwib25Ub3VjaERyYWciLCJvblRvdWNoRW5kIiwib25Ub3VjaFRhcCIsIm9uWm9vbSIsIm9uWm9vbUVuZCIsIm1hcFRvdWNoVG9Nb3VzZSIsInByZXNzS2V5VG9Sb3RhdGUiLCJfY2FudmFzIiwic3RhdGUiLCJkaWREcmFnIiwiaXNGdW5jdGlvbktleVByZXNzZWQiLCJzdGFydFBvcyIsInBvcyIsIm1vdXNlV2hlZWxQb3MiLCJjYWxsYmFja3MiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uTW91c2VNb3ZlIiwiYmluZCIsIl9vbk1vdXNlRG93biIsIl9vbk1vdXNlVXAiLCJfb25Ub3VjaFN0YXJ0IiwiX29uV2hlZWwiLCJzZXR0aW5ncyIsIk9iamVjdCIsImFzc2lnbiIsIkJvb2xlYW4iLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiX2dldE1vdXNlUG9zIiwic2V0U3RhdGUiLCJfaXNGdW5jdGlvbktleVByZXNzZWQiLCJfb25Nb3VzZURyYWciLCJfZ2V0VG91Y2hQb3MiLCJfb25Ub3VjaERyYWciLCJfb25Ub3VjaEVuZCIsInJvdGF0ZSIsInByZXZlbnREZWZhdWx0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInZhbHVlIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwiV2hlZWxFdmVudCIsIkRPTV9ERUxUQV9QSVhFTCIsImRldmljZVBpeGVsUmF0aW8iLCJET01fREVMVEFfTElORSIsInR5cGUiLCJtb3VzZVdoZWVsVHlwZSIsInRpbWVvdXQiLCJtb3VzZVdoZWVsVGltZW91dCIsImxhc3RWYWx1ZSIsIm1vdXNlV2hlZWxMYXN0VmFsdWUiLCJ0aW1lIiwibW91c2VXaGVlbFRpbWUiLCJub3ciLCJwZXJmb3JtYW5jZSIsIkRhdGUiLCJ0aW1lRGVsdGEiLCJNYXRoIiwiZmxvb3IiLCJhYnMiLCJzZXRUaW1lb3V0IiwiX3R5cGUiLCJfem9vbSIsImNsZWFyVGltZW91dCIsImRlbHRhIiwic2NhbGUiLCJleHAiLCJfem9vbUVuZFRpbWVvdXQiLCJfc2V0VGltZW91dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O3FqQkFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBRUEsU0FBU0EsSUFBVCxHQUFnQixDQUFFOztBQUVsQixJQUFNQyxLQUFLLE9BQU8sZ0JBQU9DLFNBQWQsS0FBNEIsV0FBNUIsR0FDVCxnQkFBT0EsU0FBUCxDQUFpQkMsU0FBakIsQ0FBMkJDLFdBQTNCLEVBRFMsR0FDa0MsRUFEN0M7QUFFQSxJQUFNQyxVQUFVSixHQUFHSyxPQUFILENBQVcsU0FBWCxNQUEwQixDQUFDLENBQTNDOztBQUVBO0FBQ0EsU0FBU0MsZ0JBQVQsQ0FBMEJDLEVBQTFCLEVBQThCQyxLQUE5QixFQUFxQztBQUNu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ImZpbGUiOiJldmVudC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgYmVsb3cgb3JpZ2luYWxseSBmcm9tOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvYmxvYi9tYXN0ZXIvanMvdWkvaGFuZGxlci9zY3JvbGxfem9vbS5qc1xuXG5pbXBvcnQge3dpbmRvdywgZG9jdW1lbnR9IGZyb20gJy4vZ2xvYmFscyc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCB1YSA9IHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbmNvbnN0IGZpcmVmb3ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuXG4vLyBFeHRyYWN0IGEgcG9zaXRpb24gZnJvbSBhIG1vdXNlIGV2ZW50XG5mdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGVsLCBldmVudCkge1xuICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGV2ZW50ID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcbiAgcmV0dXJuIFtcbiAgICBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgXTtcbn1cblxuLy8gRXh0cmFjdCBhbiBhcnJheSBvZiB0b3VjaCBwb3NpdGlvbnMgZnJvbSBhIHRvdWNoIGV2ZW50XG5mdW5jdGlvbiBnZXRUb3VjaFBvc2l0aW9ucyhlbCwgZXZlbnQpIHtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC50b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9pbnRzLnB1c2goW1xuICAgICAgZXZlbnQudG91Y2hlc1tpXS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICAgIGV2ZW50LnRvdWNoZXNbaV0uY2xpZW50WSAtIHJlY3QudG9wIC0gZWwuY2xpZW50VG9wXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuLy8gUmV0dXJuIHRoZSBjZW50cm9pZCBvZiBhbiBhcnJheSBvZiBwb2ludHNcbmZ1bmN0aW9uIGNlbnRyb2lkKHBvc2l0aW9ucykge1xuICBjb25zdCBzdW0gPSBwb3NpdGlvbnMucmVkdWNlKFxuICAgIChhY2MsIGVsdCkgPT4gW2FjY1swXSArIGVsdFswXSwgYWNjWzFdICsgZWx0WzFdXSxcbiAgICBbMCwgMF1cbiAgKTtcbiAgcmV0dXJuIFtzdW1bMF0gLyBwb3NpdGlvbnMubGVuZ3RoLCBzdW1bMV0gLyBwb3NpdGlvbnMubGVuZ3RoXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcblxuICBjb25zdHJ1Y3RvcihjYW52YXMsIHtcbiAgICBvbk1vdXNlTW92ZSA9IG5vb3AsXG4gICAgb25Nb3VzZUNsaWNrID0gbm9vcCxcbiAgICBvbk1vdXNlRG93biA9IG5vb3AsXG4gICAgb25Nb3VzZVVwID0gbm9vcCxcbiAgICBvbk1vdXNlUm90YXRlID0gbm9vcCxcbiAgICBvbk1vdXNlRHJhZyA9IG5vb3AsXG4gICAgb25Ub3VjaFN0YXJ0ID0gbm9vcCxcbiAgICBvblRvdWNoUm90YXRlID0gbm9vcCxcbiAgICBvblRvdWNoRHJhZyA9IG5vb3AsXG4gICAgb25Ub3VjaEVuZCA9IG5vb3AsXG4gICAgb25Ub3VjaFRhcCA9IG5vb3AsXG4gICAgb25ab29tID0gbm9vcCxcbiAgICBvblpvb21FbmQgPSBub29wLFxuICAgIG1hcFRvdWNoVG9Nb3VzZSA9IHRydWUsXG4gICAgcHJlc3NLZXlUb1JvdGF0ZSA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIC8vIEluc3RhbGwgZGVmYXVsdCB0b3VjaCBoYW5kbGVycyBpZiByZXF1ZXN0ZWQgKGZvcndhcmRzIHRvdWNoIHRvIG1vdXNlKVxuICAgIG9uVG91Y2hTdGFydCA9IG9uVG91Y2hTdGFydCB8fCAobWFwVG91Y2hUb01vdXNlICYmIG9uTW91c2VEb3duKTtcbiAgICBvblRvdWNoRHJhZyA9IG9uVG91Y2hEcmFnIHx8IChtYXBUb3VjaFRvTW91c2UgJiYgb25Nb3VzZURyYWcpO1xuICAgIG9uVG91Y2hSb3RhdGUgPSBvblRvdWNoUm90YXRlIHx8IChtYXBUb3VjaFRvTW91c2UgJiYgb25Nb3VzZVJvdGF0ZSk7XG4gICAgb25Ub3VjaEVuZCA9IG9uVG91Y2hFbmQgfHwgKG1hcFRvdWNoVG9Nb3VzZSAmJiBvbk1vdXNlVXApO1xuICAgIG9uVG91Y2hUYXAgPSBvblRvdWNoVGFwIHx8IChtYXBUb3VjaFRvTW91c2UgJiYgb25Nb3VzZUNsaWNrKTtcblxuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcblxuICAgIC8vIFB1YmxpYyBtZW1iZXI6IGNhbiBiZSBjaGFuZ2VkIGJ5IGFwcFxuICAgIHRoaXMucHJlc3NLZXlUb1JvdGF0ZSA9IHByZXNzS2V5VG9Sb3RhdGU7XG5cbiAgICAvLyBQcml2YXRlIHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRpZERyYWc6IGZhbHNlLFxuICAgICAgaXNGdW5jdGlvbktleVByZXNzZWQ6IGZhbHNlLFxuICAgICAgc3RhcnRQb3M6IG51bGwsXG4gICAgICBwb3M6IG51bGwsXG4gICAgICBtb3VzZVdoZWVsUG9zOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgb25Nb3VzZU1vdmUsXG4gICAgICBvbk1vdXNlQ2xpY2ssXG4gICAgICBvbk1vdXNlRG93bixcbiAgICAgIG9uTW91c2VVcCxcbiAgICAgIG9uVG91Y2hTdGFydCxcbiAgICAgIG9uTW91c2VSb3RhdGUsXG4gICAgICBvbk1vdXNlRHJhZyxcbiAgICAgIG9uVG91Y2hSb3RhdGUsXG4gICAgICBvblRvdWNoRHJhZyxcbiAgICAgIG9uVG91Y2hFbmQsXG4gICAgICBvblRvdWNoVGFwLFxuICAgICAgb25ab29tLFxuICAgICAgb25ab29tRW5kXG4gICAgfTtcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBSZWdpc3RlciBhbnkgb3V0c3RhbmRpbmcgZXZlbnQgbGlzdGVuZXJzXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHNldFN0YXRlKHNldHRpbmdzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCBzZXR0aW5ncyk7XG4gIH1cblxuICBfZ2V0TW91c2VQb3MoZXZlbnQpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuX2NhbnZhcztcbiAgICByZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlbCwgZXZlbnQpO1xuICB9XG5cbiAgX2dldFRvdWNoUG9zKGV2ZW50KSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLl9jYW52YXM7XG4gICAgY29uc3QgcG9zaXRpb25zID0gZ2V0VG91Y2hQb3NpdGlvbnMoZWwsIGV2ZW50KTtcbiAgICByZXR1cm4gY2VudHJvaWQocG9zaXRpb25zKTtcbiAgfVxuXG4gIF9pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8XG4gICAgICBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbiAgfVxuXG4gIF9vbk1vdXNlRG93bihldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRpZERyYWc6IGZhbHNlLFxuICAgICAgc3RhcnRQb3M6IHBvcyxcbiAgICAgIHBvcyxcbiAgICAgIGlzRnVuY3Rpb25LZXlQcmVzc2VkOiB0aGlzLl9pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudClcbiAgICB9KTtcbiAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlRG93bih7cG9zfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZURyYWcuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgX29uVG91Y2hTdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFRvdWNoUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRpZERyYWc6IGZhbHNlLFxuICAgICAgc3RhcnRQb3M6IHBvcyxcbiAgICAgIHBvcyxcbiAgICAgIGlzRnVuY3Rpb25LZXlQcmVzc2VkOiB0aGlzLl9pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudClcbiAgICB9KTtcbiAgICB0aGlzLmNhbGxiYWNrcy5vblRvdWNoU3RhcnQoe3Bvc30pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hEcmFnLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgX29uTW91c2VEcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZXZlbnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe3BvcywgZGlkRHJhZzogdHJ1ZX0pO1xuICAgIGNvbnN0IHtzdGFydFBvc30gPSB0aGlzLnN0YXRlO1xuXG4gICAgY29uc3Qge2lzRnVuY3Rpb25LZXlQcmVzc2VkfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgcm90YXRlID0gdGhpcy5wcmVzc0tleVRvUm90YXRlID8gaXNGdW5jdGlvbktleVByZXNzZWQgOiAhaXNGdW5jdGlvbktleVByZXNzZWQ7XG5cbiAgICBpZiAocm90YXRlKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlUm90YXRlKHtwb3MsIHN0YXJ0UG9zfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTW91c2VEcmFnKHtwb3MsIHN0YXJ0UG9zfSk7XG4gICAgfVxuICB9XG5cbiAgX29uVG91Y2hEcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0VG91Y2hQb3MoZXZlbnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe3BvcywgZGlkRHJhZzogdHJ1ZX0pO1xuXG4gICAgY29uc3Qge2lzRnVuY3Rpb25LZXlQcmVzc2VkfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgcm90YXRlID0gdGhpcy5wcmVzc0tleVRvUm90YXRlID8gaXNGdW5jdGlvbktleVByZXNzZWQgOiAhaXNGdW5jdGlvbktleVByZXNzZWQ7XG5cbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB7c3RhcnRQb3N9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uVG91Y2hSb3RhdGUoe3Bvcywgc3RhcnRQb3N9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaERyYWcoe3Bvc30pO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgX29uTW91c2VVcChldmVudCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VEcmFnLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgICB0aGlzLnNldFN0YXRlKHtwb3N9KTtcbiAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlVXAoe3Bvc30pO1xuICAgIGlmICghdGhpcy5zdGF0ZS5kaWREcmFnKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlQ2xpY2soe3Bvc30pO1xuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoRW5kKGV2ZW50KSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaERyYWcsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRUb3VjaFBvcyhldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7cG9zfSk7XG4gICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaEVuZCh7cG9zfSk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmRpZERyYWcpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uVG91Y2hUYXAoe3Bvc30pO1xuICAgIH1cbiAgfVxuXG4gIF9vbk1vdXNlTW92ZShldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGV2ZW50KTtcbiAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlTW92ZSh7cG9zfSk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICBfb25XaGVlbChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHZhbHVlID0gZXZlbnQuZGVsdGFZO1xuICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgaWYgKGZpcmVmb3ggJiYgZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgdmFsdWUgKj0gNDA7XG4gICAgfVxuXG4gICAgbGV0IHR5cGUgPSB0aGlzLnN0YXRlLm1vdXNlV2hlZWxUeXBlO1xuICAgIGxldCB0aW1lb3V0ID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsVGltZW91dDtcbiAgICBsZXQgbGFzdFZhbHVlID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsTGFzdFZhbHVlO1xuICAgIGxldCB0aW1lID0gdGhpcy5zdGF0ZS5tb3VzZVdoZWVsVGltZTtcblxuICAgIGNvbnN0IG5vdyA9ICh3aW5kb3cucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG4gICAgY29uc3QgdGltZURlbHRhID0gbm93IC0gKHRpbWUgfHwgMCk7XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRNb3VzZVBvcyhldmVudCk7XG4gICAgdGltZSA9IG5vdztcblxuICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1ID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gNCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gMCAmJiBNYXRoLmFicyh2YWx1ZSkgPCA0KSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICAgIHR5cGUgPSAndHJhY2twYWQnO1xuICAgIH0gZWxzZSBpZiAodGltZURlbHRhID4gNDAwKSB7XG4gICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG5ldyBzY3JvbGwgYWN0aW9uLlxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWxheSBpdCBieSB1cFxuICAgICAgLy8gdG8gNDBtcy5cbiAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiBzZXRUaW1lb3V0KCkge1xuICAgICAgICBjb25zdCBfdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgIHRoaXMuX3pvb20oLXRoaXMuc3RhdGUubW91c2VXaGVlbExhc3RWYWx1ZSwgdGhpcy5zdGF0ZS5tb3VzZVdoZWVsUG9zKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bW91c2VXaGVlbFR5cGU6IF90eXBlfSk7XG4gICAgICB9LmJpbmQodGhpcyksIDQwKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0XG4gICAgICAvLyB5ZXQuXG4gICAgICAvLyBJZiB0aGUgZGVsdGEgcGVyIHRpbWUgaXMgc21hbGwsIHdlIGFzc3VtZSBpdCdzIGEgZmFzdCB0cmFja3BhZDtcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgICAgdHlwZSA9IE1hdGguYWJzKHRpbWVEZWx0YSAqIHZhbHVlKSA8IDIwMCA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFsdWUgKz0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNsb3cgZG93biB6b29tIGlmIHNoaWZ0IGtleSBpcyBoZWxkIGZvciBtb3JlIHByZWNpc2Ugem9vbWluZ1xuICAgIGlmIChldmVudC5zaGlmdEtleSAmJiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAvIDQ7XG4gICAgfVxuXG4gICAgLy8gT25seSBmaXJlIHRoZSBjYWxsYmFjayBpZiB3ZSBhY3R1YWxseSBrbm93IHdoYXQgdHlwZSBvZiBzY3JvbGxpbmcgZGV2aWNlXG4gICAgLy8gdGhlIHVzZXIgdXNlcy5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdGhpcy5fem9vbSgtdmFsdWUsIHBvcyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb3VzZVdoZWVsVGltZTogdGltZSxcbiAgICAgIG1vdXNlV2hlZWxQb3M6IHBvcyxcbiAgICAgIG1vdXNlV2hlZWxUeXBlOiB0eXBlLFxuICAgICAgbW91c2VXaGVlbFRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBtb3VzZVdoZWVsTGFzdFZhbHVlOiBsYXN0VmFsdWVcbiAgICB9KTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX3pvb20oZGVsdGEsIHBvcykge1xuICAgIC8vIFNjYWxlIGJ5IHNpZ21vaWQgb2Ygc2Nyb2xsIHdoZWVsIGRlbHRhLlxuICAgIGxldCBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkZWx0YSAvIDEwMCkpKTtcbiAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSB7XG4gICAgICBzY2FsZSA9IDEgLyBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFja3Mub25ab29tKHtwb3MsIGRlbHRhLCBzY2FsZX0pO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fem9vbUVuZFRpbWVvdXQpO1xuICAgIHRoaXMuX3pvb21FbmRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gX3NldFRpbWVvdXQoKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vblpvb21FbmQoKTtcbiAgICB9LmJpbmQodGhpcyksIDIwMCk7XG4gIH1cbn1cblxuIl19