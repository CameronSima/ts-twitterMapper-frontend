var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import { PureComponent, PropTypes, createElement } from 'react';
import MapControls from './map-controls';

// InteractiveMap is for browser only and should work with isomorphic rendering
// Conditionally require mapbox only in browser to avoid issues under node.js
// Node apps can use StaticMap directly - requires adding additional dependencies
import { isBrowser } from './globals';
var StaticMap = isBrowser ? require('react-map-gl').StaticMap : null;

var propTypes = {
  displayConstraints: PropTypes.object.isRequired
};

var defaultProps = {
  displayConstraints: {
    maxPitch: 60
  }
};

var InteractiveMap = function (_PureComponent) {
  _inherits(InteractiveMap, _PureComponent);

  function InteractiveMap(props) {
    _classCallCheck(this, InteractiveMap);

    return _possibleConstructorReturn(this, (InteractiveMap.__proto__ || Object.getPrototypeOf(InteractiveMap)).call(this, props));
  }

  // TODO - Remove once Viewport alternative is good enough


  _createClass(InteractiveMap, [{
    key: '_getMap',
    value: function _getMap() {
      return this._map._map;
    }

    // Checks a displayConstraints object to see if the map should be displayed

  }, {
    key: 'checkDisplayConstraints',
    value: function checkDisplayConstraints(props) {
      var capitalize = function capitalize(s) {
        return s[0].toUpperCase() + s.slice(1);
      };

      var displayConstraints = props.displayConstraints;

      for (var propName in props) {
        var capitalizedPropName = capitalize(propName);
        var minPropName = 'min' + capitalizedPropName;
        var maxPropName = 'max' + capitalizedPropName;

        if (minPropName in displayConstraints && props[propName] < displayConstraints[minPropName]) {
          return false;
        }
        if (maxPropName in displayConstraints && props[propName] > displayConstraints[maxPropName]) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      // Bail out under node
      if (!StaticMap) {
        return null;
      }

      var mapVisible = this.checkDisplayConstraints(this.props);
      var visibility = mapVisible ? 'visible' : 'hidden';

      return createElement(MapControls, Object.assign({}, this.props, {
        key: 'map-controls',
        style: { position: 'relative' }
      }), [createElement(StaticMap, Object.assign({}, this.props, {
        key: 'map-static',
        style: { position: 'absolute', left: 0, top: 0, visibility: visibility },
        ref: function ref(map) {
          _this2._map = map;
        }
      })), createElement('div', {
        key: 'map-children',
        style: { position: 'absolute', left: 0, top: 0 }
      }, this.props.children)]);
    }
  }]);

  return InteractiveMap;
}(PureComponent);

export default InteractiveMap;


InteractiveMap.displayName = 'InteractiveMap';
InteractiveMap.propTypes = propTypes;
InteractiveMap.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cm9sbGVycy9pbnRlcmFjdGl2ZS1tYXAuanMiXSwibmFtZXMiOlsiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsImNyZWF0ZUVsZW1lbnQiLCJNYXBDb250cm9scyIsImlzQnJvd3NlciIsIlN0YXRpY01hcCIsInJlcXVpcmUiLCJwcm9wVHlwZXMiLCJkaXNwbGF5Q29uc3RyYWludHMiLCJvYmplY3QiLCJpc1JlcXVpcmVkIiwiZGVmYXVsdFByb3BzIiwibWF4UGl0Y2giLCJJbnRlcmFjdGl2ZU1hcCIsInByb3BzIiwiX21hcCIsImNhcGl0YWxpemUiLCJzIiwidG9VcHBlckNhc2UiLCJzbGljZSIsInByb3BOYW1lIiwiY2FwaXRhbGl6ZWRQcm9wTmFtZSIsIm1pblByb3BOYW1lIiwibWF4UHJvcE5hbWUiLCJtYXBWaXNpYmxlIiwiY2hlY2tEaXNwbGF5Q29uc3RyYWludHMiLCJ2aXNpYmlsaXR5IiwiT2JqZWN0IiwiYXNzaWduIiwia2V5Iiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJyZWYiLCJtYXAiLCJjaGlsZHJlbiIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLFNBQVFBLGFBQVIsRUFBdUJDLFNBQXZCLEVBQWtDQyxhQUFsQyxRQUFzRCxPQUF0RDtBQUNBLE9BQU9DLFdBQVAsTUFBd0IsZ0JBQXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVFDLFNBQVIsUUFBd0IsV0FBeEI7QUFDQSxJQUFNQyxZQUFZRCxZQUFZRSxRQUFRLGNBQVIsRUFBd0JELFNBQXBDLEdBQWdELElBQWxFOztBQUVBLElBQU1FLFlBQVk7QUFDaEJDLHNCQUFvQlAsVUFBVVEsTUFBVixDQUFpQkM7QUFEckIsQ0FBbEI7O0FBSUEsSUFBTUMsZUFBZTtBQUNuQkgsc0JBQW9CO0FBQ2xCSSxjQUFVO0FBRFE7QUFERCxDQUFyQjs7SUFNcUJDLGM7OztBQUNuQiwwQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLDJIQUNYQSxLQURXO0FBRWxCOztBQUVEOzs7Ozs4QkFDVTtBQUNSLGFBQU8sS0FBS0MsSUFBTCxDQUFVQSxJQUFqQjtBQUNEOztBQUVEOzs7OzRDQUN3QkQsSyxFQUFPO0FBQzdCLFVBQU1FLGFBQWEsU0FBYkEsVUFBYTtBQUFBLGVBQUtDLEVBQUUsQ0FBRixFQUFLQyxXQUFMLEtBQXFCRCxFQUFFRSxLQUFGLENBQVEsQ0FBUixDQUExQjtBQUFBLE9BQW5COztBQUQ2QixVQUd0Qlgsa0JBSHNCLEdBR0FNLEtBSEEsQ0FHdEJOLGtCQUhzQjs7QUFJN0IsV0FBSyxJQUFNWSxRQUFYLElBQXVCTixLQUF2QixFQUE4QjtBQUM1QixZQUFNTyxzQkFBc0JMLFdBQVdJLFFBQVgsQ0FBNUI7QUFDQSxZQUFNRSxzQkFBb0JELG1CQUExQjtBQUNBLFlBQU1FLHNCQUFvQkYsbUJBQTFCOztBQUVBLFlBQUlDLGVBQWVkLGtCQUFmLElBQXFDTSxNQUFNTSxRQUFOLElBQWtCWixtQkFBbUJjLFdBQW5CLENBQTNELEVBQTRGO0FBQzFGLGlCQUFPLEtBQVA7QUFDRDtBQUNELFlBQUlDLGVBQWVmLGtCQUFmLElBQXFDTSxNQUFNTSxRQUFOLElBQWtCWixtQkFBbUJlLFdBQW5CLENBQTNELEVBQTRGO0FBQzFGLGlCQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7Ozs2QkFFUTtBQUFBOztBQUNQO0FBQ0EsVUFBSSxDQUFDbEIsU0FBTCxFQUFnQjtBQUNkLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQU1tQixhQUFhLEtBQUtDLHVCQUFMLENBQTZCLEtBQUtYLEtBQWxDLENBQW5CO0FBQ0EsVUFBTVksYUFBYUYsYUFBYSxTQUFiLEdBQXlCLFFBQTVDOztBQUVBLGFBQ0V0QixjQUFjQyxXQUFkLEVBQTJCd0IsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IsS0FBS2QsS0FBdkIsRUFBOEI7QUFDdkRlLGFBQUssY0FEa0Q7QUFFdkRDLGVBQU8sRUFBQ0MsVUFBVSxVQUFYO0FBRmdELE9BQTlCLENBQTNCLEVBR0ksQ0FDRjdCLGNBQWNHLFNBQWQsRUFBeUJzQixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLZCxLQUF2QixFQUE4QjtBQUNyRGUsYUFBSyxZQURnRDtBQUVyREMsZUFBTyxFQUFDQyxVQUFVLFVBQVgsRUFBdUJDLE1BQU0sQ0FBN0IsRUFBZ0NDLEtBQUssQ0FBckMsRUFBd0NQLHNCQUF4QyxFQUY4QztBQUdyRFEsYUFBSyxrQkFBTztBQUNWLGlCQUFLbkIsSUFBTCxHQUFZb0IsR0FBWjtBQUNEO0FBTG9ELE9BQTlCLENBQXpCLENBREUsRUFRRmpDLGNBQWMsS0FBZCxFQUFxQjtBQUNuQjJCLGFBQUssY0FEYztBQUVuQkMsZUFBTyxFQUFDQyxVQUFVLFVBQVgsRUFBdUJDLE1BQU0sQ0FBN0IsRUFBZ0NDLEtBQUssQ0FBckM7QUFGWSxPQUFyQixFQUlFLEtBQUtuQixLQUFMLENBQVdzQixRQUpiLENBUkUsQ0FISixDQURGO0FBb0JEOzs7O0VBM0R5Q3BDLGE7O2VBQXZCYSxjOzs7QUE4RHJCQSxlQUFld0IsV0FBZixHQUE2QixnQkFBN0I7QUFDQXhCLGVBQWVOLFNBQWYsR0FBMkJBLFNBQTNCO0FBQ0FNLGVBQWVGLFlBQWYsR0FBOEJBLFlBQTlCIiwiZmlsZSI6ImludGVyYWN0aXZlLW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UHVyZUNvbXBvbmVudCwgUHJvcFR5cGVzLCBjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTWFwQ29udHJvbHMgZnJvbSAnLi9tYXAtY29udHJvbHMnO1xuXG4vLyBJbnRlcmFjdGl2ZU1hcCBpcyBmb3IgYnJvd3NlciBvbmx5IGFuZCBzaG91bGQgd29yayB3aXRoIGlzb21vcnBoaWMgcmVuZGVyaW5nXG4vLyBDb25kaXRpb25hbGx5IHJlcXVpcmUgbWFwYm94IG9ubHkgaW4gYnJvd3NlciB0byBhdm9pZCBpc3N1ZXMgdW5kZXIgbm9kZS5qc1xuLy8gTm9kZSBhcHBzIGNhbiB1c2UgU3RhdGljTWFwIGRpcmVjdGx5IC0gcmVxdWlyZXMgYWRkaW5nIGFkZGl0aW9uYWwgZGVwZW5kZW5jaWVzXG5pbXBvcnQge2lzQnJvd3Nlcn0gZnJvbSAnLi9nbG9iYWxzJztcbmNvbnN0IFN0YXRpY01hcCA9IGlzQnJvd3NlciA/IHJlcXVpcmUoJ3JlYWN0LW1hcC1nbCcpLlN0YXRpY01hcCA6IG51bGw7XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgZGlzcGxheUNvbnN0cmFpbnRzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZGlzcGxheUNvbnN0cmFpbnRzOiB7XG4gICAgbWF4UGl0Y2g6IDYwXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyYWN0aXZlTWFwIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgLy8gVE9ETyAtIFJlbW92ZSBvbmNlIFZpZXdwb3J0IGFsdGVybmF0aXZlIGlzIGdvb2QgZW5vdWdoXG4gIF9nZXRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5fbWFwO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGEgZGlzcGxheUNvbnN0cmFpbnRzIG9iamVjdCB0byBzZWUgaWYgdGhlIG1hcCBzaG91bGQgYmUgZGlzcGxheWVkXG4gIGNoZWNrRGlzcGxheUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgY29uc3QgY2FwaXRhbGl6ZSA9IHMgPT4gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcblxuICAgIGNvbnN0IHtkaXNwbGF5Q29uc3RyYWludHN9ID0gcHJvcHM7XG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgY29uc3QgY2FwaXRhbGl6ZWRQcm9wTmFtZSA9IGNhcGl0YWxpemUocHJvcE5hbWUpO1xuICAgICAgY29uc3QgbWluUHJvcE5hbWUgPSBgbWluJHtjYXBpdGFsaXplZFByb3BOYW1lfWA7XG4gICAgICBjb25zdCBtYXhQcm9wTmFtZSA9IGBtYXgke2NhcGl0YWxpemVkUHJvcE5hbWV9YDtcblxuICAgICAgaWYgKG1pblByb3BOYW1lIGluIGRpc3BsYXlDb25zdHJhaW50cyAmJiBwcm9wc1twcm9wTmFtZV0gPCBkaXNwbGF5Q29uc3RyYWludHNbbWluUHJvcE5hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhQcm9wTmFtZSBpbiBkaXNwbGF5Q29uc3RyYWludHMgJiYgcHJvcHNbcHJvcE5hbWVdID4gZGlzcGxheUNvbnN0cmFpbnRzW21heFByb3BOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIC8vIEJhaWwgb3V0IHVuZGVyIG5vZGVcbiAgICBpZiAoIVN0YXRpY01hcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwVmlzaWJsZSA9IHRoaXMuY2hlY2tEaXNwbGF5Q29uc3RyYWludHModGhpcy5wcm9wcyk7XG4gICAgY29uc3QgdmlzaWJpbGl0eSA9IG1hcFZpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcblxuICAgIHJldHVybiAoXG4gICAgICBjcmVhdGVFbGVtZW50KE1hcENvbnRyb2xzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIGtleTogJ21hcC1jb250cm9scycsXG4gICAgICAgIHN0eWxlOiB7cG9zaXRpb246ICdyZWxhdGl2ZSd9XG4gICAgICB9KSwgW1xuICAgICAgICBjcmVhdGVFbGVtZW50KFN0YXRpY01hcCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICAgIGtleTogJ21hcC1zdGF0aWMnLFxuICAgICAgICAgIHN0eWxlOiB7cG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IDAsIHRvcDogMCwgdmlzaWJpbGl0eX0sXG4gICAgICAgICAgcmVmOiBtYXAgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAga2V5OiAnbWFwLWNoaWxkcmVuJyxcbiAgICAgICAgICBzdHlsZToge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiAwLCB0b3A6IDB9XG4gICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cbn1cblxuSW50ZXJhY3RpdmVNYXAuZGlzcGxheU5hbWUgPSAnSW50ZXJhY3RpdmVNYXAnO1xuSW50ZXJhY3RpdmVNYXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuSW50ZXJhY3RpdmVNYXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19