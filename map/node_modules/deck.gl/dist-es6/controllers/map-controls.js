var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { PropTypes, PureComponent, createElement } from 'react';
import { PerspectiveMercatorViewport } from 'viewport-mercator-project';

// MapControls uses non-react event manager to register events
import EventManager from './event-manager';

// import browser from 'bowser';
var PREFIX = '-webkit-';
// browser.webkit || browser.blink ? '-webkit-' :
// browser.gecko ? '-moz-' :
// '';
var CURSOR = {
  GRABBING: PREFIX + 'grabbing',
  GRAB: PREFIX + 'grab',
  POINTER: 'pointer'
};

function mod(value, divisor) {
  var modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
// MAPBOX LIMITS
var MAX_PITCH = 60;
var MAX_ZOOM = 40;

// EVENT HANDLING PARAMETERS
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;

/* eslint-disable no-inline-comments */
var propTypes = {
  width: PropTypes.number.isRequired, // The width of the map
  height: PropTypes.number.isRequired, // The height of the map
  latitude: PropTypes.number.isRequired, // The latitude of the center of the map.
  longitude: PropTypes.number.isRequired, // The longitude of the center of the map.
  zoom: PropTypes.number.isRequired, // The tile zoom level of the map.
  bearing: PropTypes.number, // Specify the bearing of the viewport
  pitch: PropTypes.number, // Specify the pitch of the viewport
  altitude: PropTypes.number, // Altitude of viewport camera. Unit: map heights, default 1.5

  constraints: PropTypes.object,

  dragToRotate: PropTypes.bool, // Enables perspective control event handling

  onViewportChange: PropTypes.func, // `onViewportChange` is fired on user interaction

  isDragging: PropTypes.bool, // Is the component currently being dragged.
  startDragLngLat: PropTypes.arrayOf(PropTypes.number), // Position when current drag started
  startBearing: PropTypes.number, // Bearing when current perspective drag started
  startPitch: PropTypes.number, // Pitch when current perspective drag operation started

  pressKeyToRotate: PropTypes.bool, // If key must be pressed for mouse to rotate vs pan

  /* Hooks to get mapbox help with calculations. TODO - replace with Viewport */
  unproject: PropTypes.func,
  getLngLatAtPoint: PropTypes.func
};

var defaultProps = {
  bearing: 0,
  pitch: 0,
  altitude: 1.5,
  clickRadius: 15,
  onViewportChange: null,

  maxZoom: MAX_ZOOM,
  minZoom: 0,
  maxPitch: MAX_PITCH,
  minPitch: 0,

  unproject: null,
  getLngLatAtPoint: null,

  pressKeyToRotate: true
};

var MapControls = function (_PureComponent) {
  _inherits(MapControls, _PureComponent);

  /**
   * @classdesc
   * A component that monitors events and updates mercator style viewport parameters
   * It can be used with or without a mapbox map
   * (e.g. it could pan over a static map image)
   */
  function MapControls(props) {
    _classCallCheck(this, MapControls);

    var _this = _possibleConstructorReturn(this, (MapControls.__proto__ || Object.getPrototypeOf(MapControls)).call(this, props));

    _this.state = {
      isDragging: false,
      isHovering: false,
      startDragLngLat: null,
      startBearing: null,
      startPitch: null
    };
    return _this;
  }

  _createClass(MapControls, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // Register event handlers on the canvas using the EventManager helper class
      //
      // Note that mouse move and click are handled directly by static-map
      // Corresponding to hover and click on map
      // onMouseMove={this._onMouseMove}
      // onMouseClick={this._onMouseClick}

      this._eventManager = new EventManager(this.refs.canvas, {
        onMouseDown: this._onMouseDown.bind(this),
        onMouseDrag: this._onMouseDrag.bind(this),
        onMouseRotate: this._onMouseRotate.bind(this),
        onMouseUp: this._onMouseUp.bind(this),
        onZoom: this._onZoom.bind(this),
        onZoomEnd: this._onZoomEnd.bind(this),
        mapTouchToMouse: true,
        pressKeyToRotate: this.props.pressKeyToRotate
      });
    }

    // New props are comin' round the corner!

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      var startDragLngLat = newProps.startDragLngLat;

      this.setState({
        startDragLngLat: startDragLngLat && [].concat(_toConsumableArray(startDragLngLat))
      });
    }

    // Calculate a cursor style to show that we are in "dragging state"

  }, {
    key: '_getCursor',
    value: function _getCursor() {
      var isInteractive = this.props.onViewportChange || this.props.onClickFeature || this.props.onHoverFeatures;

      if (!isInteractive) {
        return 'inherit';
      }
      if (this.props.isDragging) {
        return CURSOR.GRABBING;
      }
      if (this.state.isHovering) {
        return CURSOR.POINTER;
      }
      return CURSOR.GRAB;
    }
  }, {
    key: '_updateViewport',
    value: function _updateViewport(opts) {
      var viewport = Object.assign({
        latitude: this.props.latitude,
        longitude: this.props.longitude,
        zoom: this.props.zoom,
        bearing: this.props.bearing,
        pitch: this.props.pitch,
        altitude: this.props.altitude,
        isDragging: this.props.isDragging,
        startDragLngLat: this.props.startDragLngLat,
        startBearing: this.props.startBearing,
        startPitch: this.props.startPitch
      }, opts);

      viewport = this._applyConstraints(viewport);

      return this.props.onViewportChange(viewport);
    }

    // Apply any constraints (mathematical or defined by props) to viewport params

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(viewport) {
      // Normalize degrees
      viewport.longitude = mod(viewport.longitude + 180, 360) - 180;
      viewport.bearing = mod(viewport.bearing + 180, 360) - 180;

      // Ensure zoom is within specified range
      var _props = this.props,
          maxZoom = _props.maxZoom,
          minZoom = _props.minZoom;

      viewport.zoom = viewport.zoom > maxZoom ? maxZoom : viewport.zoom;
      viewport.zoom = viewport.zoom < minZoom ? minZoom : viewport.zoom;

      // Ensure pitch is within specified range
      var _props2 = this.props,
          maxPitch = _props2.maxPitch,
          minPitch = _props2.minPitch;


      viewport.pitch = viewport.pitch > maxPitch ? maxPitch : viewport.pitch;
      viewport.pitch = viewport.pitch < minPitch ? minPitch : viewport.pitch;

      return viewport;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new PerspectiveMercatorViewport(Object.assign({}, this.props));
      var lngLat = this.props.unproject ? this.props.unproject(pos) : viewport.unproject(pos, { topLeft: false });
      return lngLat;
    }

    // Calculate a new lnglat based on pixel dragging position
    // TODO - We should have a mapbox-independent implementation of panning
    // Panning calculation is currently done using an undocumented mapbox function

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref) {
      var startDragLngLat = _ref.startDragLngLat,
          pos = _ref.pos,
          startPos = _ref.startPos;

      var viewport = new PerspectiveMercatorViewport(Object.assign({}, this.props, {
        longitude: startDragLngLat[0],
        latitude: startDragLngLat[1]
      }));

      var lngLat = this.props.getLngLatAtPoint ? this.props.getLngLatAtPoint({ lngLat: startDragLngLat, pos: pos }) : viewport.getLocationAtPoint({ lngLat: startDragLngLat, pos: pos });

      return lngLat;
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref2) {
      var relativeScale = _ref2.relativeScale;

      return this.props.zoom + Math.log2(relativeScale);
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos,
          startBearing = _ref3.startBearing,
          startPitch = _ref3.startPitch;
      var maxPitch = this.props.maxPitch;
      // TODO minPitch

      var xDelta = pos[0] - startPos[0];
      var yDelta = pos[1] - startPos[1];

      var bearing = startBearing + 180 * xDelta / this.props.width;

      var pitch = startPitch;
      if (yDelta > 0) {
        // Dragging downwards, gradually decrease pitch
        if (Math.abs(this.props.height - startPos[1]) > PITCH_MOUSE_THRESHOLD) {
          var scale = yDelta / (this.props.height - startPos[1]);
          pitch = (1 - scale) * PITCH_ACCEL * startPitch;
        }
      } else if (yDelta < 0) {
        // Dragging upwards, gradually increase pitch
        if (startPos[1] > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          var yScale = 1 - pos[1] / startPos[1];
          // Gradually add until we hit max pitch
          pitch = startPitch + yScale * (maxPitch - startPitch);
        }
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }

    // EVENT HANDLERS

  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(_ref4) {
      var pos = _ref4.pos;

      this._updateViewport({
        isDragging: true,
        startDragLngLat: this._unproject(pos),
        startBearing: this.props.bearing,
        startPitch: this.props.pitch
      });
    }
  }, {
    key: '_onMouseDrag',
    value: function _onMouseDrag(_ref5) {
      var pos = _ref5.pos;

      if (!this.props.onViewportChange) {
        return;
      }

      var startDragLngLat = this.state.startDragLngLat;

      // take the start lnglat and put it where the mouse is down.

      if (!startDragLngLat) {
        console.log( // eslint-disable-line
        startDragLngLat, '`startDragLngLat` prop is required ' + 'for mouse drag behavior to calculate where to position the map.');
        return;
      }
      // assert(startDragLngLat, '`startDragLngLat` prop is required ' +
      //   'for mouse drag behavior to calculate where to position the map.');

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startDragLngLat: startDragLngLat, pos: pos }),
          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      this._updateViewport({
        longitude: longitude,
        latitude: latitude,
        isDragging: true
      });
    }
  }, {
    key: '_onMouseRotate',
    value: function _onMouseRotate(_ref6) {
      var pos = _ref6.pos,
          startPos = _ref6.startPos;

      if (!this.props.onViewportChange || !this.props.dragToRotate) {
        return;
      }

      var _props3 = this.props,
          startBearing = _props3.startBearing,
          startPitch = _props3.startPitch;

      if (typeof startBearing !== 'number') {
        console.error( // eslint-disable-line
        '`startBearing` prop is required for mouse rotate behavior');
        return;
      }
      if (typeof startPitch !== 'number') {
        console.error( // eslint-disable-line
        '`startPitch` prop is required for mouse rotate behavior');
        return;
      }

      // assert(typeof startBearing === 'number',
      //   '`startBearing` prop is required for mouse rotate behavior');
      // assert(typeof startPitch === 'number',
      //   '`startPitch` prop is required for mouse rotate behavior');

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        pos: pos,
        startPos: startPos,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      this._updateViewport({
        bearing: bearing,
        pitch: pitch,
        isDragging: true
      });
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(opt) {
      this._updateViewport({
        isDragging: false,
        startDragLngLat: null,
        startBearing: null,
        startPitch: null
      });
    }
  }, {
    key: '_onZoom',
    value: function _onZoom(_ref7) {
      var pos = _ref7.pos,
          scale = _ref7.scale;

      // Make sure we zoom around the current mouse position rather than map center
      var viewport = new PerspectiveMercatorViewport(this.props);
      var aroundLngLat = viewport.unproject(pos);

      var zoom = this._calculateNewZoom({ relativeScale: scale });

      var zoomedViewport = new PerspectiveMercatorViewport(Object.assign({}, this.props, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: aroundLngLat, pos: pos }),
          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      this._updateViewport({
        zoom: this._calculateNewZoom({ relativeScale: scale }),
        longitude: longitude,
        latitude: latitude,
        isDragging: true
      });
    }
  }, {
    key: '_onZoomEnd',
    value: function _onZoomEnd() {
      this._updateViewport({ isDragging: false });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props4 = this.props,
          className = _props4.className,
          width = _props4.width,
          height = _props4.height,
          style = _props4.style;


      var mapEventLayerStyle = Object.assign({}, style, {
        width: width,
        height: height,
        position: 'relative',
        cursor: this._getCursor()
      });

      return createElement('div', {
        ref: 'canvas',
        style: mapEventLayerStyle,
        className: className
      }, this.props.children);
    }
  }]);

  return MapControls;
}(PureComponent);

export default MapControls;


MapControls.displayName = 'MapControls';
MapControls.propTypes = propTypes;
MapControls.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cm9sbGVycy9tYXAtY29udHJvbHMuanMiXSwibmFtZXMiOlsiUHJvcFR5cGVzIiwiUHVyZUNvbXBvbmVudCIsImNyZWF0ZUVsZW1lbnQiLCJQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQiLCJFdmVudE1hbmFnZXIiLCJQUkVGSVgiLCJDVVJTT1IiLCJHUkFCQklORyIsIkdSQUIiLCJQT0lOVEVSIiwibW9kIiwidmFsdWUiLCJkaXZpc29yIiwibW9kdWx1cyIsIk1BWF9QSVRDSCIsIk1BWF9aT09NIiwiUElUQ0hfTU9VU0VfVEhSRVNIT0xEIiwiUElUQ0hfQUNDRUwiLCJwcm9wVHlwZXMiLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJiZWFyaW5nIiwicGl0Y2giLCJhbHRpdHVkZSIsImNvbnN0cmFpbnRzIiwib2JqZWN0IiwiZHJhZ1RvUm90YXRlIiwiYm9vbCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJmdW5jIiwiaXNEcmFnZ2luZyIsInN0YXJ0RHJhZ0xuZ0xhdCIsImFycmF5T2YiLCJzdGFydEJlYXJpbmciLCJzdGFydFBpdGNoIiwicHJlc3NLZXlUb1JvdGF0ZSIsInVucHJvamVjdCIsImdldExuZ0xhdEF0UG9pbnQiLCJkZWZhdWx0UHJvcHMiLCJjbGlja1JhZGl1cyIsIm1heFpvb20iLCJtaW5ab29tIiwibWF4UGl0Y2giLCJtaW5QaXRjaCIsIk1hcENvbnRyb2xzIiwicHJvcHMiLCJzdGF0ZSIsImlzSG92ZXJpbmciLCJfZXZlbnRNYW5hZ2VyIiwicmVmcyIsImNhbnZhcyIsIm9uTW91c2VEb3duIiwiX29uTW91c2VEb3duIiwiYmluZCIsIm9uTW91c2VEcmFnIiwiX29uTW91c2VEcmFnIiwib25Nb3VzZVJvdGF0ZSIsIl9vbk1vdXNlUm90YXRlIiwib25Nb3VzZVVwIiwiX29uTW91c2VVcCIsIm9uWm9vbSIsIl9vblpvb20iLCJvblpvb21FbmQiLCJfb25ab29tRW5kIiwibWFwVG91Y2hUb01vdXNlIiwibmV3UHJvcHMiLCJzZXRTdGF0ZSIsImlzSW50ZXJhY3RpdmUiLCJvbkNsaWNrRmVhdHVyZSIsIm9uSG92ZXJGZWF0dXJlcyIsIm9wdHMiLCJ2aWV3cG9ydCIsIk9iamVjdCIsImFzc2lnbiIsIl9hcHBseUNvbnN0cmFpbnRzIiwicG9zIiwibG5nTGF0IiwidG9wTGVmdCIsInN0YXJ0UG9zIiwiZ2V0TG9jYXRpb25BdFBvaW50IiwicmVsYXRpdmVTY2FsZSIsIk1hdGgiLCJsb2cyIiwieERlbHRhIiwieURlbHRhIiwiYWJzIiwic2NhbGUiLCJ5U2NhbGUiLCJfdXBkYXRlVmlld3BvcnQiLCJfdW5wcm9qZWN0IiwiY29uc29sZSIsImxvZyIsIl9jYWxjdWxhdGVOZXdMbmdMYXQiLCJlcnJvciIsIl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmciLCJvcHQiLCJhcm91bmRMbmdMYXQiLCJfY2FsY3VsYXRlTmV3Wm9vbSIsInpvb21lZFZpZXdwb3J0IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJtYXBFdmVudExheWVyU3R5bGUiLCJwb3NpdGlvbiIsImN1cnNvciIsIl9nZXRDdXJzb3IiLCJyZWYiLCJjaGlsZHJlbiIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVFBLFNBQVIsRUFBbUJDLGFBQW5CLEVBQWtDQyxhQUFsQyxRQUFzRCxPQUF0RDtBQUNBLFNBQVFDLDJCQUFSLFFBQTBDLDJCQUExQzs7QUFFQTtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsaUJBQXpCOztBQUVBO0FBQ0EsSUFBTUMsU0FBUyxVQUFmO0FBQ0U7QUFDQTtBQUNBO0FBQ0YsSUFBTUMsU0FBUztBQUNiQyxZQUFhRixNQUFiLGFBRGE7QUFFYkcsUUFBU0gsTUFBVCxTQUZhO0FBR2JJLFdB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QUEwQixhQUExQjtBQUNBL0QsWUFBWS9CLFNBQVosR0FBd0JBLFNBQXhCO0FBQ0ErQixZQUFZTixZQUFaLEdBQTJCQSxZQUEzQiIsImZpbGUiOiJtYXAtY29udHJvbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IHtQcm9wVHlwZXMsIFB1cmVDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7UGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0fSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxuLy8gTWFwQ29udHJvbHMgdXNlcyBub24tcmVhY3QgZXZlbnQgbWFuYWdlciB0byByZWdpc3RlciBldmVudHNcbmltcG9ydCBFdmVudE1hbmFnZXIgZnJvbSAnLi9ldmVudC1tYW5hZ2VyJztcblxuLy8gaW1wb3J0IGJyb3dzZXIgZnJvbSAnYm93c2VyJztcbmNvbnN0IFBSRUZJWCA9ICctd2Via2l0LSc7XG4gIC8vIGJyb3dzZXIud2Via2l0IHx8IGJyb3dzZXIuYmxpbmsgPyAnLXdlYmtpdC0nIDpcbiAgLy8gYnJvd3Nlci5nZWNrbyA/ICctbW96LScgOlxuICAvLyAnJztcbmNvbnN0IENVUlNPUiA9IHtcbiAgR1JBQkJJTkc6IGAke1BSRUZJWH1ncmFiYmluZ2AsXG4gIEdSQUI6IGAke1BSRUZJWH1ncmFiYCxcbiAgUE9JTlRFUjogJ3BvaW50ZXInXG59O1xuXG5mdW5jdGlvbiBtb2QodmFsdWUsIGRpdmlzb3IpIHtcbiAgY29uc3QgbW9kdWx1cyA9IHZhbHVlICUgZGl2aXNvcjtcbiAgcmV0dXJuIG1vZHVsdXMgPCAwID8gZGl2aXNvciArIG1vZHVsdXMgOiBtb2R1bHVzO1xufVxuLy8gTUFQQk9YIExJTUlUU1xuY29uc3QgTUFYX1BJVENIID0gNjA7XG5jb25zdCBNQVhfWk9PTSA9IDQwO1xuXG4vLyBFVkVOVCBIQU5ETElORyBQQVJBTUVURVJTXG5jb25zdCBQSVRDSF9NT1VTRV9USFJFU0hPTEQgPSA1O1xuY29uc3QgUElUQ0hfQUNDRUwgPSAxLjI7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWlubGluZS1jb21tZW50cyAqL1xuY29uc3QgcHJvcFR5cGVzID0ge1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAvLyBUaGUgd2lkdGggb2YgdGhlIG1hcFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCwgLy8gVGhlIGhlaWdodCBvZiB0aGUgbWFwXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8vIFRoZSBsYXRpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gIGxvbmdpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAgLy8gVGhlIGxvbmdpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCwgLy8gVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxuICBiZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBTcGVjaWZ5IHRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydFxuICBwaXRjaDogUHJvcFR5cGVzLm51bWJlciwgLy8gU3BlY2lmeSB0aGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0XG4gIGFsdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBBbHRpdHVkZSBvZiB2aWV3cG9ydCBjYW1lcmEuIFVuaXQ6IG1hcCBoZWlnaHRzLCBkZWZhdWx0IDEuNVxuXG4gIGNvbnN0cmFpbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIGRyYWdUb1JvdGF0ZTogUHJvcFR5cGVzLmJvb2wsICAvLyBFbmFibGVzIHBlcnNwZWN0aXZlIGNvbnRyb2wgZXZlbnQgaGFuZGxpbmdcblxuICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYywgLy8gYG9uVmlld3BvcnRDaGFuZ2VgIGlzIGZpcmVkIG9uIHVzZXIgaW50ZXJhY3Rpb25cblxuICBpc0RyYWdnaW5nOiBQcm9wVHlwZXMuYm9vbCwgLy8gSXMgdGhlIGNvbXBvbmVudCBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZC5cbiAgc3RhcnREcmFnTG5nTGF0OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSwgLy8gUG9zaXRpb24gd2hlbiBjdXJyZW50IGRyYWcgc3RhcnRlZFxuICBzdGFydEJlYXJpbmc6IFByb3BUeXBlcy5udW1iZXIsIC8vIEJlYXJpbmcgd2hlbiBjdXJyZW50IHBlcnNwZWN0aXZlIGRyYWcgc3RhcnRlZFxuICBzdGFydFBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBQaXRjaCB3aGVuIGN1cnJlbnQgcGVyc3BlY3RpdmUgZHJhZyBvcGVyYXRpb24gc3RhcnRlZFxuXG4gIHByZXNzS2V5VG9Sb3RhdGU6IFByb3BUeXBlcy5ib29sLCAvLyBJZiBrZXkgbXVzdCBiZSBwcmVzc2VkIGZvciBtb3VzZSB0byByb3RhdGUgdnMgcGFuXG5cbiAgLyogSG9va3MgdG8gZ2V0IG1hcGJveCBoZWxwIHdpdGggY2FsY3VsYXRpb25zLiBUT0RPIC0gcmVwbGFjZSB3aXRoIFZpZXdwb3J0ICovXG4gIHVucHJvamVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIGdldExuZ0xhdEF0UG9pbnQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGJlYXJpbmc6IDAsXG4gIHBpdGNoOiAwLFxuICBhbHRpdHVkZTogMS41LFxuICBjbGlja1JhZGl1czogMTUsXG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG5cbiAgbWF4Wm9vbTogTUFYX1pPT00sXG4gIG1pblpvb206IDAsXG4gIG1heFBpdGNoOiBNQVhfUElUQ0gsXG4gIG1pblBpdGNoOiAwLFxuXG4gIHVucHJvamVjdDogbnVsbCxcbiAgZ2V0TG5nTGF0QXRQb2ludDogbnVsbCxcblxuICBwcmVzc0tleVRvUm90YXRlOiB0cnVlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBDb250cm9scyBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBBIGNvbXBvbmVudCB0aGF0IG1vbml0b3JzIGV2ZW50cyBhbmQgdXBkYXRlcyBtZXJjYXRvciBzdHlsZSB2aWV3cG9ydCBwYXJhbWV0ZXJzXG4gICAqIEl0IGNhbiBiZSB1c2VkIHdpdGggb3Igd2l0aG91dCBhIG1hcGJveCBtYXBcbiAgICogKGUuZy4gaXQgY291bGQgcGFuIG92ZXIgYSBzdGF0aWMgbWFwIGltYWdlKVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgaXNIb3ZlcmluZzogZmFsc2UsXG4gICAgICBzdGFydERyYWdMbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydEJlYXJpbmc6IG51bGwsXG4gICAgICBzdGFydFBpdGNoOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBjYW52YXMgdXNpbmcgdGhlIEV2ZW50TWFuYWdlciBoZWxwZXIgY2xhc3NcbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCBtb3VzZSBtb3ZlIGFuZCBjbGljayBhcmUgaGFuZGxlZCBkaXJlY3RseSBieSBzdGF0aWMtbWFwXG4gICAgLy8gQ29ycmVzcG9uZGluZyB0byBob3ZlciBhbmQgY2xpY2sgb24gbWFwXG4gICAgLy8gb25Nb3VzZU1vdmU9e3RoaXMuX29uTW91c2VNb3ZlfVxuICAgIC8vIG9uTW91c2VDbGljaz17dGhpcy5fb25Nb3VzZUNsaWNrfVxuXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0aGlzLnJlZnMuY2FudmFzLCB7XG4gICAgICBvbk1vdXNlRG93bjogdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKSxcbiAgICAgIG9uTW91c2VEcmFnOiB0aGlzLl9vbk1vdXNlRHJhZy5iaW5kKHRoaXMpLFxuICAgICAgb25Nb3VzZVJvdGF0ZTogdGhpcy5fb25Nb3VzZVJvdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgb25Nb3VzZVVwOiB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKSxcbiAgICAgIG9uWm9vbTogdGhpcy5fb25ab29tLmJpbmQodGhpcyksXG4gICAgICBvblpvb21FbmQ6IHRoaXMuX29uWm9vbUVuZC5iaW5kKHRoaXMpLFxuICAgICAgbWFwVG91Y2hUb01vdXNlOiB0cnVlLFxuICAgICAgcHJlc3NLZXlUb1JvdGF0ZTogdGhpcy5wcm9wcy5wcmVzc0tleVRvUm90YXRlXG4gICAgfSk7XG4gIH1cblxuICAvLyBOZXcgcHJvcHMgYXJlIGNvbWluJyByb3VuZCB0aGUgY29ybmVyIVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzKSB7XG4gICAgY29uc3Qge3N0YXJ0RHJhZ0xuZ0xhdH0gPSBuZXdQcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogc3RhcnREcmFnTG5nTGF0ICYmIFsuLi5zdGFydERyYWdMbmdMYXRdXG4gICAgfSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBjdXJzb3Igc3R5bGUgdG8gc2hvdyB0aGF0IHdlIGFyZSBpbiBcImRyYWdnaW5nIHN0YXRlXCJcbiAgX2dldEN1cnNvcigpIHtcbiAgICBjb25zdCBpc0ludGVyYWN0aXZlID1cbiAgICAgIHRoaXMucHJvcHMub25WaWV3cG9ydENoYW5nZSB8fFxuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrRmVhdHVyZSB8fFxuICAgICAgdGhpcy5wcm9wcy5vbkhvdmVyRmVhdHVyZXM7XG5cbiAgICBpZiAoIWlzSW50ZXJhY3RpdmUpIHtcbiAgICAgIHJldHVybiAnaW5oZXJpdCc7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybiBDVVJTT1IuR1JBQkJJTkc7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLmlzSG92ZXJpbmcpIHtcbiAgICAgIHJldHVybiBDVVJTT1IuUE9JTlRFUjtcbiAgICB9XG4gICAgcmV0dXJuIENVUlNPUi5HUkFCO1xuICB9XG5cbiAgX3VwZGF0ZVZpZXdwb3J0KG9wdHMpIHtcbiAgICBsZXQgdmlld3BvcnQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxhdGl0dWRlOiB0aGlzLnByb3BzLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiB0aGlzLnByb3BzLmxvbmdpdHVkZSxcbiAgICAgIHpvb206IHRoaXMucHJvcHMuem9vbSxcbiAgICAgIGJlYXJpbmc6IHRoaXMucHJvcHMuYmVhcmluZyxcbiAgICAgIHBpdGNoOiB0aGlzLnByb3BzLnBpdGNoLFxuICAgICAgYWx0aXR1ZGU6IHRoaXMucHJvcHMuYWx0aXR1ZGUsXG4gICAgICBpc0RyYWdnaW5nOiB0aGlzLnByb3BzLmlzRHJhZ2dpbmcsXG4gICAgICBzdGFydERyYWdMbmdMYXQ6IHRoaXMucHJvcHMuc3RhcnREcmFnTG5nTGF0LFxuICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLnByb3BzLnN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMucHJvcHMuc3RhcnRQaXRjaFxuICAgIH0sIG9wdHMpO1xuXG4gICAgdmlld3BvcnQgPSB0aGlzLl9hcHBseUNvbnN0cmFpbnRzKHZpZXdwb3J0KTtcblxuICAgIHJldHVybiB0aGlzLnByb3BzLm9uVmlld3BvcnRDaGFuZ2Uodmlld3BvcnQpO1xuICB9XG5cbiAgLy8gQXBwbHkgYW55IGNvbnN0cmFpbnRzIChtYXRoZW1hdGljYWwgb3IgZGVmaW5lZCBieSBwcm9wcykgdG8gdmlld3BvcnQgcGFyYW1zXG4gIF9hcHBseUNvbnN0cmFpbnRzKHZpZXdwb3J0KSB7XG4gICAgLy8gTm9ybWFsaXplIGRlZ3JlZXNcbiAgICB2aWV3cG9ydC5sb25naXR1ZGUgPSBtb2Qodmlld3BvcnQubG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICAgIHZpZXdwb3J0LmJlYXJpbmcgPSBtb2Qodmlld3BvcnQuYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcblxuICAgIC8vIEVuc3VyZSB6b29tIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCB7bWF4Wm9vbSwgbWluWm9vbX0gPSB0aGlzLnByb3BzO1xuICAgIHZpZXdwb3J0Lnpvb20gPSB2aWV3cG9ydC56b29tID4gbWF4Wm9vbSA/IG1heFpvb20gOiB2aWV3cG9ydC56b29tO1xuICAgIHZpZXdwb3J0Lnpvb20gPSB2aWV3cG9ydC56b29tIDwgbWluWm9vbSA/IG1pblpvb20gOiB2aWV3cG9ydC56b29tO1xuXG4gICAgLy8gRW5zdXJlIHBpdGNoIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCB7bWF4UGl0Y2gsIG1pblBpdGNofSA9IHRoaXMucHJvcHM7XG5cbiAgICB2aWV3cG9ydC5waXRjaCA9IHZpZXdwb3J0LnBpdGNoID4gbWF4UGl0Y2ggPyBtYXhQaXRjaCA6IHZpZXdwb3J0LnBpdGNoO1xuICAgIHZpZXdwb3J0LnBpdGNoID0gdmlld3BvcnQucGl0Y2ggPCBtaW5QaXRjaCA/IG1pblBpdGNoIDogdmlld3BvcnQucGl0Y2g7XG5cbiAgICByZXR1cm4gdmlld3BvcnQ7XG4gIH1cblxuICBfdW5wcm9qZWN0KHBvcykge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydChPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSk7XG4gICAgY29uc3QgbG5nTGF0ID0gdGhpcy5wcm9wcy51bnByb2plY3QgP1xuICAgICAgdGhpcy5wcm9wcy51bnByb2plY3QocG9zKSA6XG4gICAgICB2aWV3cG9ydC51bnByb2plY3QocG9zLCB7dG9wTGVmdDogZmFsc2V9KTtcbiAgICByZXR1cm4gbG5nTGF0O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IGxuZ2xhdCBiYXNlZCBvbiBwaXhlbCBkcmFnZ2luZyBwb3NpdGlvblxuICAvLyBUT0RPIC0gV2Ugc2hvdWxkIGhhdmUgYSBtYXBib3gtaW5kZXBlbmRlbnQgaW1wbGVtZW50YXRpb24gb2YgcGFubmluZ1xuICAvLyBQYW5uaW5nIGNhbGN1bGF0aW9uIGlzIGN1cnJlbnRseSBkb25lIHVzaW5nIGFuIHVuZG9jdW1lbnRlZCBtYXBib3ggZnVuY3Rpb25cbiAgX2NhbGN1bGF0ZU5ld0xuZ0xhdCh7c3RhcnREcmFnTG5nTGF0LCBwb3MsIHN0YXJ0UG9zfSkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydChPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBsb25naXR1ZGU6IHN0YXJ0RHJhZ0xuZ0xhdFswXSxcbiAgICAgIGxhdGl0dWRlOiBzdGFydERyYWdMbmdMYXRbMV1cbiAgICB9KSk7XG5cbiAgICBjb25zdCBsbmdMYXQgPSB0aGlzLnByb3BzLmdldExuZ0xhdEF0UG9pbnQgP1xuICAgICAgdGhpcy5wcm9wcy5nZXRMbmdMYXRBdFBvaW50KHtsbmdMYXQ6IHN0YXJ0RHJhZ0xuZ0xhdCwgcG9zfSkgOlxuICAgICAgdmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IHN0YXJ0RHJhZ0xuZ0xhdCwgcG9zfSk7XG5cbiAgICByZXR1cm4gbG5nTGF0O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyBuZXcgem9vbVxuICBfY2FsY3VsYXRlTmV3Wm9vbSh7cmVsYXRpdmVTY2FsZX0pIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy56b29tICsgTWF0aC5sb2cyKHJlbGF0aXZlU2NhbGUpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyBhIG5ldyBwaXRjaCBhbmQgYmVhcmluZyBmcm9tIGEgcG9zaXRpb24gKGNvbWluZyBmcm9tIGFuIGV2ZW50KVxuICBfY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nKHtwb3MsIHN0YXJ0UG9zLCBzdGFydEJlYXJpbmcsIHN0YXJ0UGl0Y2h9KSB7XG4gICAgY29uc3Qge21heFBpdGNofSA9IHRoaXMucHJvcHM7XG4gICAgLy8gVE9ETyBtaW5QaXRjaFxuXG4gICAgY29uc3QgeERlbHRhID0gcG9zWzBdIC0gc3RhcnRQb3NbMF07XG4gICAgY29uc3QgeURlbHRhID0gcG9zWzFdIC0gc3RhcnRQb3NbMV07XG5cbiAgICBjb25zdCBiZWFyaW5nID0gc3RhcnRCZWFyaW5nICsgMTgwICogeERlbHRhIC8gdGhpcy5wcm9wcy53aWR0aDtcblxuICAgIGxldCBwaXRjaCA9IHN0YXJ0UGl0Y2g7XG4gICAgaWYgKHlEZWx0YSA+IDApIHtcbiAgICAgIC8vIERyYWdnaW5nIGRvd253YXJkcywgZ3JhZHVhbGx5IGRlY3JlYXNlIHBpdGNoXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy5wcm9wcy5oZWlnaHQgLSBzdGFydFBvc1sxXSkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB5RGVsdGEgLyAodGhpcy5wcm9wcy5oZWlnaHQgLSBzdGFydFBvc1sxXSk7XG4gICAgICAgIHBpdGNoID0gKDEgLSBzY2FsZSkgKiBQSVRDSF9BQ0NFTCAqIHN0YXJ0UGl0Y2g7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh5RGVsdGEgPCAwKSB7XG4gICAgICAvLyBEcmFnZ2luZyB1cHdhcmRzLCBncmFkdWFsbHkgaW5jcmVhc2UgcGl0Y2hcbiAgICAgIGlmIChzdGFydFBvc1sxXSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBNb3ZlIGZyb20gMCB0byAxIGFzIHdlIGRyYWcgdXB3YXJkc1xuICAgICAgICBjb25zdCB5U2NhbGUgPSAxIC0gcG9zWzFdIC8gc3RhcnRQb3NbMV07XG4gICAgICAgIC8vIEdyYWR1YWxseSBhZGQgdW50aWwgd2UgaGl0IG1heCBwaXRjaFxuICAgICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggKyB5U2NhbGUgKiAobWF4UGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nXG4gICAgfTtcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMRVJTXG5cbiAgX29uTW91c2VEb3duKHtwb3N9KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe1xuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIHN0YXJ0RHJhZ0xuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcyksXG4gICAgICBzdGFydEJlYXJpbmc6IHRoaXMucHJvcHMuYmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMucHJvcHMucGl0Y2hcbiAgICB9KTtcbiAgfVxuXG4gIF9vbk1vdXNlRHJhZyh7cG9zfSkge1xuICAgIGlmICghdGhpcy5wcm9wcy5vblZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge3N0YXJ0RHJhZ0xuZ0xhdH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gdGFrZSB0aGUgc3RhcnQgbG5nbGF0IGFuZCBwdXQgaXQgd2hlcmUgdGhlIG1vdXNlIGlzIGRvd24uXG4gICAgaWYgKCFzdGFydERyYWdMbmdMYXQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHN0YXJ0RHJhZ0xuZ0xhdCwgJ2BzdGFydERyYWdMbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArXG4gICAgICAgICdmb3IgbW91c2UgZHJhZyBiZWhhdmlvciB0byBjYWxjdWxhdGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIG1hcC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXNzZXJ0KHN0YXJ0RHJhZ0xuZ0xhdCwgJ2BzdGFydERyYWdMbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArXG4gICAgLy8gICAnZm9yIG1vdXNlIGRyYWcgYmVoYXZpb3IgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBtYXAuJyk7XG5cbiAgICBjb25zdCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gPSB0aGlzLl9jYWxjdWxhdGVOZXdMbmdMYXQoe3N0YXJ0RHJhZ0xuZ0xhdCwgcG9zfSk7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9vbk1vdXNlUm90YXRlKHtwb3MsIHN0YXJ0UG9zfSkge1xuICAgIGlmICghdGhpcy5wcm9wcy5vblZpZXdwb3J0Q2hhbmdlIHx8ICF0aGlzLnByb3BzLmRyYWdUb1JvdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtzdGFydEJlYXJpbmcsIHN0YXJ0UGl0Y2h9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodHlwZW9mIHN0YXJ0QmVhcmluZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgJ2BzdGFydEJlYXJpbmdgIHByb3AgaXMgcmVxdWlyZWQgZm9yIG1vdXNlIHJvdGF0ZSBiZWhhdmlvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0UGl0Y2ggIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICdgc3RhcnRQaXRjaGAgcHJvcCBpcyByZXF1aXJlZCBmb3IgbW91c2Ugcm90YXRlIGJlaGF2aW9yJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXNzZXJ0KHR5cGVvZiBzdGFydEJlYXJpbmcgPT09ICdudW1iZXInLFxuICAgIC8vICAgJ2BzdGFydEJlYXJpbmdgIHByb3AgaXMgcmVxdWlyZWQgZm9yIG1vdXNlIHJvdGF0ZSBiZWhhdmlvcicpO1xuICAgIC8vIGFzc2VydCh0eXBlb2Ygc3RhcnRQaXRjaCA9PT0gJ251bWJlcicsXG4gICAgLy8gICAnYHN0YXJ0UGl0Y2hgIHByb3AgaXMgcmVxdWlyZWQgZm9yIG1vdXNlIHJvdGF0ZSBiZWhhdmlvcicpO1xuXG4gICAgY29uc3Qge3BpdGNoLCBiZWFyaW5nfSA9IHRoaXMuX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyh7XG4gICAgICBwb3MsXG4gICAgICBzdGFydFBvcyxcbiAgICAgIHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2hcbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXdwb3J0KHtcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaCxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9vbk1vdXNlVXAob3B0KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoe1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICBzdGFydERyYWdMbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydEJlYXJpbmc6IG51bGwsXG4gICAgICBzdGFydFBpdGNoOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICBfb25ab29tKHtwb3MsIHNjYWxlfSkge1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSB6b29tIGFyb3VuZCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiByYXRoZXIgdGhhbiBtYXAgY2VudGVyXG4gICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KHRoaXMucHJvcHMpO1xuICAgIGNvbnN0IGFyb3VuZExuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuXG4gICAgY29uc3Qgem9vbSA9IHRoaXMuX2NhbGN1bGF0ZU5ld1pvb20oe3JlbGF0aXZlU2NhbGU6IHNjYWxlfSk7XG5cbiAgICBjb25zdCB6b29tZWRWaWV3cG9ydCA9IG5ldyBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge3pvb219KSk7XG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gem9vbWVkVmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IGFyb3VuZExuZ0xhdCwgcG9zfSk7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3cG9ydCh7XG4gICAgICB6b29tOiB0aGlzLl9jYWxjdWxhdGVOZXdab29tKHtyZWxhdGl2ZVNjYWxlOiBzY2FsZX0pLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfb25ab29tRW5kKCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpZXdwb3J0KHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtjbGFzc05hbWUsIHdpZHRoLCBoZWlnaHQsIHN0eWxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBtYXBFdmVudExheWVyU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogdGhpcy5fZ2V0Q3Vyc29yKClcbiAgICB9KTtcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICByZWY6ICdjYW52YXMnLFxuICAgICAgc3R5bGU6IG1hcEV2ZW50TGF5ZXJTdHlsZSxcbiAgICAgIGNsYXNzTmFtZVxuICAgIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59XG5cbk1hcENvbnRyb2xzLmRpc3BsYXlOYW1lID0gJ01hcENvbnRyb2xzJztcbk1hcENvbnRyb2xzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbk1hcENvbnRyb2xzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==