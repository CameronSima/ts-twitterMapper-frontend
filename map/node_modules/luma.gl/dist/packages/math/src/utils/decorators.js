'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unary = unary;
exports.staticMethod = staticMethod;
exports.binary = binary;
exports.spread = spread;

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// From https://github.com/jayphelps/core-decorators.js, MIT license
function isDescriptor(descriptor) {
  if (!descriptor || !descriptor.hasOwnProperty) {
    return false;
  }

  var keys = ['value', 'initializer', 'get', 'set'];

  for (var i = 0, l = keys.length; i < l; i++) {
    if (descriptor.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

// From https://github.com/jayphelps/core-decorators.js, MIT license
function decorate(entryArgs, handleDescriptor) {
  if (isDescriptor(entryArgs[entryArgs.length - 1])) {
    return handleDescriptor.apply(undefined, _toConsumableArray(entryArgs).concat([[]]));
  }
  return function _decorate() {
    return handleDescriptor.apply(undefined, Array.prototype.slice.call(arguments).concat([entryArgs]));
  };
}

function unary() {
  for (var _len = arguments.length, decoratorArgs = Array(_len), _key = 0; _key < _len; _key++) {
    decoratorArgs[_key] = arguments[_key];
  }

  return decorate(decoratorArgs, function (target, methodKey, descriptor, _ref) {
    var _ref2 = _toArray(_ref);

    var Class = target.constructor;
    Class[methodKey] = function () {
      var _ref3;

      return (_ref3 = new Class())[methodKey].apply(_ref3, arguments);
    };
    return Object.assing({}, descriptor, {
      value: function unaryWrapper() {
        return descriptor.value.apply(this, arguments);
      }
    });
  });
}

function staticMethod() {
  for (var _len2 = arguments.length, decoratorArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    decoratorArgs[_key2] = arguments[_key2];
  }

  return decorate(decoratorArgs, function (target, methodKey, descriptor, _ref4) {
    var _ref5 = _toArray(_ref4);

    var Class = target.constructor;
    Class[methodKey] = function () {
      var _ref6;

      return (_ref6 = new Class())[methodKey].apply(_ref6, arguments);
    };
    return Object.assign({}, descriptor, {
      value: function staticMethodWrapper() {
        return descriptor.value.apply(this, arguments);
      }
    });
  });
}

function binary() {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return decorate(args, function (target, methodKey, descriptor, _ref7) {
    var _ref8 = _toArray(_ref7);

    var Class = target.constructor;
    Class[methodKey] = function (a, b) {
      return new Class().copy(a)[methodKey](b);
    };

    return Object.assign({}, descriptor, {
      value: function binaryWrapper() {
        return descriptor.value.apply(this, arguments);
      }
    });
  });
}

function spread() {
  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return decorate(args, function (target, methodKey, descriptor, _ref9) {
    var _ref10 = _toArray(_ref9);

    var Class = target.constructor;
    Class[methodKey] = function (a) {
      for (var _len5 = arguments.length, rest = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        rest[_key5 - 1] = arguments[_key5];
      }

      return rest.reduce(function (acc, elt) {
        return acc[methodKey](elt);
      }, new Class().copy(a));
    };

    return Object.assign({}, descriptor, {
      value: function spreadWrapper() {
        return descriptor.value.apply(this, arguments);
      }
    });
  });
}
//# sourceMappingURL=decorators.js.map